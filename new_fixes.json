[
    {
        "tag": "reentrancy",
        "url": "https://github.com/argentlabs/argent-contracts/commit/7f904ac5fe743711cfaf8461b8a867f001161434",
        "file": "contracts/modules/RecoveryManager.sol",
        "before": "// Copyright (C) 2018  Argent Labs Ltd. <https://argent.xyz>\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.5.4;\nimport \"./common/ArgentSafeMath.sol\";\nimport \"../wallet/BaseWallet.sol\";\nimport \"./common/BaseModule.sol\";\nimport \"./common/RelayerModule.sol\";\nimport \"./storage/GuardianStorage.sol\";\n\n/**\n * @title RecoveryManager\n * @dev Module to manage the recovery of a wallet owner.\n * Recovery is executed by a consensus of the wallet's guardians and takes\n * 24 hours before it can be finalized. Once finalised the ownership of the wallet\n * is transfered to a new address.\n * @author Julien Niset - <julien@argent.im>\n * @author Olivier Van Den Biggelaar - <olivier@argent.im>\n */\ncontract RecoveryManager is BaseModule, RelayerModule {\n\n    bytes32 constant NAME = \"RecoveryManager\";\n\n    bytes4 constant internal EXECUTE_RECOVERY_PREFIX = bytes4(keccak256(\"executeRecovery(address,address)\"));\n    bytes4 constant internal FINALIZE_RECOVERY_PREFIX = bytes4(keccak256(\"finalizeRecovery(address)\"));\n    bytes4 constant internal CANCEL_RECOVERY_PREFIX = bytes4(keccak256(\"cancelRecovery(address)\"));\n    bytes4 constant internal TRANSFER_OWNERSHIP_PREFIX = bytes4(keccak256(\"transferOwnership(address,address)\"));\n\n    struct RecoveryConfig {\n        address recovery;\n        uint64 executeAfter;\n        uint32 guardianCount;\n    }\n\n    // Wallet specific storage\n    mapping (address => RecoveryConfig) internal recoveryConfigs;\n\n    // Recovery period\n    uint256 public recoveryPeriod;\n    // Lock period\n    uint256 public lockPeriod;\n    // Security period used for (non-recovery) ownership transfer\n    uint256 public securityPeriod;\n    // Security window used for (non-recovery) ownership transfer\n    uint256 public securityWindow;\n\n    // *************** Events *************************** //\n\n    event RecoveryExecuted(address indexed wallet, address indexed _recovery, uint64 executeAfter);\n    event RecoveryFinalized(address indexed wallet, address indexed _recovery);\n    event RecoveryCanceled(address indexed wallet, address indexed _recovery);\n    event OwnershipTransfered(address indexed wallet, address indexed _newOwner);\n\n    // *************** Modifiers ************************ //\n\n    /**\n     * @dev Throws if there is no ongoing recovery procedure.\n     */\n    modifier onlyWhenRecovery(BaseWallet _wallet) {\n        require(recoveryConfigs[address(_wallet)].executeAfter > 0, \"RM: there must be an ongoing recovery\");\n        _;\n    }\n\n    /**\n     * @dev Throws if there is an ongoing recovery procedure.\n     */\n    modifier notWhenRecovery(BaseWallet _wallet) {\n        require(recoveryConfigs[address(_wallet)].executeAfter == 0, \"RM: there cannot be an ongoing recovery\");\n        _;\n    }\n\n    // *************** Constructor ************************ //\n\n    constructor(\n        ModuleRegistry _registry,\n        GuardianStorage _guardianStorage,\n        uint256 _recoveryPeriod,\n        uint256 _lockPeriod,\n        uint256 _securityPeriod,\n        uint256 _securityWindow\n    )\n        BaseModule(_registry, _guardianStorage, NAME)\n        public\n    {\n        require(_lockPeriod >= _recoveryPeriod && _recoveryPeriod >= _securityPeriod + _securityWindow, \"RM: insecure security periods\");\n        recoveryPeriod = _recoveryPeriod;\n        lockPeriod = _lockPeriod;\n        securityPeriod = _securityPeriod;\n        securityWindow = _securityWindow;\n    }\n\n    // *************** External functions ************************ //\n\n    /**\n     * @dev Lets the guardians start the execution of the recovery procedure.\n     * Once triggered the recovery is pending for the security period before it can\n     * be finalised.\n     * Must be confirmed by N guardians, where N = ((Nb Guardian + 1) / 2).\n     * @param _wallet The target wallet.\n     * @param _recovery The address to which ownership should be transferred.\n     */\n    function executeRecovery(BaseWallet _wallet, address _recovery) external onlyExecute notWhenRecovery(_wallet) {\n        require(_recovery != address(0), \"RM: recovery address cannot be null\");\n        RecoveryConfig storage config = recoveryConfigs[address(_wallet)];\n        config.recovery = _recovery;\n        config.executeAfter = uint64(now + recoveryPeriod);\n        config.guardianCount = uint32(guardianStorage.guardianCount(_wallet));\n        guardianStorage.setLock(_wallet, now + lockPeriod);\n        emit RecoveryExecuted(address(_wallet), _recovery, config.executeAfter);\n    }\n\n    /**\n     * @dev Finalizes an ongoing recovery procedure if the security period is over.\n     * The method is public and callable by anyone to enable orchestration.\n     * @param _wallet The target wallet.\n     */\n    function finalizeRecovery(BaseWallet _wallet) external onlyWhenRecovery(_wallet) {\n        RecoveryConfig storage config = recoveryConfigs[address(_wallet)];\n        require(uint64(now) > config.executeAfter, \"RM: the recovery period is not over yet\");\n        _wallet.setOwner(config.recovery);\n        emit RecoveryFinalized(address(_wallet), config.recovery);\n        guardianStorage.setLock(_wallet, 0);\n        delete recoveryConfigs[address(_wallet)];\n    }\n\n    /**\n     * @dev Lets the owner cancel an ongoing recovery procedure.\n     * Must be confirmed by N guardians, where N = ((Nb Guardian + 1) / 2) - 1.\n     * @param _wallet The target wallet.\n     */\n    function cancelRecovery(BaseWallet _wallet) external onlyExecute onlyWhenRecovery(_wallet) {\n        RecoveryConfig storage config = recoveryConfigs[address(_wallet)];\n        emit RecoveryCanceled(address(_wallet), config.recovery);\n        guardianStorage.setLock(_wallet, 0);\n        delete recoveryConfigs[address(_wallet)];\n    }\n\n    /**\n     * @dev Lets the owner start the execution of the ownership transfer procedure.\n     * Once triggered the ownership transfer is pending for the security period before it can\n     * be finalised.\n     * @param _wallet The target wallet.\n     * @param _newOwner The address to which ownership should be transferred.\n     */\n    function transferOwnership(BaseWallet _wallet, address _newOwner) external onlyExecute onlyWhenUnlocked(_wallet) {\n        require(_newOwner != address(0), \"RM: new owner address cannot be null\");\n        _wallet.setOwner(_newOwner);\n\n        emit OwnershipTransfered(address(_wallet), _newOwner);\n    }\n\n    /**\n    * @dev Gets the details of the ongoing recovery procedure if any.\n    * @param _wallet The target wallet.\n    */\n    function getRecovery(BaseWallet _wallet) public view returns(address _address, uint64 _executeAfter, uint32 _guardianCount) {\n        RecoveryConfig storage config = recoveryConfigs[address(_wallet)];\n        return (config.recovery, config.executeAfter, config.guardianCount);\n    }\n\n    // *************** Implementation of RelayerModule methods ********************* //\n\n    function getRequiredSignatures(BaseWallet _wallet, bytes memory _data) public view returns (uint256, OwnerSignature) {\n        bytes4 methodId = functionPrefix(_data);\n        if (methodId == EXECUTE_RECOVERY_PREFIX) {\n            uint numberOfSignaturesRequired = ArgentSafeMath.ceil(guardianStorage.guardianCount(_wallet), 2);\n            return (numberOfSignaturesRequired, OwnerSignature.Disallowed);\n        }\n        if (methodId == FINALIZE_RECOVERY_PREFIX) {\n            return (0, OwnerSignature.Required);\n        }\n        if (methodId == CANCEL_RECOVERY_PREFIX) {\n            uint numberOfSignaturesRequired = ArgentSafeMath.ceil(recoveryConfigs[address(_wallet)].guardianCount + 1, 2);\n            return (numberOfSignaturesRequired, OwnerSignature.Optional);\n        }\n        if (methodId == TRANSFER_OWNERSHIP_PREFIX) {\n            uint majorityGuardians = ArgentSafeMath.ceil(guardianStorage.guardianCount(_wallet), 2);\n            uint numberOfSignaturesRequired = SafeMath.add(majorityGuardians, 1);\n            return (numberOfSignaturesRequired, OwnerSignature.Required);\n        }\n\n        revert(\"RM: unknown method\");\n    }",
        "after": "// Copyright (C) 2018  Argent Labs Ltd. <https://argent.xyz>\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.5.4;\nimport \"./common/ArgentSafeMath.sol\";\nimport \"../wallet/BaseWallet.sol\";\nimport \"./common/BaseModule.sol\";\nimport \"./common/RelayerModule.sol\";\nimport \"./storage/GuardianStorage.sol\";\n\n/**\n * @title RecoveryManager\n * @dev Module to manage the recovery of a wallet owner.\n * Recovery is executed by a consensus of the wallet's guardians and takes\n * 24 hours before it can be finalized. Once finalised the ownership of the wallet\n * is transfered to a new address.\n * @author Julien Niset - <julien@argent.im>\n * @author Olivier Van Den Biggelaar - <olivier@argent.im>\n */\ncontract RecoveryManager is BaseModule, RelayerModule {\n\n    bytes32 constant NAME = \"RecoveryManager\";\n\n    bytes4 constant internal EXECUTE_RECOVERY_PREFIX = bytes4(keccak256(\"executeRecovery(address,address)\"));\n    bytes4 constant internal FINALIZE_RECOVERY_PREFIX = bytes4(keccak256(\"finalizeRecovery(address)\"));\n    bytes4 constant internal CANCEL_RECOVERY_PREFIX = bytes4(keccak256(\"cancelRecovery(address)\"));\n    bytes4 constant internal TRANSFER_OWNERSHIP_PREFIX = bytes4(keccak256(\"transferOwnership(address,address)\"));\n\n    struct RecoveryConfig {\n        address recovery;\n        uint64 executeAfter;\n        uint32 guardianCount;\n    }\n\n    // Wallet specific storage\n    mapping (address => RecoveryConfig) internal recoveryConfigs;\n\n    // Recovery period\n    uint256 public recoveryPeriod;\n    // Lock period\n    uint256 public lockPeriod;\n    // Security period used for (non-recovery) ownership transfer\n    uint256 public securityPeriod;\n    // Security window used for (non-recovery) ownership transfer\n    uint256 public securityWindow;\n\n    // *************** Events *************************** //\n\n    event RecoveryExecuted(address indexed wallet, address indexed _recovery, uint64 executeAfter);\n    event RecoveryFinalized(address indexed wallet, address indexed _recovery);\n    event RecoveryCanceled(address indexed wallet, address indexed _recovery);\n    event OwnershipTransfered(address indexed wallet, address indexed _newOwner);\n\n    // *************** Modifiers ************************ //\n\n    /**\n     * @dev Throws if there is no ongoing recovery procedure.\n     */\n    modifier onlyWhenRecovery(BaseWallet _wallet) {\n        require(recoveryConfigs[address(_wallet)].executeAfter > 0, \"RM: there must be an ongoing recovery\");\n        _;\n    }\n\n    /**\n     * @dev Throws if there is an ongoing recovery procedure.\n     */\n    modifier notWhenRecovery(BaseWallet _wallet) {\n        require(recoveryConfigs[address(_wallet)].executeAfter == 0, \"RM: there cannot be an ongoing recovery\");\n        _;\n    }\n\n    // *************** Constructor ************************ //\n\n    constructor(\n        ModuleRegistry _registry,\n        GuardianStorage _guardianStorage,\n        uint256 _recoveryPeriod,\n        uint256 _lockPeriod,\n        uint256 _securityPeriod,\n        uint256 _securityWindow\n    )\n        BaseModule(_registry, _guardianStorage, NAME)\n        public\n    {\n        require(_lockPeriod >= _recoveryPeriod && _recoveryPeriod >= _securityPeriod + _securityWindow, \"RM: insecure security periods\");\n        recoveryPeriod = _recoveryPeriod;\n        lockPeriod = _lockPeriod;\n        securityPeriod = _securityPeriod;\n        securityWindow = _securityWindow;\n    }\n\n    // *************** External functions ************************ //\n\n    /**\n     * @dev Lets the guardians start the execution of the recovery procedure.\n     * Once triggered the recovery is pending for the security period before it can\n     * be finalised.\n     * Must be confirmed by N guardians, where N = ((Nb Guardian + 1) / 2).\n     * @param _wallet The target wallet.\n     * @param _recovery The address to which ownership should be transferred.\n     */\n    function executeRecovery(BaseWallet _wallet, address _recovery) external onlyExecute notWhenRecovery(_wallet) {\n        require(_recovery != address(0), \"RM: recovery address cannot be null\");\n        RecoveryConfig storage config = recoveryConfigs[address(_wallet)];\n        config.recovery = _recovery;\n        config.executeAfter = uint64(now + recoveryPeriod);\n        config.guardianCount = uint32(guardianStorage.guardianCount(_wallet));\n        guardianStorage.setLock(_wallet, now + lockPeriod);\n        emit RecoveryExecuted(address(_wallet), _recovery, config.executeAfter);\n    }\n\n    /**\n     * @dev Finalizes an ongoing recovery procedure if the security period is over.\n     * The method is public and callable by anyone to enable orchestration.\n     * @param _wallet The target wallet.\n     */\n    function finalizeRecovery(BaseWallet _wallet) external onlyWhenRecovery(_wallet) {\n        RecoveryConfig storage config = recoveryConfigs[address(_wallet)];\n        require(uint64(now) > config.executeAfter, \"RM: the recovery period is not over yet\");\n        address recoveryOwner = config.recovery;\n        delete recoveryConfigs[address(_wallet)];\n        _wallet.setOwner(recoveryOwner);\n        guardianStorage.setLock(_wallet, 0);\n        emit RecoveryFinalized(address(_wallet), config.recovery);\n    }\n\n    /**\n     * @dev Lets the owner cancel an ongoing recovery procedure.\n     * Must be confirmed by N guardians, where N = ((Nb Guardian + 1) / 2) - 1.\n     * @param _wallet The target wallet.\n     */\n    function cancelRecovery(BaseWallet _wallet) external onlyExecute onlyWhenRecovery(_wallet) {\n        RecoveryConfig storage config = recoveryConfigs[address(_wallet)];\n        delete recoveryConfigs[address(_wallet)];\n        guardianStorage.setLock(_wallet, 0);\n        emit RecoveryCanceled(address(_wallet), config.recovery);\n    }\n\n    /**\n     * @dev Lets the owner start the execution of the ownership transfer procedure.\n     * Once triggered the ownership transfer is pending for the security period before it can\n     * be finalised.\n     * @param _wallet The target wallet.\n     * @param _newOwner The address to which ownership should be transferred.\n     */\n    function transferOwnership(BaseWallet _wallet, address _newOwner) external onlyExecute onlyWhenUnlocked(_wallet) {\n        require(_newOwner != address(0), \"RM: new owner address cannot be null\");\n        _wallet.setOwner(_newOwner);\n\n        emit OwnershipTransfered(address(_wallet), _newOwner);\n    }\n\n    /**\n    * @dev Gets the details of the ongoing recovery procedure if any.\n    * @param _wallet The target wallet.\n    */\n    function getRecovery(BaseWallet _wallet) public view returns(address _address, uint64 _executeAfter, uint32 _guardianCount) {\n        RecoveryConfig storage config = recoveryConfigs[address(_wallet)];\n        return (config.recovery, config.executeAfter, config.guardianCount);\n    }\n\n    // *************** Implementation of RelayerModule methods ********************* //\n\n    function getRequiredSignatures(BaseWallet _wallet, bytes memory _data) public view returns (uint256, OwnerSignature) {\n        bytes4 methodId = functionPrefix(_data);\n        if (methodId == EXECUTE_RECOVERY_PREFIX) {\n            uint numberOfSignaturesRequired = ArgentSafeMath.ceil(guardianStorage.guardianCount(_wallet), 2);\n            return (numberOfSignaturesRequired, OwnerSignature.Disallowed);\n        }\n        if (methodId == FINALIZE_RECOVERY_PREFIX) {\n            return (0, OwnerSignature.Required);\n        }\n        if (methodId == CANCEL_RECOVERY_PREFIX) {\n            uint numberOfSignaturesRequired = ArgentSafeMath.ceil(recoveryConfigs[address(_wallet)].guardianCount + 1, 2);\n            return (numberOfSignaturesRequired, OwnerSignature.Optional);\n        }\n        if (methodId == TRANSFER_OWNERSHIP_PREFIX) {\n            uint majorityGuardians = ArgentSafeMath.ceil(guardianStorage.guardianCount(_wallet), 2);\n            uint numberOfSignaturesRequired = SafeMath.add(majorityGuardians, 1);\n            return (numberOfSignaturesRequired, OwnerSignature.Required);\n        }\n\n        revert(\"RM: unknown method\");\n    }"
    },
    {
        "tag": "arithmetic",
        "url": "https://github.com/kleros/kleros/commit/4162c9ed060eb83c13025312fcadcec042b4c1db",
        "file": "contracts/Kleros.sol",
        "before": "/**\n *  @title Kleros\n *  @author Clément Lesaege - <clement@lesaege.com>\n *  This code implements a simple version of Kleros.\n *  Bug Bounties: This code hasn't undertaken a bug bounty program yet.\n */\npragma solidity ^0.4.15;\nimport \"kleros-interaction/contracts/standard/arbitration/Arbitrator.sol\";\nimport {MiniMeTokenERC20 as Pinakion} from \"kleros-interaction/contracts/standard/arbitration/ArbitrableTokens/MiniMeTokenERC20.sol\";\nimport \"kleros-interaction/contracts/standard/rng/RNG.sol\";\nimport {ApproveAndCallFallBack} from \"minimetoken/contracts/MiniMeToken.sol\";\ncontract Kleros is Arbitrator, ApproveAndCallFallBack {\n    // **************************** //\n    // *    Contract variables    * //\n    // **************************** //\n    // Variables which should not change after initialization.\n    Pinakion public pinakion;\n    uint public constant NON_PAYABLE_AMOUNT = (2**256 - 2) / 2; // An astronomic amount, practically can't be paid.\n    // Variables which will subject to the governance mechanism.\n    // Note they will only be able to be changed during the activation period (because a session assumes they don't change after it).\n    RNG public rng; // Random Number Generator used to draw jurors.\n    uint public arbitrationFeePerJuror = 0.05 ether; // The fee which will be paid to each juror.\n    uint16 public defaultNumberJuror = 3; // Number of drawn jurors unless specified otherwise.\n    uint public minActivatedToken = 0.1 * 1e18; // Minimum of tokens to be activated (in basic units).\n    uint[5] public timePerPeriod; // The minimum time each period lasts (seconds).\n    uint public alpha = 2000; // alpha in ‱.\n    uint constant ALPHA_DIVISOR = 1e4; // Amount we need to divided alpha in ‱ to get the float value of alpha.\n    uint public maxAppeals = 5; // Number of times a dispute can be appealed. When exceeded appeal cost becomes NON_PAYABLE_AMOUNT.\n    // Initially, the governor will be an address controlled by the Kleros team. At a later stage,\n    // the governor will be switched to a governance contract with liquid voting.\n    address public governor; // Address of the governor contract.\n    // Variables changing during day to day interaction.\n    uint public session = 1;      // Current session of the court.\n    uint public lastPeriodChange; // The last time we changed of period (seconds).\n    uint public segmentSize;      // Size of the segment of activated tokens.\n    uint public rnBlock;          // The block linked with the RN which is requested.\n    uint public randomNumber;     // Random number of the session.\n    enum Period {\n        Activation, // When juror can deposit their tokens and parties give evidences.\n        Draw,       // When jurors are drawn at random, note that this period is fast.\n        Vote,       // Where jurors can vote on disputes.\n        Appeal,     // When parties can appeal the rulings.\n        Execution   // When where token redistribution occurs and Kleros call the arbitrated contracts.\n    }\n    Period public period;\n    struct Juror {\n        uint balance;      // The amount of tokens the contract holds for this juror.\n        uint atStake;      // Total number of tokens the jurors can loose in disputes they are drawn in. Those tokens are locked. Note that we can have atStake > balance but it should be statistically unlikely and does not pose issues.\n        uint lastSession;  // Last session the tokens were activated.\n        uint segmentStart; // Start of the segment of activated tokens.\n        uint segmentEnd;   // End of the segment of activated tokens.\n    }\n    mapping (address => Juror) public jurors;\n    struct Vote {\n        address account; // The juror who casted the vote.\n        uint ruling;     // The ruling which was given.\n    }\n    struct VoteCounter {\n        uint winningChoice; // The choice which currently has the highest amount of votes. Is 0 in case of a tie.\n        uint winningCount;  // The number of votes for winningChoice. Or for the choices which are tied.\n        mapping (uint => uint) voteCount; // voteCount[choice] is the number of votes for choice.\n    }\n    enum DisputeState {\n        Open,       // The dispute is opened but the outcome is not available yet (this include when jurors voted but appeal is still possible).\n        Resolving,  // The token repartition has started. Note that if it's done in just one call, this state is skipped.\n        Executable, // The arbitrated contract can be called to enforce the decision.\n        Executed    // Everything has been done and the dispute can't be interacted with anymore.\n    }\n    struct Dispute {\n        Arbitrable arbitrated;       // Contract to be arbitrated.\n        uint session;                // First session the dispute was schedule.\n        uint appeals;                // Number of appeals.\n        uint choices;                // The number of choices available to the jurors.\n        uint16 initialNumberJurors;  // The initial number of jurors.\n        uint arbitrationFeePerJuror; // The fee which will be paid to each juror.\n        DisputeState state;          // The state of the dispute.\n        Vote[][] votes;              // The votes in the form vote[appeals][voteID].\n        VoteCounter[] voteCounter;   // The vote counters in the form voteCounter[appeals].\n        mapping (address => uint) lastSessionVote; // Last session a juror has voted on this dispute. Is 0 if he never did.\n        uint currentAppealToRepartition; // The current appeal we are repartitioning.\n        AppealsRepartitioned[] appealsRepartitioned; // Track a partially repartitioned appeal in the form AppealsRepartitioned[appeal].\n    }\n    enum RepartitionStage { // State of the token repartition if oneShotTokenRepartition would throw because there are too many votes.\n        Incoherent,\n        Coherent,\n        AtStake,\n        Complete\n    }\n    struct AppealsRepartitioned {\n        uint totalToRedistribute;   // Total amount of tokens we have to redistribute.\n        uint nbCoherent;            // Number of coherent jurors for session.\n        uint currentIncoherentVote; // Current vote for the incoherent loop.\n        uint currentCoherentVote;   // Current vote we need to count.\n        uint currentAtStakeVote;    // Current vote we need to count.\n        RepartitionStage stage;     // Use with multipleShotTokenRepartition if oneShotTokenRepartition would throw.\n    }\n    Dispute[] public disputes;\n    // **************************** //\n    // *          Events          * //\n    // **************************** //\n    /** @dev Emitted when we pass to a new period.\n     *  @param _period The new period.\n     *  @param _session The current session.\n     */\n    event NewPeriod(Period _period, uint indexed _session);\n    /** @dev Emitted when a juror wins or loses tokens.\n      * @param _account The juror affected.\n      * @param _disputeID The ID of the dispute.\n      * @param _amount The amount of parts of token which was won. Can be negative for lost amounts.\n      */\n    event TokenShift(address indexed _account, uint _disputeID, int _amount);\n    /** @dev Emited when a juror wins arbitration fees.\n      * @param _account The account affected.\n      * @param _disputeID The ID of the dispute.\n      * @param _amount The amount of weis which was won.\n      */\n    event ArbitrationReward(address indexed _account, uint _disputeID, uint _amount);\n    // **************************** //\n    // *         Modifiers        * //\n    // **************************** //\n    modifier onlyBy(address _account) {require(msg.sender == _account); _;}\n    modifier onlyDuring(Period _period) {require(period == _period); _;}\n    modifier onlyGovernor() {require(msg.sender == governor); _;}\n    /** @dev Constructor.\n     *  @param _pinakion The address of the pinakion contract.\n     *  @param _rng The random number generator which will be used.\n     *  @param _timePerPeriod The minimal time for each period (seconds).\n     *  @param _governor Address of the governor contract.\n     */\n    function Kleros(Pinakion _pinakion, RNG _rng, uint[5] _timePerPeriod, address _governor) public {\n        pinakion = _pinakion;\n        rng = _rng;\n        lastPeriodChange = now;\n        timePerPeriod = _timePerPeriod;\n        governor = _governor;\n    }\n    // **************************** //\n    // *  Functions interacting   * //\n    // *  with Pinakion contract  * //\n    // **************************** //\n    /** @dev Callback of approveAndCall - transfer pinakions of a juror in the contract. Should be called by the pinakion contract. TRUSTED.\n     *  @param _from The address making the transfer.\n     *  @param _amount Amount of tokens to transfer to Kleros (in basic units).\n     */\n    function receiveApproval(address _from, uint _amount, address, bytes) public onlyBy(pinakion) {\n        require(pinakion.transferFrom(_from, this, _amount));\n        jurors[_from].balance += _amount;\n    }\n    /** @dev Withdraw tokens. Note that we can't withdraw the tokens which are still atStake. \n     *  Jurors can't withdraw their tokens if they have deposited some during this session.\n     *  This is to prevent jurors from withdrawing tokens they could loose.\n     *  @param _value The amount to withdraw.\n     */\n    function withdraw(uint _value) public {\n        Juror storage juror = jurors[msg.sender];\n        require(juror.atStake <= juror.balance); // Make sure that there is no more at stake than owned to avoid overflow.\n        require(_value <= juror.balance-juror.atStake);\n        require(juror.lastSession != session);\n        juror.balance -= _value;\n        require(pinakion.transfer(msg.sender,_value));\n    }\n    // **************************** //\n    // *      Court functions     * //\n    // *    Modifying the state   * //\n    // **************************** //\n    /** @dev To call to go to a new period. TRUSTED.\n     */\n    function passPeriod() public {\n        require(now-lastPeriodChange >= timePerPeriod[uint8(period)]);\n        if (period == Period.Activation) {\n            rnBlock = block.number + 1;\n            rng.requestRN(rnBlock);\n            period = Period.Draw;\n        } else if (period == Period.Draw) {\n            randomNumber = rng.getUncorrelatedRN(rnBlock);\n            require(randomNumber != 0);\n            period = Period.Vote;\n        } else if (period == Period.Vote) {\n            period = Period.Appeal;\n        } else if (period == Period.Appeal) {\n            period = Period.Execution;\n        } else if (period == Period.Execution) {\n            period = Period.Activation;\n            ++session;\n            segmentSize = 0;\n            rnBlock = 0;\n            randomNumber = 0;\n        }\n        lastPeriodChange = now;\n        NewPeriod(period, session);\n    }\n    /** @dev Activate tokens in order to have chances of being drawn. Note that once tokens are activated, \n     *  there is no possibility of activating more.\n     *  @param _value Amount of fractions of token to activate.\n     */\n    function activateTokens(uint _value) public onlyDuring(Period.Activation) {\n        Juror storage juror = jurors[msg.sender];\n        require(_value <= juror.balance);\n        require(_value >= minActivatedToken);\n        require(juror.lastSession != session); // Verify that tokens were not already activated for this session.\n        juror.lastSession = session;\n        juror.segmentStart = segmentSize;\n        segmentSize += _value;\n        juror.segmentEnd = segmentSize;\n    }\n    /** @dev Vote a ruling. Juror must input the draw ID he was drawn.\n     *  Note that the complexity is O(d), where d is amount of times the juror was drawn.\n     *  Since being drawn multiple time is a rare occurrence and that a juror can always vote with less weight than it has, it is not a problem.\n     *  @param _disputeID The ID of the dispute the juror was drawn.\n     *  @param _ruling The ruling given.\n     *  @param _draws The list of draws the juror was drawn. It draw numbering starts at 1 and the numbers should be increasing.\n     */\n    function voteRuling(uint _disputeID, uint _ruling, uint[] _draws) public onlyDuring(Period.Vote) {\n        Dispute storage dispute = disputes[_disputeID];\n        Juror storage juror = jurors[msg.sender];\n        VoteCounter storage voteCounter = dispute.voteCounter[dispute.appeals];\n        require(dispute.lastSessionVote[msg.sender] != session); // Make sure juror hasn't voted yet.\n        require(_ruling <= dispute.choices);\n        // Note that it throws if the draws are incorrect.\n        require(validDraws(msg.sender, _disputeID, _draws));\n        dispute.lastSessionVote[msg.sender] = session;\n        voteCounter.voteCount[_ruling] += _draws.length;\n        if (voteCounter.winningCount < voteCounter.voteCount[_ruling]) {\n            voteCounter.winningCount = voteCounter.voteCount[_ruling];\n            voteCounter.winningChoice = _ruling;\n        } else if (voteCounter.winningCount==voteCounter.voteCount[_ruling] && _draws.length!=0) {\n            voteCounter.winningChoice = 0; // It's currently a tie.\n        }\n        for (uint i = 0; i < _draws.length; ++i) {\n            dispute.votes[dispute.appeals].push(Vote({\n                account: msg.sender,\n                ruling: _ruling\n            }));\n        }\n        juror.atStake += _draws.length * getStakePerDraw();\n        uint feeToPay = _draws.length * dispute.arbitrationFeePerJuror;\n        msg.sender.transfer(feeToPay);\n        ArbitrationReward(msg.sender, _disputeID, feeToPay);\n    }\n    /** @dev Steal part of the tokens of a juror who failed to vote.\n     *  Note that a juror who voted but without all his weight can't be penalized.\n     *  @param _jurorAddress Address of the juror to steal tokens from.\n     *  @param _disputeID The ID of the dispute the juror was drawn.\n     *  @param _draws The list of draws the juror was drawn. Numbering starts at 1 and the numbers should be increasing.\n     */\n    function penalizeInactiveJuror(address _jurorAddress, uint _disputeID, uint[] _draws) public {\n        Dispute storage dispute = disputes[_disputeID];\n        Juror storage inactiveJuror = jurors[_jurorAddress];\n        require(period > Period.Vote);\n        require(dispute.lastSessionVote[_jurorAddress] != session); // Verify the juror hasn't voted.\n        dispute.lastSessionVote[_jurorAddress] = session;\n        require(validDraws(_jurorAddress, _disputeID, _draws));\n        uint penality = _draws.length * minActivatedToken * 2 * alpha / ALPHA_DIVISOR;\n        penality = (penality < inactiveJuror.balance-inactiveJuror.atStake) ? penality : inactiveJuror.balance-inactiveJuror.atStake; // Make sure the penality is not higher than what the juror can lose.\n        inactiveJuror.balance -= penality;\n        jurors[msg.sender].balance += penality / 2; // Give half of the penalty to the caller.\n        jurors[this].balance += penality / 2; // The other half to Kleros.\n\n    \n          \n            \n    \n\n          \n          Expand Down\n    \n    \n  \n        msg.sender.transfer(_draws.length*dispute.arbitrationFeePerJuror);\n    }\n    /** @dev Execute all the token repartition.\n     *  Note that this function could consume to much gas if there is too much votes. \n     *  It is O(v), where v is the number of votes for this dispute.\n     *  In the next version, there will also be a function to execute it in multiple calls \n     *  (but note that one shot execution, if possible, is less expensive).\n     *  @param _disputeID ID of the dispute.\n     */\n    function oneShotTokenRepartition(uint _disputeID) public onlyDuring(Period.Execution) {\n        Dispute storage dispute = disputes[_disputeID];\n        require(dispute.state == DisputeState.Open);\n        require(dispute.session+dispute.appeals <= session);\n        uint winningChoice = dispute.voteCounter[dispute.appeals].winningChoice;\n        uint amountShift = getStakePerDraw();\n        for (uint i = 0; i <= dispute.appeals; ++i) {\n            // If the result is not a tie, some parties are incoherent. Note that 0 (refuse to arbitrate) winning is not a tie.\n            // Result is a tie if the winningChoice is 0 (refuse to arbitrate) and the choice 0 is not the most voted choice.\n            // Note that in case of a \"tie\" among some choices including 0, parties who did not vote 0 are considered incoherent.\n            if (winningChoice!=0 || (dispute.voteCounter[dispute.appeals].voteCount[0] == dispute.voteCounter[dispute.appeals].winningCount)) {\n                uint totalToRedistribute = 0;\n                uint nbCoherent = 0;\n                // First loop to penalize the incoherent votes.\n                for (uint j = 0; j < dispute.votes[i].length; ++j) {\n                    Vote storage vote = dispute.votes[i][j];\n                    if (vote.ruling != winningChoice) {\n                        Juror storage juror = jurors[vote.account];\n                        uint penalty = amountShift<juror.balance ? amountShift : juror.balance;\n                        juror.balance -= penalty;\n                        TokenShift(vote.account, _disputeID, int(-penalty));\n                        totalToRedistribute += penalty;\n                    } else {\n                        ++nbCoherent;\n                    }\n                }\n                if (nbCoherent == 0) { // No one was coherent at this stage. Take the tokens.\n                    jurors[this].balance += totalToRedistribute;\n                } else { // otherwise, redistribute them.\n                    uint toRedistribute = totalToRedistribute / nbCoherent; // Note that few fractions of tokens can be lost but due to the high amount of decimals we don't care.\n                    // Second loop to redistribute.\n                    for (j = 0; j < dispute.votes[i].length; ++j) {\n                        vote = dispute.votes[i][j];\n                        if (vote.ruling == winningChoice) {\n                            juror = jurors[vote.account];\n                            juror.balance += toRedistribute;\n                            TokenShift(vote.account, _disputeID, int(toRedistribute));\n                        }\n                    }\n                }\n            }\n            // Third loop to lower the atStake in order to unlock tokens.\n            for (j = 0; j < dispute.votes[i].length; ++j) {\n                vote = dispute.votes[i][j];\n                juror = jurors[vote.account];\n                juror.atStake -= amountShift; // Note that it can't underflow due to amountShift not changing between vote and redistribution.\n            }\n        }\n        dispute.state = DisputeState.Executable; // Since it was solved in one shot, go directly to the executable step.\n    }\n    /** @dev Execute token repartition on a dispute for a specific number of votes.\n     *  This should only be called if oneShotTokenRepartition will throw because there are too many votes (will use too much gas).\n     *  Note There are 3 iterations per vote. e.g. A dispute with 1 appeal (2 sessions) and 3 votes per session will have 18 iterations\n     *  @param _disputeId ID of the dispute.\n     *  @param _maxIterations the maxium number of votes to repartition in this iteration\n     */\n    function multipleShotTokenRepartition(uint _disputeId, uint _maxIterations) public onlyDuring(Period.Execution) {\n        Dispute storage dispute = disputes[_disputeId];\n        require(dispute.state <= DisputeState.Resolving);\n        require(dispute.session+dispute.appeals <= session);\n        dispute.state = DisputeState.Resolving; // mark as resolving so oneShotTokenRepartition cannot be called on dispute\n        uint winningChoice = dispute.voteCounter[dispute.appeals].winningChoice;\n        uint amountShift = getStakePerDraw();\n        uint currentIterations = 0; // total votes we have repartitioned this iteration\n        for (uint i = dispute.currentAppealToRepartition; i <= dispute.appeals; ++i) {\n            // make new AppealsRepartitioned\n            if (dispute.appealsRepartitioned.length < i+1) {\n                dispute.appealsRepartitioned.length++;\n            }\n            // If the result is a tie, no parties are incoherent and no need to move tokens. Note that 0 (refuse to arbitrate) winning is not a tie.\n            if (winningChoice==0 && (dispute.voteCounter[dispute.appeals].voteCount[0] != dispute.voteCounter[dispute.appeals].winningCount)) {\n                // if ruling is a tie we can skip to at stake\n                dispute.appealsRepartitioned[i].stage = RepartitionStage.AtStake;\n            }\n            // First loop to penalize the incoherent votes.\n            if (dispute.appealsRepartitioned[i].stage == RepartitionStage.Incoherent) {\n                for (uint j = dispute.appealsRepartitioned[i].currentIncoherentVote; j < dispute.votes[i].length; ++j) {\n                    if (currentIterations >= _maxIterations) {\n                        return;\n                    }\n                    Vote storage vote = dispute.votes[i][j];\n                    if (vote.ruling != winningChoice) {\n                        Juror storage juror = jurors[vote.account];\n                        uint penalty = amountShift<juror.balance ? amountShift : juror.balance;\n                        juror.balance -= penalty;\n                        TokenShift(vote.account, _disputeId, int(-penalty));\n                        dispute.appealsRepartitioned[i].totalToRedistribute += penalty;\n                    } else {\n                        ++dispute.appealsRepartitioned[i].nbCoherent;\n                    }\n                    ++dispute.appealsRepartitioned[i].currentIncoherentVote;\n                    ++currentIterations;\n                }\n                dispute.appealsRepartitioned[i].stage = RepartitionStage.Coherent;\n            }\n            // Second loop to reward coherent voters\n            if (dispute.appealsRepartitioned[i].stage == RepartitionStage.Coherent) {\n                if (dispute.appealsRepartitioned[i].nbCoherent == 0) { // No one was coherent at this stage. Take the tokens.\n                    jurors[this].balance += dispute.appealsRepartitioned[i].totalToRedistribute;\n                    dispute.appealsRepartitioned[i].stage = RepartitionStage.AtStake;\n                } else { // otherwise, redistribute them.\n                    uint toRedistribute = dispute.appealsRepartitioned[i].totalToRedistribute / dispute.appealsRepartitioned[i].nbCoherent; // Note that few fractions of tokens can be lost but due to the high amount of decimals we don't care.\n                    // Second loop to redistribute.\n                    for (j = dispute.appealsRepartitioned[i].currentCoherentVote; j < dispute.votes[i].length; ++j) {\n                        if (currentIterations >= _maxIterations) {\n                            return;\n                        }\n                        vote = dispute.votes[i][j];\n                        if (vote.ruling == winningChoice) {\n                            juror = jurors[vote.account];\n                            juror.balance += toRedistribute;\n                            TokenShift(vote.account, _disputeId, int(toRedistribute));\n                        }\n                        ++currentIterations;\n                        ++dispute.appealsRepartitioned[i].currentCoherentVote;\n                    }\n                    dispute.appealsRepartitioned[i].stage = RepartitionStage.AtStake;\n                }\n            }\n            if (dispute.appealsRepartitioned[i].stage == RepartitionStage.AtStake) {\n                // Third loop to lower the atStake in order to unlock tokens.\n                for (j = dispute.appealsRepartitioned[i].currentAtStakeVote; j < dispute.votes[i].length; ++j) {\n                    if (currentIterations >= _maxIterations) {\n                        return;\n                    }\n                    vote = dispute.votes[i][j];\n                    juror = jurors[vote.account];\n                    juror.atStake -= amountShift; // Note that it can't underflow due to amountShift not changing between vote and redistribution.\n                    ++currentIterations;\n                    ++dispute.appealsRepartitioned[i].currentAtStakeVote;\n                }\n                dispute.appealsRepartitioned[i].stage = RepartitionStage.Complete;\n            }\n            if (dispute.appealsRepartitioned[i].stage == RepartitionStage.Complete) {\n                ++dispute.currentAppealToRepartition;\n            }\n        }\n        dispute.state = DisputeState.Executable;\n    }\n    // **************************** //\n    // *      Court functions     * //\n    // *     Constant and Pure    * //\n    // **************************** //\n    /** @dev Return the amount of jurors which are or will be drawn in the dispute.\n     *  The number of jurors is doubled and 1 is added at each appeal. We have proven the formula by recurrence.\n     *  This avoid having a variable number of jurors which would be updated in order to save gas.\n     *  @param _disputeID The ID of the dispute we compute the amount of jurors.\n     *  @return nbJurors The number of jurors which are drawn.\n     */\n    function amountJurors(uint _disputeID) public view returns (uint nbJurors) {\n        Dispute storage dispute = disputes[_disputeID];\n        return (dispute.initialNumberJurors + 1) * 2**dispute.appeals - 1;\n    }\n    /** @dev Must be used to prove that a juror has been draw at least _draws.length times.\n     *  We have to require the user to specify the draws that lead the juror to be drawn.\n     *  Because doing otherwise (looping through all draws) could consume too much gas.\n     *  @param _jurorAddress Address of the juror we want to prove was drawn.\n     *  @param _disputeID The ID of the dispute the juror was drawn.\n     *  @param _draws The list of draws the juror was drawn. It draw numbering starts at 1 and the numbers should be increasing.\n     *  Note that in most cases this list will just contain 1 number.\n     *  @param valid true if the draws are valid.\n     */\n    function validDraws(address _jurorAddress, uint _disputeID, uint[] _draws) public view returns (bool valid) {\n        uint draw = 0;\n        Juror storage juror = jurors[_jurorAddress];\n        Dispute storage dispute = disputes[_disputeID];\n        uint nbJurors = amountJurors(_disputeID);\n        if (juror.lastSession != session) return false; // Make sure that the tokens were activated for this session.\n        if (dispute.session+dispute.appeals != session) return false; // Make sure this currently a dispute.\n        if (period <= Period.Draw) return false; // Make sure that it's already drawn.\n        for (uint i; i < _draws.length; ++i) {\n            if (_draws[i] <= draw) return false; // Make sure that draws are always increasing to avoid someone inputing the same multiple times.\n            draw = _draws[i];\n            if (draw > nbJurors) return false;\n            uint position = uint(keccak256(randomNumber, _disputeID, draw)) % segmentSize; // Random position on the segment for draw.\n            require(position >= juror.segmentStart);\n            require(position < juror.segmentEnd);\n        }\n        return true;\n    }\n    // **************************** //\n    // *   Arbitrator functions   * //\n    // *   Modifying the state    * //\n    // **************************** //\n    /** @dev Create a dispute. Must be called by the arbitrable contract.\n     *  Must be paid at least arbitrationCost().\n     *  @param _choices Amount of choices the arbitrator can make in this dispute.\n     *  @param _extraData Null for the default number. Otherwise, first 16 bytes will be used to return the number of jurors.\n     *  @return disputeID ID of the dispute created.\n     */\n    function createDispute(uint _choices, bytes _extraData) public payable returns (uint disputeID) {\n        uint16 nbJurors = extraDataToNbJurors(_extraData);\n        require(msg.value >= arbitrationCost(_extraData));\n        disputeID = disputes.length++;\n        Dispute storage dispute = disputes[disputeID];\n        dispute.arbitrated = Arbitrable(msg.sender);\n        if (period < Period.Draw) // If drawing did not start schedule it for the current session.\n            dispute.session = session;\n        else // Otherwise schedule it for the next one.\n            dispute.session = session+1;\n        dispute.choices = _choices;\n        dispute.initialNumberJurors = nbJurors;\n        dispute.arbitrationFeePerJuror = arbitrationFeePerJuror; // We story it as it will be able to be changed through the governance mechanism.\n        dispute.votes.length++;\n        dispute.voteCounter.length++;\n        DisputeCreation(disputeID, Arbitrable(msg.sender));\n        return disputeID;\n    }\n    /** @dev Appeal a ruling. Note that it has to be called before the arbitrator contract calls rule.\n     *  @param _disputeID ID of the dispute to be appealed.\n     *  @param _extraData Standard but not used by this contract.\n     */\n    function appeal(uint _disputeID, bytes _extraData) public payable onlyDuring(Period.Appeal) {\n        super.appeal(_disputeID,_extraData);\n        Dispute storage dispute = disputes[_disputeID];\n        require(msg.value >= appealCost(_disputeID, _extraData));\n        require(dispute.session+dispute.appeals == session); // Dispute of the current session.\n        dispute.appeals++;\n        dispute.votes.length++;\n        dispute.voteCounter.length++;\n    }\n    /** @dev Execute the ruling of a dispute which is in the state executable. UNTRUSTED.\n     *  @param disputeID ID of the dispute to execute the ruling.\n     */\n    function executeRuling(uint disputeID) public {\n        Dispute storage dispute = disputes[disputeID];\n        require(dispute.state == DisputeState.Executable);\n        dispute.state = DisputeState.Executed;\n        dispute.arbitrated.rule(disputeID, dispute.voteCounter[dispute.appeals].winningChoice);\n    }\n    // **************************** //\n    // *   Arbitrator functions   * //\n    // *    Constant and pure     * //\n    // **************************** //\n    /** @dev Compute the cost of arbitration. It is recommended not to increase it often, \n     *  as it can be highly time and gas consuming for the arbitrated contracts to cope with fee augmentation.\n     *  @param _extraData Null for the default number. Other first 16 bits will be used to return the number of jurors.\n     *  @return fee Amount to be paid.\n     */\n    function arbitrationCost(bytes _extraData) public view returns (uint fee) {\n        return extraDataToNbJurors(_extraData) * arbitrationFeePerJuror;\n    }\n    /** @dev Compute the cost of appeal. It is recommended not to increase it often, \n     *  as it can be highly time and gas consuming for the arbitrated contracts to cope with fee augmentation.\n     *  @param _disputeID ID of the dispute to be appealed.\n     *  @param _extraData Is not used there.\n     *  @return fee Amount to be paid.\n     */\n    function appealCost(uint _disputeID, bytes _extraData) public view returns (uint fee) {\n        Dispute storage dispute = disputes[_disputeID];\n        if(dispute.appeals >= maxAppeals) return NON_PAYABLE_AMOUNT;\n        return (2*amountJurors(_disputeID) + 1) * dispute.arbitrationFeePerJuror;\n    }\n    /** @dev Compute the amount of jurors to be drawn.\n     *  @param _extraData Null for the default number. Other first 16 bits will be used to return the number of jurors.\n     *  Note that it does not check that the number of jurors is odd, but users are advised to choose a odd number of jurors.\n     */\n    function extraDataToNbJurors(bytes _extraData) internal view returns (uint16 nbJurors) {\n        if (_extraData.length < 2)\n            return defaultNumberJuror;\n        else\n            return (uint16(_extraData[0]) << 8) + uint16(_extraData[1]);\n    }\n    /** @dev Compute the minimum activated pinakions in alpha.\n     * Note there may be multiple draws for a single user on a single dispute.\n    */\n    function getStakePerDraw() public view returns (uint minActivatedTokenInAlpha) {\n        return (alpha * minActivatedToken) / ALPHA_DIVISOR;\n    }\n    // **************************** //\n    // *     Constant getters     * //\n    // **************************** //\n    /** @dev Getter for account in Vote.\n     *  @param _disputeID ID of the dispute.\n     *  @param _appeals Which appeal (or 0 for the initial session).\n     *  @param _voteID The ID of the vote for this appeal (or initial session).\n     *  @return account The address of the voter.\n     */\n    function getVoteAccount(uint _disputeID, uint _appeals, uint _voteID) public view returns (address account) {\n        return disputes[_disputeID].votes[_appeals][_voteID].account;\n    }\n    /** @dev Getter for ruling in Vote.\n     *  @param _disputeID ID of the dispute.\n     *  @param _appeals Which appeal (or 0 for the initial session).\n     *  @param _voteID The ID of the vote for this appeal (or initial session).\n     *  @return ruling The ruling given by the voter.\n     */\n    function getVoteRuling(uint _disputeID, uint _appeals, uint _voteID) public view returns (uint ruling) {\n        return disputes[_disputeID].votes[_appeals][_voteID].ruling;\n    }\n    /** @dev Getter for winningChoice in VoteCounter.\n     *  @param _disputeID ID of the dispute.\n     *  @param _appeals Which appeal (or 0 for the initial session).\n     *  @return winningChoice The currently winning choice (or 0 if it's tied). Note that 0 can also be return if the juror mainly refuse to arbitrate.\n     */\n    function getWinningChoice(uint _disputeID, uint _appeals) public view returns (uint winningChoice) {\n        return disputes[_disputeID].voteCounter[_appeals].winningChoice;\n    }\n    /** @dev Getter for winningCount in VoteCounter.\n     *  @param _disputeID ID of the dispute.\n     *  @param _appeals Which appeal (or 0 for the initial session).\n     *  @return winningCount The amount of votes the winning choice (or those who are tied) has.\n     */\n    function getWinningCount(uint _disputeID, uint _appeals) public view returns (uint winningCount) {\n        return disputes[_disputeID].voteCounter[_appeals].winningCount;\n    }\n    /** @dev Getter for voteCount in VoteCounter.\n     *  @param _disputeID ID of the dispute.\n     *  @param _appeals Which appeal (or 0 for the initial session).\n     *  @param _choice The choice.\n     *  @return voteCount The amount of votes the winning choice (or those who are tied) has.\n     */\n    function getVoteCount(uint _disputeID, uint _appeals, uint _choice) public view returns (uint voteCount) {\n        return disputes[_disputeID].voteCounter[_appeals].voteCount[_choice];\n    }\n    /** @dev Getter for lastSessionVote in Dispute.\n     *  @param _disputeID ID of the dispute.\n     *  @param _juror The juror we want to get the last session he voted.\n     *  @return lastSessionVote The last session the juror voted.\n     */\n    function getLastSessionVote(uint _disputeID, address _juror) public view returns (uint lastSessionVote) {\n        return disputes[_disputeID].lastSessionVote[_juror];\n    }\n    /** @dev Is the juror drawn in the draw of the dispute.\n     *  @param _disputeID ID of the dispute.\n     *  @param _juror The juror.\n     *  @param _draw The draw. Note that it starts at 1.\n     *  @return drawn True if the juror is drawn, false otherwise.\n     */\n    function isDrawn(uint _disputeID, address _juror, uint _draw) public view returns (bool drawn) {\n        Dispute storage dispute = disputes[_disputeID];\n        Juror storage juror = jurors[_juror];\n        if (juror.lastSession != session\n        || (dispute.session+dispute.appeals != session)\n        || period<=Period.Draw\n        || _draw>amountJurors(_disputeID)\n        || _draw==0\n        || segmentSize==0\n        ) {\n            return false;\n        } else {\n            uint position = uint(keccak256(randomNumber,_disputeID,_draw)) % segmentSize;\n            return (position >= juror.segmentStart) && (position < juror.segmentEnd);\n        }\n    }\n    /** @dev Return the current ruling of a dispute. This is useful for parties to know if they should appeal.\n     *  @param _disputeID ID of the dispute.\n     *  @return ruling The current ruling which will be given if there is no appeal. If it is not available, return 0.\n     */\n    function currentRuling(uint _disputeID) public view returns (uint ruling) {\n        Dispute storage dispute = disputes[_disputeID];\n        return dispute.voteCounter[dispute.appeals].winningChoice;\n    }\n    /** @dev Return the status of a dispute.\n     *  @param _disputeID ID of the dispute to rule.\n     *  @return status The status of the dispute.\n     */\n    function disputeStatus(uint _disputeID) public view returns (DisputeStatus status) {\n        Dispute storage dispute = disputes[_disputeID];\n        if (dispute.session+dispute.appeals < session) // Dispute of past session.\n            return DisputeStatus.Solved;\n        else if(dispute.session+dispute.appeals == session) { // Dispute of current session.\n            if (dispute.state == DisputeState.Open) {\n                if (period < Period.Appeal)\n                    return DisputeStatus.Waiting;\n                else if (period == Period.Appeal)\n                    return DisputeStatus.Appealable;\n                else return DisputeStatus.Solved;\n            } else return DisputeStatus.Solved;\n        } else return DisputeStatus.Waiting; // Dispute for future session.\n    }\n    // **************************** //\n    // *     Governor Functions   * //\n    // **************************** //\n    /** @dev General call function where the contract execute an arbitrary call with data and ETH following governor orders.\n     *  @param _data Transaction data.\n     *  @param _value Transaction value.\n     *  @param _target Transaction target.\n     */\n    function executeOrder(bytes32 _data, uint _value, address _target) public onlyGovernor {\n        _target.call.value(_value)(_data);\n    }\n    /** @dev Setter for rng.\n     *  @param _rng An instance of RNG.\n     */\n    function setRng(RNG _rng) public onlyGovernor {\n        rng = _rng;\n    }\n    /** @dev Setter for arbitrationFeePerJuror.\n     *  @param _arbitrationFeePerJuror The fee which will be paid to each juror.\n     */\n    function setArbitrationFeePerJuror(uint _arbitrationFeePerJuror) public onlyGovernor {\n        arbitrationFeePerJuror = _arbitrationFeePerJuror;\n    }\n    /** @dev Setter for defaultNumberJuror.\n     *  @param _defaultNumberJuror Number of drawn jurors unless specified otherwise.\n     */\n    function setDefaultNumberJuror(uint16 _defaultNumberJuror) public onlyGovernor {\n        defaultNumberJuror = _defaultNumberJuror;\n    }\n    /** @dev Setter for minActivatedToken.\n     *  @param _minActivatedToken Minimum of tokens to be activated (in basic units).\n     */\n    function setMinActivatedToken(uint _minActivatedToken) public onlyGovernor {\n        minActivatedToken = _minActivatedToken;\n    }\n    /** @dev Setter for timePerPeriod.\n     *  @param _timePerPeriod The minimum time each period lasts (seconds).\n     */\n    function setTimePerPeriod(uint[5] _timePerPeriod) public onlyGovernor {\n        timePerPeriod = _timePerPeriod;\n    }\n    /** @dev Setter for alpha.\n     *  @param _alpha Alpha in ‱.\n     */\n    function setAlpha(uint _alpha) public onlyGovernor {\n        alpha = _alpha;\n    }\n    /** @dev Setter for maxAppeals.\n     *  @param _maxAppeals Number of times a dispute can be appealed. When exceeded appeal cost becomes NON_PAYABLE_AMOUNT.\n     */\n    function setMaxAppeals(uint _maxAppeals) public onlyGovernor {\n        maxAppeals = _maxAppeals;\n    }\n    /** @dev Setter for governor.\n     *  @param _governor Address of the governor contract.\n     */\n    function setGovernor(address _governor) public onlyGovernor {\n        governor = _governor;\n    }\n}",
        "after": "/**\n *  @title Kleros\n *  @author Clément Lesaege - <clement@lesaege.com>\n *  This code implements a simple version of Kleros.\n *  Bug Bounties: This code hasn't undertaken a bug bounty program yet.\n */\npragma solidity ^0.4.15;\nimport \"kleros-interaction/contracts/standard/arbitration/Arbitrator.sol\";\nimport {MiniMeTokenERC20 as Pinakion} from \"kleros-interaction/contracts/standard/arbitration/ArbitrableTokens/MiniMeTokenERC20.sol\";\nimport \"kleros-interaction/contracts/standard/rng/RNG.sol\";\nimport {ApproveAndCallFallBack} from \"minimetoken/contracts/MiniMeToken.sol\";\ncontract Kleros is Arbitrator, ApproveAndCallFallBack {\n    // **************************** //\n    // *    Contract variables    * //\n    // **************************** //\n    // Variables which should not change after initialization.\n    Pinakion public pinakion;\n    uint public constant NON_PAYABLE_AMOUNT = (2**256 - 2) / 2; // An astronomic amount, practically can't be paid.\n    // Variables which will subject to the governance mechanism.\n    // Note they will only be able to be changed during the activation period (because a session assumes they don't change after it).\n    RNG public rng; // Random Number Generator used to draw jurors.\n    uint public arbitrationFeePerJuror = 0.05 ether; // The fee which will be paid to each juror.\n    uint16 public defaultNumberJuror = 3; // Number of drawn jurors unless specified otherwise.\n    uint public minActivatedToken = 0.1 * 1e18; // Minimum of tokens to be activated (in basic units).\n    uint[5] public timePerPeriod; // The minimum time each period lasts (seconds).\n    uint public alpha = 2000; // alpha in ‱.\n    uint constant ALPHA_DIVISOR = 1e4; // Amount we need to divided alpha in ‱ to get the float value of alpha.\n    uint public maxAppeals = 5; // Number of times a dispute can be appealed. When exceeded appeal cost becomes NON_PAYABLE_AMOUNT.\n    // Initially, the governor will be an address controlled by the Kleros team. At a later stage,\n    // the governor will be switched to a governance contract with liquid voting.\n    address public governor; // Address of the governor contract.\n    // Variables changing during day to day interaction.\n    uint public session = 1;      // Current session of the court.\n    uint public lastPeriodChange; // The last time we changed of period (seconds).\n    uint public segmentSize;      // Size of the segment of activated tokens.\n    uint public rnBlock;          // The block linked with the RN which is requested.\n    uint public randomNumber;     // Random number of the session.\n    enum Period {\n        Activation, // When juror can deposit their tokens and parties give evidences.\n        Draw,       // When jurors are drawn at random, note that this period is fast.\n        Vote,       // Where jurors can vote on disputes.\n        Appeal,     // When parties can appeal the rulings.\n        Execution   // When where token redistribution occurs and Kleros call the arbitrated contracts.\n    }\n    Period public period;\n    struct Juror {\n        uint balance;      // The amount of tokens the contract holds for this juror.\n        uint atStake;      // Total number of tokens the jurors can loose in disputes they are drawn in. Those tokens are locked. Note that we can have atStake > balance but it should be statistically unlikely and does not pose issues.\n        uint lastSession;  // Last session the tokens were activated.\n        uint segmentStart; // Start of the segment of activated tokens.\n        uint segmentEnd;   // End of the segment of activated tokens.\n    }\n    mapping (address => Juror) public jurors;\n    struct Vote {\n        address account; // The juror who casted the vote.\n        uint ruling;     // The ruling which was given.\n    }\n    struct VoteCounter {\n        uint winningChoice; // The choice which currently has the highest amount of votes. Is 0 in case of a tie.\n        uint winningCount;  // The number of votes for winningChoice. Or for the choices which are tied.\n        mapping (uint => uint) voteCount; // voteCount[choice] is the number of votes for choice.\n    }\n    enum DisputeState {\n        Open,       // The dispute is opened but the outcome is not available yet (this include when jurors voted but appeal is still possible).\n        Resolving,  // The token repartition has started. Note that if it's done in just one call, this state is skipped.\n        Executable, // The arbitrated contract can be called to enforce the decision.\n        Executed    // Everything has been done and the dispute can't be interacted with anymore.\n    }\n    struct Dispute {\n        Arbitrable arbitrated;       // Contract to be arbitrated.\n        uint session;                // First session the dispute was schedule.\n        uint appeals;                // Number of appeals.\n        uint choices;                // The number of choices available to the jurors.\n        uint16 initialNumberJurors;  // The initial number of jurors.\n        uint arbitrationFeePerJuror; // The fee which will be paid to each juror.\n        DisputeState state;          // The state of the dispute.\n        Vote[][] votes;              // The votes in the form vote[appeals][voteID].\n        VoteCounter[] voteCounter;   // The vote counters in the form voteCounter[appeals].\n        mapping (address => uint) lastSessionVote; // Last session a juror has voted on this dispute. Is 0 if he never did.\n        uint currentAppealToRepartition; // The current appeal we are repartitioning.\n        AppealsRepartitioned[] appealsRepartitioned; // Track a partially repartitioned appeal in the form AppealsRepartitioned[appeal].\n    }\n    enum RepartitionStage { // State of the token repartition if oneShotTokenRepartition would throw because there are too many votes.\n        Incoherent,\n        Coherent,\n        AtStake,\n        Complete\n    }\n    struct AppealsRepartitioned {\n        uint totalToRedistribute;   // Total amount of tokens we have to redistribute.\n        uint nbCoherent;            // Number of coherent jurors for session.\n        uint currentIncoherentVote; // Current vote for the incoherent loop.\n        uint currentCoherentVote;   // Current vote we need to count.\n        uint currentAtStakeVote;    // Current vote we need to count.\n        RepartitionStage stage;     // Use with multipleShotTokenRepartition if oneShotTokenRepartition would throw.\n    }\n    Dispute[] public disputes;\n    // **************************** //\n    // *          Events          * //\n    // **************************** //\n    /** @dev Emitted when we pass to a new period.\n     *  @param _period The new period.\n     *  @param _session The current session.\n     */\n    event NewPeriod(Period _period, uint indexed _session);\n    /** @dev Emitted when a juror wins or loses tokens.\n      * @param _account The juror affected.\n      * @param _disputeID The ID of the dispute.\n      * @param _amount The amount of parts of token which was won. Can be negative for lost amounts.\n      */\n    event TokenShift(address indexed _account, uint _disputeID, int _amount);\n    /** @dev Emited when a juror wins arbitration fees.\n      * @param _account The account affected.\n      * @param _disputeID The ID of the dispute.\n      * @param _amount The amount of weis which was won.\n      */\n    event ArbitrationReward(address indexed _account, uint _disputeID, uint _amount);\n    // **************************** //\n    // *         Modifiers        * //\n    // **************************** //\n    modifier onlyBy(address _account) {require(msg.sender == _account); _;}\n    modifier onlyDuring(Period _period) {require(period == _period); _;}\n    modifier onlyGovernor() {require(msg.sender == governor); _;}\n    /** @dev Constructor.\n     *  @param _pinakion The address of the pinakion contract.\n     *  @param _rng The random number generator which will be used.\n     *  @param _timePerPeriod The minimal time for each period (seconds).\n     *  @param _governor Address of the governor contract.\n     */\n    function Kleros(Pinakion _pinakion, RNG _rng, uint[5] _timePerPeriod, address _governor) public {\n        pinakion = _pinakion;\n        rng = _rng;\n        lastPeriodChange = now;\n        timePerPeriod = _timePerPeriod;\n        governor = _governor;\n    }\n    // **************************** //\n    // *  Functions interacting   * //\n    // *  with Pinakion contract  * //\n    // **************************** //\n    /** @dev Callback of approveAndCall - transfer pinakions of a juror in the contract. Should be called by the pinakion contract. TRUSTED.\n     *  @param _from The address making the transfer.\n     *  @param _amount Amount of tokens to transfer to Kleros (in basic units).\n     */\n    function receiveApproval(address _from, uint _amount, address, bytes) public onlyBy(pinakion) {\n        require(pinakion.transferFrom(_from, this, _amount));\n        jurors[_from].balance += _amount;\n    }\n    /** @dev Withdraw tokens. Note that we can't withdraw the tokens which are still atStake. \n     *  Jurors can't withdraw their tokens if they have deposited some during this session.\n     *  This is to prevent jurors from withdrawing tokens they could loose.\n     *  @param _value The amount to withdraw.\n     */\n    function withdraw(uint _value) public {\n        Juror storage juror = jurors[msg.sender];\n        require(juror.atStake <= juror.balance); // Make sure that there is no more at stake than owned to avoid overflow.\n        require(_value <= juror.balance-juror.atStake);\n        require(juror.lastSession != session);\n        juror.balance -= _value;\n        require(pinakion.transfer(msg.sender,_value));\n    }\n    // **************************** //\n    // *      Court functions     * //\n    // *    Modifying the state   * //\n    // **************************** //\n    /** @dev To call to go to a new period. TRUSTED.\n     */\n    function passPeriod() public {\n        require(now-lastPeriodChange >= timePerPeriod[uint8(period)]);\n        if (period == Period.Activation) {\n            rnBlock = block.number + 1;\n            rng.requestRN(rnBlock);\n            period = Period.Draw;\n        } else if (period == Period.Draw) {\n            randomNumber = rng.getUncorrelatedRN(rnBlock);\n            require(randomNumber != 0);\n            period = Period.Vote;\n        } else if (period == Period.Vote) {\n            period = Period.Appeal;\n        } else if (period == Period.Appeal) {\n            period = Period.Execution;\n        } else if (period == Period.Execution) {\n            period = Period.Activation;\n            ++session;\n            segmentSize = 0;\n            rnBlock = 0;\n            randomNumber = 0;\n        }\n        lastPeriodChange = now;\n        NewPeriod(period, session);\n    }\n    /** @dev Activate tokens in order to have chances of being drawn. Note that once tokens are activated, \n     *  there is no possibility of activating more.\n     *  @param _value Amount of fractions of token to activate.\n     */\n    function activateTokens(uint _value) public onlyDuring(Period.Activation) {\n        Juror storage juror = jurors[msg.sender];\n        require(_value <= juror.balance);\n        require(_value >= minActivatedToken);\n        require(juror.lastSession != session); // Verify that tokens were not already activated for this session.\n        juror.lastSession = session;\n        juror.segmentStart = segmentSize;\n        segmentSize += _value;\n        juror.segmentEnd = segmentSize;\n    }\n    /** @dev Vote a ruling. Juror must input the draw ID he was drawn.\n     *  Note that the complexity is O(d), where d is amount of times the juror was drawn.\n     *  Since being drawn multiple time is a rare occurrence and that a juror can always vote with less weight than it has, it is not a problem.\n     *  @param _disputeID The ID of the dispute the juror was drawn.\n     *  @param _ruling The ruling given.\n     *  @param _draws The list of draws the juror was drawn. It draw numbering starts at 1 and the numbers should be increasing.\n     */\n    function voteRuling(uint _disputeID, uint _ruling, uint[] _draws) public onlyDuring(Period.Vote) {\n        Dispute storage dispute = disputes[_disputeID];\n        Juror storage juror = jurors[msg.sender];\n        VoteCounter storage voteCounter = dispute.voteCounter[dispute.appeals];\n        require(dispute.lastSessionVote[msg.sender] != session); // Make sure juror hasn't voted yet.\n        require(_ruling <= dispute.choices);\n        // Note that it throws if the draws are incorrect.\n        require(validDraws(msg.sender, _disputeID, _draws));\n        dispute.lastSessionVote[msg.sender] = session;\n        voteCounter.voteCount[_ruling] += _draws.length;\n        if (voteCounter.winningCount < voteCounter.voteCount[_ruling]) {\n            voteCounter.winningCount = voteCounter.voteCount[_ruling];\n            voteCounter.winningChoice = _ruling;\n        } else if (voteCounter.winningCount==voteCounter.voteCount[_ruling] && _draws.length!=0) {\n            voteCounter.winningChoice = 0; // It's currently a tie.\n        }\n        for (uint i = 0; i < _draws.length; ++i) {\n            dispute.votes[dispute.appeals].push(Vote({\n                account: msg.sender,\n                ruling: _ruling\n            }));\n        }\n        juror.atStake += _draws.length * getStakePerDraw();\n        uint feeToPay = _draws.length * dispute.arbitrationFeePerJuror;\n        msg.sender.transfer(feeToPay);\n        ArbitrationReward(msg.sender, _disputeID, feeToPay);\n    }\n    /** @dev Steal part of the tokens of a juror who failed to vote.\n     *  Note that a juror who voted but without all his weight can't be penalized.\n     *  @param _jurorAddress Address of the juror to steal tokens from.\n     *  @param _disputeID The ID of the dispute the juror was drawn.\n     *  @param _draws The list of draws the juror was drawn. Numbering starts at 1 and the numbers should be increasing.\n     */\n    function penalizeInactiveJuror(address _jurorAddress, uint _disputeID, uint[] _draws) public {\n        Dispute storage dispute = disputes[_disputeID];\n        Juror storage inactiveJuror = jurors[_jurorAddress];\n        require(period > Period.Vote);\n        require(dispute.lastSessionVote[_jurorAddress] != session); // Verify the juror hasn't voted.\n        dispute.lastSessionVote[_jurorAddress] = session;\n        require(validDraws(_jurorAddress, _disputeID, _draws));\n        uint penality = _draws.length * minActivatedToken * 2 * alpha / ALPHA_DIVISOR;\n        penality = (penality < inactiveJuror.balance) ? penality : inactiveJuror.balance; // Make sure the penality is not higher than the balance.\n        inactiveJuror.balance -= penality;\n        jurors[msg.sender].balance += penality / 2; // Give half of the penalty to the caller.\n        jurors[this].balance += penality / 2; // The other half to Kleros.\n\n    \n          \n            \n    \n\n          \n          Expand Down\n    \n    \n  \n        msg.sender.transfer(_draws.length*dispute.arbitrationFeePerJuror);\n    }\n    /** @dev Execute all the token repartition.\n     *  Note that this function could consume to much gas if there is too much votes. \n     *  It is O(v), where v is the number of votes for this dispute.\n     *  In the next version, there will also be a function to execute it in multiple calls \n     *  (but note that one shot execution, if possible, is less expensive).\n     *  @param _disputeID ID of the dispute.\n     */\n    function oneShotTokenRepartition(uint _disputeID) public onlyDuring(Period.Execution) {\n        Dispute storage dispute = disputes[_disputeID];\n        require(dispute.state == DisputeState.Open);\n        require(dispute.session+dispute.appeals <= session);\n        uint winningChoice = dispute.voteCounter[dispute.appeals].winningChoice;\n        uint amountShift = getStakePerDraw();\n        for (uint i = 0; i <= dispute.appeals; ++i) {\n            // If the result is not a tie, some parties are incoherent. Note that 0 (refuse to arbitrate) winning is not a tie.\n            // Result is a tie if the winningChoice is 0 (refuse to arbitrate) and the choice 0 is not the most voted choice.\n            // Note that in case of a \"tie\" among some choices including 0, parties who did not vote 0 are considered incoherent.\n            if (winningChoice!=0 || (dispute.voteCounter[dispute.appeals].voteCount[0] == dispute.voteCounter[dispute.appeals].winningCount)) {\n                uint totalToRedistribute = 0;\n                uint nbCoherent = 0;\n                // First loop to penalize the incoherent votes.\n                for (uint j = 0; j < dispute.votes[i].length; ++j) {\n                    Vote storage vote = dispute.votes[i][j];\n                    if (vote.ruling != winningChoice) {\n                        Juror storage juror = jurors[vote.account];\n                        uint penalty = amountShift<juror.balance ? amountShift : juror.balance;\n                        juror.balance -= penalty;\n                        TokenShift(vote.account, _disputeID, int(-penalty));\n                        totalToRedistribute += penalty;\n                    } else {\n                        ++nbCoherent;\n                    }\n                }\n                if (nbCoherent == 0) { // No one was coherent at this stage. Take the tokens.\n                    jurors[this].balance += totalToRedistribute;\n                } else { // otherwise, redistribute them.\n                    uint toRedistribute = totalToRedistribute / nbCoherent; // Note that few fractions of tokens can be lost but due to the high amount of decimals we don't care.\n                    // Second loop to redistribute.\n                    for (j = 0; j < dispute.votes[i].length; ++j) {\n                        vote = dispute.votes[i][j];\n                        if (vote.ruling == winningChoice) {\n                            juror = jurors[vote.account];\n                            juror.balance += toRedistribute;\n                            TokenShift(vote.account, _disputeID, int(toRedistribute));\n                        }\n                    }\n                }\n            }\n            // Third loop to lower the atStake in order to unlock tokens.\n            for (j = 0; j < dispute.votes[i].length; ++j) {\n                vote = dispute.votes[i][j];\n                juror = jurors[vote.account];\n                juror.atStake -= amountShift; // Note that it can't underflow due to amountShift not changing between vote and redistribution.\n            }\n        }\n        dispute.state = DisputeState.Executable; // Since it was solved in one shot, go directly to the executable step.\n    }\n    /** @dev Execute token repartition on a dispute for a specific number of votes.\n     *  This should only be called if oneShotTokenRepartition will throw because there are too many votes (will use too much gas).\n     *  Note There are 3 iterations per vote. e.g. A dispute with 1 appeal (2 sessions) and 3 votes per session will have 18 iterations\n     *  @param _disputeId ID of the dispute.\n     *  @param _maxIterations the maxium number of votes to repartition in this iteration\n     */\n    function multipleShotTokenRepartition(uint _disputeId, uint _maxIterations) public onlyDuring(Period.Execution) {\n        Dispute storage dispute = disputes[_disputeId];\n        require(dispute.state <= DisputeState.Resolving);\n        require(dispute.session+dispute.appeals <= session);\n        dispute.state = DisputeState.Resolving; // mark as resolving so oneShotTokenRepartition cannot be called on dispute\n        uint winningChoice = dispute.voteCounter[dispute.appeals].winningChoice;\n        uint amountShift = getStakePerDraw();\n        uint currentIterations = 0; // total votes we have repartitioned this iteration\n        for (uint i = dispute.currentAppealToRepartition; i <= dispute.appeals; ++i) {\n            // make new AppealsRepartitioned\n            if (dispute.appealsRepartitioned.length < i+1) {\n                dispute.appealsRepartitioned.length++;\n            }\n            // If the result is a tie, no parties are incoherent and no need to move tokens. Note that 0 (refuse to arbitrate) winning is not a tie.\n            if (winningChoice==0 && (dispute.voteCounter[dispute.appeals].voteCount[0] != dispute.voteCounter[dispute.appeals].winningCount)) {\n                // if ruling is a tie we can skip to at stake\n                dispute.appealsRepartitioned[i].stage = RepartitionStage.AtStake;\n            }\n            // First loop to penalize the incoherent votes.\n            if (dispute.appealsRepartitioned[i].stage == RepartitionStage.Incoherent) {\n                for (uint j = dispute.appealsRepartitioned[i].currentIncoherentVote; j < dispute.votes[i].length; ++j) {\n                    if (currentIterations >= _maxIterations) {\n                        return;\n                    }\n                    Vote storage vote = dispute.votes[i][j];\n                    if (vote.ruling != winningChoice) {\n                        Juror storage juror = jurors[vote.account];\n                        uint penalty = amountShift<juror.balance ? amountShift : juror.balance;\n                        juror.balance -= penalty;\n                        TokenShift(vote.account, _disputeId, int(-penalty));\n                        dispute.appealsRepartitioned[i].totalToRedistribute += penalty;\n                    } else {\n                        ++dispute.appealsRepartitioned[i].nbCoherent;\n                    }\n                    ++dispute.appealsRepartitioned[i].currentIncoherentVote;\n                    ++currentIterations;\n                }\n                dispute.appealsRepartitioned[i].stage = RepartitionStage.Coherent;\n            }\n            // Second loop to reward coherent voters\n            if (dispute.appealsRepartitioned[i].stage == RepartitionStage.Coherent) {\n                if (dispute.appealsRepartitioned[i].nbCoherent == 0) { // No one was coherent at this stage. Take the tokens.\n                    jurors[this].balance += dispute.appealsRepartitioned[i].totalToRedistribute;\n                    dispute.appealsRepartitioned[i].stage = RepartitionStage.AtStake;\n                } else { // otherwise, redistribute them.\n                    uint toRedistribute = dispute.appealsRepartitioned[i].totalToRedistribute / dispute.appealsRepartitioned[i].nbCoherent; // Note that few fractions of tokens can be lost but due to the high amount of decimals we don't care.\n                    // Second loop to redistribute.\n                    for (j = dispute.appealsRepartitioned[i].currentCoherentVote; j < dispute.votes[i].length; ++j) {\n                        if (currentIterations >= _maxIterations) {\n                            return;\n                        }\n                        vote = dispute.votes[i][j];\n                        if (vote.ruling == winningChoice) {\n                            juror = jurors[vote.account];\n                            juror.balance += toRedistribute;\n                            TokenShift(vote.account, _disputeId, int(toRedistribute));\n                        }\n                        ++currentIterations;\n                        ++dispute.appealsRepartitioned[i].currentCoherentVote;\n                    }\n                    dispute.appealsRepartitioned[i].stage = RepartitionStage.AtStake;\n                }\n            }\n            if (dispute.appealsRepartitioned[i].stage == RepartitionStage.AtStake) {\n                // Third loop to lower the atStake in order to unlock tokens.\n                for (j = dispute.appealsRepartitioned[i].currentAtStakeVote; j < dispute.votes[i].length; ++j) {\n                    if (currentIterations >= _maxIterations) {\n                        return;\n                    }\n                    vote = dispute.votes[i][j];\n                    juror = jurors[vote.account];\n                    juror.atStake -= amountShift; // Note that it can't underflow due to amountShift not changing between vote and redistribution.\n                    ++currentIterations;\n                    ++dispute.appealsRepartitioned[i].currentAtStakeVote;\n                }\n                dispute.appealsRepartitioned[i].stage = RepartitionStage.Complete;\n            }\n            if (dispute.appealsRepartitioned[i].stage == RepartitionStage.Complete) {\n                ++dispute.currentAppealToRepartition;\n            }\n        }\n        dispute.state = DisputeState.Executable;\n    }\n    // **************************** //\n    // *      Court functions     * //\n    // *     Constant and Pure    * //\n    // **************************** //\n    /** @dev Return the amount of jurors which are or will be drawn in the dispute.\n     *  The number of jurors is doubled and 1 is added at each appeal. We have proven the formula by recurrence.\n     *  This avoid having a variable number of jurors which would be updated in order to save gas.\n     *  @param _disputeID The ID of the dispute we compute the amount of jurors.\n     *  @return nbJurors The number of jurors which are drawn.\n     */\n    function amountJurors(uint _disputeID) public view returns (uint nbJurors) {\n        Dispute storage dispute = disputes[_disputeID];\n        return (dispute.initialNumberJurors + 1) * 2**dispute.appeals - 1;\n    }\n    /** @dev Must be used to prove that a juror has been draw at least _draws.length times.\n     *  We have to require the user to specify the draws that lead the juror to be drawn.\n     *  Because doing otherwise (looping through all draws) could consume too much gas.\n     *  @param _jurorAddress Address of the juror we want to prove was drawn.\n     *  @param _disputeID The ID of the dispute the juror was drawn.\n     *  @param _draws The list of draws the juror was drawn. It draw numbering starts at 1 and the numbers should be increasing.\n     *  Note that in most cases this list will just contain 1 number.\n     *  @param valid true if the draws are valid.\n     */\n    function validDraws(address _jurorAddress, uint _disputeID, uint[] _draws) public view returns (bool valid) {\n        uint draw = 0;\n        Juror storage juror = jurors[_jurorAddress];\n        Dispute storage dispute = disputes[_disputeID];\n        uint nbJurors = amountJurors(_disputeID);\n        if (juror.lastSession != session) return false; // Make sure that the tokens were activated for this session.\n        if (dispute.session+dispute.appeals != session) return false; // Make sure this currently a dispute.\n        if (period <= Period.Draw) return false; // Make sure that it's already drawn.\n        for (uint i; i < _draws.length; ++i) {\n            if (_draws[i] <= draw) return false; // Make sure that draws are always increasing to avoid someone inputing the same multiple times.\n            draw = _draws[i];\n            if (draw > nbJurors) return false;\n            uint position = uint(keccak256(randomNumber, _disputeID, draw)) % segmentSize; // Random position on the segment for draw.\n            require(position >= juror.segmentStart);\n            require(position < juror.segmentEnd);\n        }\n        return true;\n    }\n    // **************************** //\n    // *   Arbitrator functions   * //\n    // *   Modifying the state    * //\n    // **************************** //\n    /** @dev Create a dispute. Must be called by the arbitrable contract.\n     *  Must be paid at least arbitrationCost().\n     *  @param _choices Amount of choices the arbitrator can make in this dispute.\n     *  @param _extraData Null for the default number. Otherwise, first 16 bytes will be used to return the number of jurors.\n     *  @return disputeID ID of the dispute created.\n     */\n    function createDispute(uint _choices, bytes _extraData) public payable returns (uint disputeID) {\n        uint16 nbJurors = extraDataToNbJurors(_extraData);\n        require(msg.value >= arbitrationCost(_extraData));\n        disputeID = disputes.length++;\n        Dispute storage dispute = disputes[disputeID];\n        dispute.arbitrated = Arbitrable(msg.sender);\n        if (period < Period.Draw) // If drawing did not start schedule it for the current session.\n            dispute.session = session;\n        else // Otherwise schedule it for the next one.\n            dispute.session = session+1;\n        dispute.choices = _choices;\n        dispute.initialNumberJurors = nbJurors;\n        dispute.arbitrationFeePerJuror = arbitrationFeePerJuror; // We story it as it will be able to be changed through the governance mechanism.\n        dispute.votes.length++;\n        dispute.voteCounter.length++;\n        DisputeCreation(disputeID, Arbitrable(msg.sender));\n        return disputeID;\n    }\n    /** @dev Appeal a ruling. Note that it has to be called before the arbitrator contract calls rule.\n     *  @param _disputeID ID of the dispute to be appealed.\n     *  @param _extraData Standard but not used by this contract.\n     */\n    function appeal(uint _disputeID, bytes _extraData) public payable onlyDuring(Period.Appeal) {\n        super.appeal(_disputeID,_extraData);\n        Dispute storage dispute = disputes[_disputeID];\n        require(msg.value >= appealCost(_disputeID, _extraData));\n        require(dispute.session+dispute.appeals == session); // Dispute of the current session.\n        dispute.appeals++;\n        dispute.votes.length++;\n        dispute.voteCounter.length++;\n    }\n    /** @dev Execute the ruling of a dispute which is in the state executable. UNTRUSTED.\n     *  @param disputeID ID of the dispute to execute the ruling.\n     */\n    function executeRuling(uint disputeID) public {\n        Dispute storage dispute = disputes[disputeID];\n        require(dispute.state == DisputeState.Executable);\n        dispute.state = DisputeState.Executed;\n        dispute.arbitrated.rule(disputeID, dispute.voteCounter[dispute.appeals].winningChoice);\n    }\n    // **************************** //\n    // *   Arbitrator functions   * //\n    // *    Constant and pure     * //\n    // **************************** //\n    /** @dev Compute the cost of arbitration. It is recommended not to increase it often, \n     *  as it can be highly time and gas consuming for the arbitrated contracts to cope with fee augmentation.\n     *  @param _extraData Null for the default number. Other first 16 bits will be used to return the number of jurors.\n     *  @return fee Amount to be paid.\n     */\n    function arbitrationCost(bytes _extraData) public view returns (uint fee) {\n        return extraDataToNbJurors(_extraData) * arbitrationFeePerJuror;\n    }\n    /** @dev Compute the cost of appeal. It is recommended not to increase it often, \n     *  as it can be highly time and gas consuming for the arbitrated contracts to cope with fee augmentation.\n     *  @param _disputeID ID of the dispute to be appealed.\n     *  @param _extraData Is not used there.\n     *  @return fee Amount to be paid.\n     */\n    function appealCost(uint _disputeID, bytes _extraData) public view returns (uint fee) {\n        Dispute storage dispute = disputes[_disputeID];\n        if(dispute.appeals >= maxAppeals) return NON_PAYABLE_AMOUNT;\n        return (2*amountJurors(_disputeID) + 1) * dispute.arbitrationFeePerJuror;\n    }\n    /** @dev Compute the amount of jurors to be drawn.\n     *  @param _extraData Null for the default number. Other first 16 bits will be used to return the number of jurors.\n     *  Note that it does not check that the number of jurors is odd, but users are advised to choose a odd number of jurors.\n     */\n    function extraDataToNbJurors(bytes _extraData) internal view returns (uint16 nbJurors) {\n        if (_extraData.length < 2)\n            return defaultNumberJuror;\n        else\n            return (uint16(_extraData[0]) << 8) + uint16(_extraData[1]);\n    }\n    /** @dev Compute the minimum activated pinakions in alpha.\n     * Note there may be multiple draws for a single user on a single dispute.\n    */\n    function getStakePerDraw() public view returns (uint minActivatedTokenInAlpha) {\n        return (alpha * minActivatedToken) / ALPHA_DIVISOR;\n    }\n    // **************************** //\n    // *     Constant getters     * //\n    // **************************** //\n    /** @dev Getter for account in Vote.\n     *  @param _disputeID ID of the dispute.\n     *  @param _appeals Which appeal (or 0 for the initial session).\n     *  @param _voteID The ID of the vote for this appeal (or initial session).\n     *  @return account The address of the voter.\n     */\n    function getVoteAccount(uint _disputeID, uint _appeals, uint _voteID) public view returns (address account) {\n        return disputes[_disputeID].votes[_appeals][_voteID].account;\n    }\n    /** @dev Getter for ruling in Vote.\n     *  @param _disputeID ID of the dispute.\n     *  @param _appeals Which appeal (or 0 for the initial session).\n     *  @param _voteID The ID of the vote for this appeal (or initial session).\n     *  @return ruling The ruling given by the voter.\n     */\n    function getVoteRuling(uint _disputeID, uint _appeals, uint _voteID) public view returns (uint ruling) {\n        return disputes[_disputeID].votes[_appeals][_voteID].ruling;\n    }\n    /** @dev Getter for winningChoice in VoteCounter.\n     *  @param _disputeID ID of the dispute.\n     *  @param _appeals Which appeal (or 0 for the initial session).\n     *  @return winningChoice The currently winning choice (or 0 if it's tied). Note that 0 can also be return if the juror mainly refuse to arbitrate.\n     */\n    function getWinningChoice(uint _disputeID, uint _appeals) public view returns (uint winningChoice) {\n        return disputes[_disputeID].voteCounter[_appeals].winningChoice;\n    }\n    /** @dev Getter for winningCount in VoteCounter.\n     *  @param _disputeID ID of the dispute.\n     *  @param _appeals Which appeal (or 0 for the initial session).\n     *  @return winningCount The amount of votes the winning choice (or those who are tied) has.\n     */\n    function getWinningCount(uint _disputeID, uint _appeals) public view returns (uint winningCount) {\n        return disputes[_disputeID].voteCounter[_appeals].winningCount;\n    }\n    /** @dev Getter for voteCount in VoteCounter.\n     *  @param _disputeID ID of the dispute.\n     *  @param _appeals Which appeal (or 0 for the initial session).\n     *  @param _choice The choice.\n     *  @return voteCount The amount of votes the winning choice (or those who are tied) has.\n     */\n    function getVoteCount(uint _disputeID, uint _appeals, uint _choice) public view returns (uint voteCount) {\n        return disputes[_disputeID].voteCounter[_appeals].voteCount[_choice];\n    }\n    /** @dev Getter for lastSessionVote in Dispute.\n     *  @param _disputeID ID of the dispute.\n     *  @param _juror The juror we want to get the last session he voted.\n     *  @return lastSessionVote The last session the juror voted.\n     */\n    function getLastSessionVote(uint _disputeID, address _juror) public view returns (uint lastSessionVote) {\n        return disputes[_disputeID].lastSessionVote[_juror];\n    }\n    /** @dev Is the juror drawn in the draw of the dispute.\n     *  @param _disputeID ID of the dispute.\n     *  @param _juror The juror.\n     *  @param _draw The draw. Note that it starts at 1.\n     *  @return drawn True if the juror is drawn, false otherwise.\n     */\n    function isDrawn(uint _disputeID, address _juror, uint _draw) public view returns (bool drawn) {\n        Dispute storage dispute = disputes[_disputeID];\n        Juror storage juror = jurors[_juror];\n        if (juror.lastSession != session\n        || (dispute.session+dispute.appeals != session)\n        || period<=Period.Draw\n        || _draw>amountJurors(_disputeID)\n        || _draw==0\n        || segmentSize==0\n        ) {\n            return false;\n        } else {\n            uint position = uint(keccak256(randomNumber,_disputeID,_draw)) % segmentSize;\n            return (position >= juror.segmentStart) && (position < juror.segmentEnd);\n        }\n    }\n    /** @dev Return the current ruling of a dispute. This is useful for parties to know if they should appeal.\n     *  @param _disputeID ID of the dispute.\n     *  @return ruling The current ruling which will be given if there is no appeal. If it is not available, return 0.\n     */\n    function currentRuling(uint _disputeID) public view returns (uint ruling) {\n        Dispute storage dispute = disputes[_disputeID];\n        return dispute.voteCounter[dispute.appeals].winningChoice;\n    }\n    /** @dev Return the status of a dispute.\n     *  @param _disputeID ID of the dispute to rule.\n     *  @return status The status of the dispute.\n     */\n    function disputeStatus(uint _disputeID) public view returns (DisputeStatus status) {\n        Dispute storage dispute = disputes[_disputeID];\n        if (dispute.session+dispute.appeals < session) // Dispute of past session.\n            return DisputeStatus.Solved;\n        else if(dispute.session+dispute.appeals == session) { // Dispute of current session.\n            if (dispute.state == DisputeState.Open) {\n                if (period < Period.Appeal)\n                    return DisputeStatus.Waiting;\n                else if (period == Period.Appeal)\n                    return DisputeStatus.Appealable;\n                else return DisputeStatus.Solved;\n            } else return DisputeStatus.Solved;\n        } else return DisputeStatus.Waiting; // Dispute for future session.\n    }\n    // **************************** //\n    // *     Governor Functions   * //\n    // **************************** //\n    /** @dev General call function where the contract execute an arbitrary call with data and ETH following governor orders.\n     *  @param _data Transaction data.\n     *  @param _value Transaction value.\n     *  @param _target Transaction target.\n     */\n    function executeOrder(bytes32 _data, uint _value, address _target) public onlyGovernor {\n        _target.call.value(_value)(_data);\n    }\n    /** @dev Setter for rng.\n     *  @param _rng An instance of RNG.\n     */\n    function setRng(RNG _rng) public onlyGovernor {\n        rng = _rng;\n    }\n    /** @dev Setter for arbitrationFeePerJuror.\n     *  @param _arbitrationFeePerJuror The fee which will be paid to each juror.\n     */\n    function setArbitrationFeePerJuror(uint _arbitrationFeePerJuror) public onlyGovernor {\n        arbitrationFeePerJuror = _arbitrationFeePerJuror;\n    }\n    /** @dev Setter for defaultNumberJuror.\n     *  @param _defaultNumberJuror Number of drawn jurors unless specified otherwise.\n     */\n    function setDefaultNumberJuror(uint16 _defaultNumberJuror) public onlyGovernor {\n        defaultNumberJuror = _defaultNumberJuror;\n    }\n    /** @dev Setter for minActivatedToken.\n     *  @param _minActivatedToken Minimum of tokens to be activated (in basic units).\n     */\n    function setMinActivatedToken(uint _minActivatedToken) public onlyGovernor {\n        minActivatedToken = _minActivatedToken;\n    }\n    /** @dev Setter for timePerPeriod.\n     *  @param _timePerPeriod The minimum time each period lasts (seconds).\n     */\n    function setTimePerPeriod(uint[5] _timePerPeriod) public onlyGovernor {\n        timePerPeriod = _timePerPeriod;\n    }\n    /** @dev Setter for alpha.\n     *  @param _alpha Alpha in ‱.\n     */\n    function setAlpha(uint _alpha) public onlyGovernor {\n        alpha = _alpha;\n    }\n    /** @dev Setter for maxAppeals.\n     *  @param _maxAppeals Number of times a dispute can be appealed. When exceeded appeal cost becomes NON_PAYABLE_AMOUNT.\n     */\n    function setMaxAppeals(uint _maxAppeals) public onlyGovernor {\n        maxAppeals = _maxAppeals;\n    }\n    /** @dev Setter for governor.\n     *  @param _governor Address of the governor contract.\n     */\n    function setGovernor(address _governor) public onlyGovernor {\n        governor = _governor;\n    }\n}"
    },
    {
        "tag": "denial of service",
        "url": "https://github.com/syscoin/sysethereum-contracts/commit/13d1f97482905c23c62916b5dca289c156cce122",
        "file": "contracts/SyscoinClaimManager.sol\n",
        "before": "pragma solidity ^0.5.13;\nimport './interfaces/SyscoinSuperblocksI.sol';\nimport './interfaces/SyscoinClaimManagerI.sol';\nimport './interfaces/SyscoinBattleManagerI.sol';\nimport './SyscoinDepositsManager.sol';\nimport './SyscoinErrorCodes.sol';\nimport 'openzeppelin-solidity/contracts/math/SafeMath.sol';\nimport \"@openzeppelin/upgrades/contracts/Initializable.sol\";\n// @dev - Manager of superblock claims\n//\n// Manages superblocks proposal and challenges\ncontract SyscoinClaimManager is Initializable, SyscoinDepositsManager, SyscoinErrorCodes {\n    using SafeMath for uint;\n\n    uint constant MAX_FUTURE_BLOCK_TIME_SYSCOIN = 7200;\n    uint constant MAX_FUTURE_BLOCK_TIME_ETHEREUM = 15;\n\n    struct SuperblockClaim {\n        bytes32 superblockHash;                       // Superblock Id\n        address submitter;                           // Superblock submitter\n\n    \n          \n            \n    \n\n          \n          Expand Down\n          \n            \n    \n\n          \n          Expand Up\n    \n    @@ -89,6 +89,7 @@ contract SyscoinClaimManager is Initializable, SyscoinDepositsManager, SyscoinEr\n  \n        address challenger;                         // Superblock challenger\n        uint createdAt;                             // Superblock creation time\n        mapping (address => uint) bondedDeposits;   // Deposit associated to submitter+challenger\n        uint challengeTimeout;                      // Claim timeout\n        bool verificationOngoing;                   // Challenge session has started\n        bool decided;                               // If the claim was decided\n        bool invalid;                               // If superblock is invalid\n    }\n    // Active superblock claims\n    mapping (bytes32 => SuperblockClaim) public claims;\n    // Superblocks contract\n    SyscoinSuperblocksI public trustedSuperblocks;\n    // Battle manager contract\n    SyscoinBattleManagerI public trustedSyscoinBattleManager;\n    // Confirmations required to confirm semi approved superblocks\n    uint public superblockConfirmations;\n    uint public superblockDelay;    // Delay required to submit superblocks (in seconds)\n    uint public superblockTimeout;  // Timeout for action (in seconds)\n    event DepositBonded(bytes32 superblockHash, address account, uint amount);\n    event DepositUnbonded(bytes32 superblockHash, address account, uint amount);\n    event SuperblockClaimCreated(bytes32 superblockHash, address submitter);\n    event SuperblockClaimChallenged(bytes32 superblockHash, address challenger);\n    event SuperblockBattleDecided(bytes32 superblockHash, address winner, address loser);\n    event SuperblockClaimSuccessful(bytes32 superblockHash, address submitter);\n    event SuperblockClaimPending(bytes32 superblockHash, address submitter);\n    event SuperblockClaimFailed(bytes32 superblockHash, address submitter);\n    event VerificationGameStarted(bytes32 superblockHash, address submitter, address challenger);\n    event ErrorClaim(bytes32 superblockHash, uint err);\n    modifier onlyBattleManager() {\n        require(msg.sender == address(trustedSyscoinBattleManager));\n        _;\n    }\n    modifier onlyMeOrBattleManager() {\n        require(msg.sender == address(trustedSyscoinBattleManager) || msg.sender == address(this));\n        _;\n    }\n    // @dev – Sets up the contract managing superblock challenges\n    // @param _superblocks Contract that manages superblocks\n    // @param _battleManager Contract that manages battles\n    // @param _superblockDelay Delay to accept a superblock submission (in seconds)\n    // @param _superblockTimeout Time to wait for challenges (in seconds)\n    // @param _superblockConfirmations Confirmations required to confirm semi approved superblocks\n    function init(\n        SyscoinSuperblocksI _superblocks,\n        SyscoinBattleManagerI _syscoinBattleManager,\n        uint _superblockDelay,\n        uint _superblockTimeout,\n        uint _superblockConfirmations\n    ) public initializer {\n        trustedSuperblocks = _superblocks;\n        trustedSyscoinBattleManager = _syscoinBattleManager;\n        superblockDelay = _superblockDelay;\n        superblockTimeout = _superblockTimeout;\n        superblockConfirmations = _superblockConfirmations;\n    }\n\n    // @dev – locks up part of a user's deposit into a claim.\n\n    \n          \n            \n    \n\n          \n          Expand Down\n          \n            \n    \n\n          \n          Expand Up\n    \n    @@ -206,7 +207,7 @@ contract SyscoinClaimManager is Initializable, SyscoinDepositsManager, SyscoinEr\n  \n    // @param superblockHash – claim id.\n    // @param account – user's address.\n    // @param amount – amount of deposit to lock up.\n    // @return – user's deposit bonded for the claim.\n    function bondDeposit(bytes32 superblockHash, address account, uint amount) external onlyMeOrBattleManager returns (uint) {\n        SuperblockClaim storage claim = claims[superblockHash];\n        if (!claimExists(claim)) {\n            return ERR_SUPERBLOCK_BAD_CLAIM;\n        }\n        if (deposits[account] < amount) {\n            return ERR_SUPERBLOCK_MIN_DEPOSIT;\n        }\n        deposits[account] = deposits[account].sub(amount);\n        claim.bondedDeposits[account] = claim.bondedDeposits[account].add(amount);\n        emit DepositBonded(superblockHash, account, amount);\n        return ERR_SUPERBLOCK_OK;\n    }\n    // @dev – accessor for a claim's bonded deposits.\n    // @param superblockHash – claim id.\n    // @param account – user's address.\n    // @return – user's deposit bonded for the claim.\n    function getBondedDeposit(bytes32 superblockHash, address account) external view returns (uint) {\n        SuperblockClaim storage claim = claims[superblockHash];\n        require(claimExists(claim));\n        return claim.bondedDeposits[account];\n    }\n    // @dev – unlocks a user's bonded deposits from a claim.\n    // @param superblockHash – claim id.\n    // @param account – user's address.\n    // @return – user's deposit which was unbonded from the claim.\n    function unbondDeposit(bytes32 superblockHash, address account) private returns (uint, uint) {\n        SuperblockClaim storage claim = claims[superblockHash];\n        if (!claimExists(claim)) {\n            return (ERR_SUPERBLOCK_BAD_CLAIM, 0);\n        }\n        if (!claim.decided) {\n            return (ERR_SUPERBLOCK_BAD_STATUS, 0);\n        }\n        uint bondedDeposit = claim.bondedDeposits[account];\n        delete claim.bondedDeposits[account];\n        deposits[account] = deposits[account].add(bondedDeposit);\n        emit DepositUnbonded(superblockHash, account, bondedDeposit);\n        return (ERR_SUPERBLOCK_OK, bondedDeposit);\n    }\n    // @dev – Propose a new superblock.\n    //\n    // @param _blocksMerkleRoot Root of the merkle tree of blocks contained in a superblock\n    // @param _timestamp Timestamp of the last block in the superblock\n    // @param _mtpTimestamp Median Timestamp of the last block in the superblock\n    // @param _lastHash Hash of the last block in the superblock\n    // @param _lastBits Difficulty bits of the last block in the superblock bits\n    // @param _parentHash Id of the parent superblock\n    // @return Error code and superblockHash\n    function proposeSuperblock(\n        bytes32 _blocksMerkleRoot,\n        uint _timestamp,\n        uint _mtpTimestamp,\n        bytes32 _lastHash,\n        uint32 _lastBits,\n        bytes32 _parentHash\n    ) external returns (uint, bytes32) {\n        require(address(trustedSuperblocks) != address(0));\n        if (deposits[msg.sender] < minProposalDeposit) {\n            emit ErrorClaim(0, ERR_SUPERBLOCK_MIN_DEPOSIT);\n            return (ERR_SUPERBLOCK_MIN_DEPOSIT, 0);\n        }\n        if (_mtpTimestamp + superblockDelay > block.timestamp) {\n            emit ErrorClaim(0, ERR_SUPERBLOCK_BAD_TIMESTAMP_MTP);\n            return (ERR_SUPERBLOCK_BAD_TIMESTAMP_MTP, 0);\n        }\n        if (block.timestamp + MAX_FUTURE_BLOCK_TIME_SYSCOIN + MAX_FUTURE_BLOCK_TIME_ETHEREUM <= _timestamp) {\n            emit ErrorClaim(0, ERR_SUPERBLOCK_BAD_TIMESTAMP);\n            return (ERR_SUPERBLOCK_BAD_TIMESTAMP, 0);\n        }\n        uint err;\n        bytes32 superblockHash;\n        (err, superblockHash) = trustedSuperblocks.propose(_blocksMerkleRoot, _timestamp, _mtpTimestamp, _lastHash, _lastBits, _parentHash, msg.sender);\n        if (err != 0) {\n            emit ErrorClaim(superblockHash, err);\n            return (err, superblockHash);\n        }\n        SuperblockClaim storage claim = claims[superblockHash];\n        // allow to propose an existing claim only if its invalid and decided and its a different submitter or not on the tip\n        // those are the ones that may actually be stuck and need to be proposed again,\n        // but we want to ensure its not the same submitter submitting the same thing\n        if (claimExists(claim)) {\n            require(claim.invalid == true && claim.decided == true && claim.submitter != msg.sender);\n        }\n        claim.superblockHash = superblockHash;\n        claim.submitter = msg.sender;\n        claim.challenger = address(0);\n        claim.decided = false;\n        claim.invalid = false;\n        claim.verificationOngoing = false;\n        claim.createdAt = block.timestamp;\n        claim.challengeTimeout = block.timestamp + superblockTimeout;\n\n        err = this.bondDeposit(superblockHash, msg.sender, minProposalDeposit);\n        require(err == ERR_SUPERBLOCK_OK);\n\n\n    \n        \n          \n    \n\n        \n        Expand All\n    \n    @@ -227,6 +228,10 @@ contract SyscoinClaimManager is Initializable, SyscoinDepositsManager, SyscoinEr\n  \n        emit SuperblockClaimCreated(superblockHash, msg.sender);\n        return (ERR_SUPERBLOCK_OK, superblockHash);\n    }\n    // @dev – challenge a superblock claim.\n    // @param superblockHash – Id of the superblock to challenge.\n    // @return - Error code and claim Id\n    function challengeSuperblock(bytes32 superblockHash) external returns (uint, bytes32) {\n        require(address(trustedSuperblocks) != address(0));\n        SuperblockClaim storage claim = claims[superblockHash];\n        if (!claimExists(claim)) {\n            emit ErrorClaim(superblockHash, ERR_SUPERBLOCK_BAD_CLAIM);\n            return (ERR_SUPERBLOCK_BAD_CLAIM, superblockHash);\n        }\n        if (claim.decided || claim.invalid) {\n            emit ErrorClaim(superblockHash, ERR_SUPERBLOCK_CLAIM_DECIDED);\n            return (ERR_SUPERBLOCK_CLAIM_DECIDED, superblockHash);\n\n    \n          \n            \n    \n\n          \n          Expand Down\n          \n            \n    \n\n          \n          Expand Up\n    \n    @@ -453,7 +458,10 @@ contract SyscoinClaimManager is Initializable, SyscoinDepositsManager, SyscoinEr\n  \n        }\n        if (claim.verificationOngoing) {\n            emit ErrorClaim(superblockHash, ERR_SUPERBLOCK_CHALLENGE_EXISTS);\n            return (ERR_SUPERBLOCK_CHALLENGE_EXISTS, superblockHash);\n        }\n        if (deposits[msg.sender] < minProposalDeposit) {\n            emit ErrorClaim(superblockHash, ERR_SUPERBLOCK_MIN_DEPOSIT);\n            return (ERR_SUPERBLOCK_MIN_DEPOSIT, superblockHash);\n        }\n    \n        uint err = trustedSuperblocks.challenge(superblockHash, msg.sender);\n        if (err != 0) {\n            emit ErrorClaim(superblockHash, err);\n            return (err, 0);\n        }\n        err = this.bondDeposit(superblockHash, msg.sender, minProposalDeposit);\n        require(err == ERR_SUPERBLOCK_OK);\n        claim.challengeTimeout = block.timestamp + superblockTimeout;\n        claim.challenger = msg.sender;\n        emit SuperblockClaimChallenged(superblockHash, msg.sender);\n        trustedSyscoinBattleManager.beginBattleSession(superblockHash, claim.submitter,\n            claim.challenger);\n        emit VerificationGameStarted(superblockHash, claim.submitter,\n            claim.challenger);\n        claim.verificationOngoing = true;\n        return (ERR_SUPERBLOCK_OK, superblockHash);\n    }\n    // @dev – confirm semi approved superblock.\n    //\n    // A semi approved superblock can be confirmed if it has several descendant\n    // superblocks that are also semi-approved.\n    // If none of the descendants were challenged they will also be confirmed.\n    //\n    // @param superblockHash – the claim ID.\n    // @param descendantId - claim ID descendants\n    function confirmClaim(bytes32 superblockHash, bytes32 descendantId) external returns (bool) {\n        uint numSuperblocks = 0;\n        bool confirmDescendants = true;\n        bytes32 id = descendantId;\n        SuperblockClaim storage claim = claims[id];\n        while (id != superblockHash) {\n            if (!claimExists(claim) || claim.invalid) {\n                emit ErrorClaim(superblockHash, ERR_SUPERBLOCK_BAD_CLAIM);\n                return false;\n            }\n            if (trustedSuperblocks.getSuperblockStatus(id) != SyscoinSuperblocksI.Status.SemiApproved) {\n                emit ErrorClaim(superblockHash, ERR_SUPERBLOCK_BAD_STATUS);\n                return false;\n            }\n            if (confirmDescendants && claim.challenger != address(0)) {\n                confirmDescendants = false;\n            }\n            id = trustedSuperblocks.getSuperblockParentId(id);\n            claim = claims[id];\n            numSuperblocks += 1;\n        }\n        if (numSuperblocks < superblockConfirmations) {\n            emit ErrorClaim(superblockHash, ERR_SUPERBLOCK_MISSING_CONFIRMATIONS);\n            return false;\n        }\n        if (trustedSuperblocks.getSuperblockStatus(id) != SyscoinSuperblocksI.Status.SemiApproved) {\n            emit ErrorClaim(superblockHash, ERR_SUPERBLOCK_BAD_STATUS);\n            return false;\n        }\n        uint err = trustedSuperblocks.confirm(superblockHash, msg.sender);\n        if (err != ERR_SUPERBLOCK_OK) {\n            emit ErrorClaim(superblockHash, err);\n            return false;\n        }\n        emit SuperblockClaimSuccessful(superblockHash, claim.submitter);\n        doPaySubmitter(superblockHash, claim);\n        if (confirmDescendants) {\n            bytes32[] memory descendants = new bytes32[](numSuperblocks);\n            id = descendantId;\n            uint idx = 0;\n            while (id != superblockHash) {\n                descendants[idx] = id;\n                id = trustedSuperblocks.getSuperblockParentId(id);\n                idx += 1;\n            }\n            while (idx > 0) {\n                idx -= 1;\n                id = descendants[idx];\n                claim = claims[id];\n                err = trustedSuperblocks.confirm(id, msg.sender);\n                require(err == ERR_SUPERBLOCK_OK);\n                emit SuperblockClaimSuccessful(id, claim.submitter);\n                doPaySubmitter(id, claim);\n            }\n        }\n        return true;\n    }\n    // @dev – Reject a semi approved superblock.\n    //\n    // Superblocks that are not in the main chain can be marked as\n    // invalid.\n    //\n    // @param superblockHash – the claim ID.\n    function rejectClaim(bytes32 superblockHash) external returns (bool) {\n        SuperblockClaim storage claim = claims[superblockHash];\n        if (!claimExists(claim)) {\n            emit ErrorClaim(superblockHash, ERR_SUPERBLOCK_BAD_CLAIM);\n            return false;\n        }\n        uint height = trustedSuperblocks.getSuperblockHeight(superblockHash);\n        if (height > trustedSuperblocks.getChainHeight()) {\n            emit ErrorClaim(superblockHash, ERR_SUPERBLOCK_BAD_BLOCKHEIGHT);\n            return false;\n        }\n        SyscoinSuperblocksI.Status status = trustedSuperblocks.getSuperblockStatus(superblockHash);\n        if (status != SyscoinSuperblocksI.Status.SemiApproved) {\n            emit ErrorClaim(superblockHash, ERR_SUPERBLOCK_BAD_STATUS);\n            return false;\n        }\n        if (!claim.decided) {\n            emit ErrorClaim(superblockHash, ERR_SUPERBLOCK_CLAIM_DECIDED);\n            return false;\n        }\n        uint err = trustedSuperblocks.invalidate(superblockHash, claim.submitter);\n        require(err == ERR_SUPERBLOCK_OK);\n        emit SuperblockClaimFailed(superblockHash, claim.submitter);\n        doPayChallenger(superblockHash, claim);\n        claim.invalid = true;\n        return true;\n    }\n    // @dev – check whether a claim has successfully withstood all challenges.\n    // If successful without challenges, it will mark the superblock as confirmed.\n    // If successful with at least one challenge, it will mark the superblock as semi-approved.\n    // If verification failed, it will mark the superblock as invalid.\n    //\n    // @param superblockHash – claim ID.\n    function checkClaimFinished(bytes32 superblockHash) external returns (bool) {\n        SuperblockClaim storage claim = claims[superblockHash];\n        if (!claimExists(claim) || claim.decided) {\n            emit ErrorClaim(superblockHash, ERR_SUPERBLOCK_BAD_CLAIM);\n            return false;\n        }\n        // check that there is no ongoing verification game.\n        if (claim.verificationOngoing) {\n            emit ErrorClaim(superblockHash, ERR_SUPERBLOCK_VERIFICATION_PENDING);\n            return false;\n        }\n        // an invalid superblock can be rejected immediately\n        if (claim.invalid) {\n            // The superblock is invalid, submitter abandoned\n            // or superblock data is inconsistent\n            claim.decided = true;\n            uint err = trustedSuperblocks.invalidate(superblockHash, claim.submitter);\n            require(err == ERR_SUPERBLOCK_OK);\n            emit SuperblockClaimFailed(superblockHash, claim.submitter);\n            doPayChallenger(superblockHash, claim);\n            return false;\n        }\n        // check that the claim has exceeded the claim's specific challenge timeout.\n        if (block.timestamp <= claim.challengeTimeout) {\n            emit ErrorClaim(superblockHash, ERR_SUPERBLOCK_NO_TIMEOUT);\n            return false;\n        }\n        claim.decided = true;\n        bool confirmImmediately = false;\n        // No challenger and parent approved; confirm immediately\n        if (claim.challenger == address(0)) {\n            bytes32 parentId = trustedSuperblocks.getSuperblockParentId(superblockHash);\n            SyscoinSuperblocksI.Status status = trustedSuperblocks.getSuperblockStatus(parentId);\n            if (status == SyscoinSuperblocksI.Status.Approved) {\n                confirmImmediately = true;\n            }\n        }\n        if (confirmImmediately) {\n            uint err = trustedSuperblocks.confirm(superblockHash, msg.sender);\n            require(err == ERR_SUPERBLOCK_OK);\n            address submitter = claim.submitter;\n            unbondDeposit(superblockHash, submitter);\n            emit SuperblockClaimSuccessful(superblockHash, submitter);\n        } else {\n            uint err = trustedSuperblocks.semiApprove(superblockHash, msg.sender);\n            require(err == ERR_SUPERBLOCK_OK);\n            emit SuperblockClaimPending(superblockHash, claim.submitter);\n        }\n        return true;\n    }\n    // @dev – called when a battle session has ended.\n    //\n    // @param superblockHash - claim Id\n    // @param winner – winner of verification game.\n    // @param loser – loser of verification game.\n    function sessionDecided(bytes32 superblockHash, address winner, address loser) external onlyBattleManager {\n        SuperblockClaim storage claim = claims[superblockHash];\n        require(claimExists(claim));\n        claim.verificationOngoing = false;\n        address submitter = claim.submitter;\n\n        if (submitter == loser) {\n            claim.invalid = true;\n        } else if (submitter != winner) {\n            revert();\n        }\n        emit SuperblockBattleDecided(superblockHash, winner, loser);\n\n    \n          \n            \n    \n\n          \n          Expand Down\n    \n    \n  \n    }\n    // @dev - Pay challenger\n    function doPayChallenger(bytes32 superblockHash, SuperblockClaim storage claim) private {\n        address challenger = claim.challenger;\n        address submitter = claim.submitter;\n        if (challenger != address(0)) {\n            uint reward = claim.bondedDeposits[submitter];\n            claim.bondedDeposits[challenger] = claim.bondedDeposits[challenger].add(reward);\n            unbondDeposit(superblockHash, challenger);\n        }\n        delete claim.bondedDeposits[submitter];\n    }\n    // @dev - Pay submitter with challenger deposit\n    function doPaySubmitter(bytes32 superblockHash, SuperblockClaim storage claim) private {\n        address challenger = claim.challenger;\n        address submitter = claim.submitter;\n        if (challenger != address(0)) {\n            uint reward = claim.bondedDeposits[challenger];\n            claim.bondedDeposits[challenger] = 0;\n            claim.bondedDeposits[submitter] = claim.bondedDeposits[submitter].add(reward);\n            unbondDeposit(superblockHash, challenger);\n        }\n        unbondDeposit(superblockHash, submitter);\n    }\n    // @dev - Check if a superblock can be semi approved by calling checkClaimFinished\n    function getInBattleAndSemiApprovable(bytes32 superblockHash) external view returns (bool) {\n        SuperblockClaim storage claim = claims[superblockHash];\n        return (trustedSuperblocks.getSuperblockStatus(superblockHash) == SyscoinSuperblocksI.Status.InBattle &&\n            !claim.invalid && !claim.verificationOngoing && block.timestamp > claim.challengeTimeout\n            && claim.challenger != address(0));\n    }\n    // @dev – Check if a claim exists\n    function claimExists(SuperblockClaim storage claim) private view returns (bool) {\n        return (claim.submitter != address(0));\n    }\n    // @dev - Return a given superblock's submitter\n    function getClaimSubmitter(bytes32 superblockHash) external view returns (address) {\n        return claims[superblockHash].submitter;\n    }\n    // @dev - Return superblock submission timestamp\n    function getNewSuperblockEventTimestamp(bytes32 superblockHash) external view returns (uint) {\n        return claims[superblockHash].createdAt;\n    }\n    // @dev - Return whether or not a claim has already been made\n    function getClaimExists(bytes32 superblockHash) external view returns (bool) {\n        return claimExists(claims[superblockHash]);\n    }\n    // @dev - Return claim status\n    function getClaimDecided(bytes32 superblockHash) external view returns (bool) {\n        return claims[superblockHash].decided;\n    }\n    // @dev - Check if a claim is invalid\n    function getClaimInvalid(bytes32 superblockHash) external view returns (bool) {\n        // TODO: see if this is redundant with superblock status\n        return claims[superblockHash].invalid;\n    }\n    function getClaimChallenger(bytes32 superblockHash) external view returns (address) {\n        SuperblockClaim storage claim = claims[superblockHash];\n        return claim.challenger;\n    }\n}",
        "after": "pragma solidity ^0.5.13;\nimport './interfaces/SyscoinSuperblocksI.sol';\nimport './interfaces/SyscoinClaimManagerI.sol';\nimport './interfaces/SyscoinBattleManagerI.sol';\nimport './SyscoinDepositsManager.sol';\nimport './SyscoinErrorCodes.sol';\nimport 'openzeppelin-solidity/contracts/math/SafeMath.sol';\nimport \"@openzeppelin/upgrades/contracts/Initializable.sol\";\n// @dev - Manager of superblock claims\n//\n// Manages superblocks proposal and challenges\ncontract SyscoinClaimManager is Initializable, SyscoinDepositsManager, SyscoinErrorCodes {\n    using SafeMath for uint;\n\n    uint constant MAX_FUTURE_BLOCK_TIME_SYSCOIN = 7200;\n    uint constant MAX_FUTURE_BLOCK_TIME_ETHEREUM = 15;\n    bool private challengeDefended;\n    struct SuperblockClaim {\n        bytes32 superblockHash;                       // Superblock Id\n        address submitter;                           // Superblock submitter\n\n    \n          \n            \n    \n\n          \n          Expand Down\n          \n            \n    \n\n          \n          Expand Up\n    \n    @@ -89,6 +89,7 @@ contract SyscoinClaimManager is Initializable, SyscoinDepositsManager, SyscoinEr\n  \n        address challenger;                         // Superblock challenger\n        uint createdAt;                             // Superblock creation time\n        mapping (address => uint) bondedDeposits;   // Deposit associated to submitter+challenger\n        uint challengeTimeout;                      // Claim timeout\n        bool verificationOngoing;                   // Challenge session has started\n        bool decided;                               // If the claim was decided\n        bool invalid;                               // If superblock is invalid\n    }\n    // Active superblock claims\n    mapping (bytes32 => SuperblockClaim) public claims;\n    // Superblocks contract\n    SyscoinSuperblocksI public trustedSuperblocks;\n    // Battle manager contract\n    SyscoinBattleManagerI public trustedSyscoinBattleManager;\n    // Confirmations required to confirm semi approved superblocks\n    uint public superblockConfirmations;\n    uint public superblockDelay;    // Delay required to submit superblocks (in seconds)\n    uint public superblockTimeout;  // Timeout for action (in seconds)\n    event DepositBonded(bytes32 superblockHash, address account, uint amount);\n    event DepositUnbonded(bytes32 superblockHash, address account, uint amount);\n    event SuperblockClaimCreated(bytes32 superblockHash, address submitter);\n    event SuperblockClaimChallenged(bytes32 superblockHash, address challenger);\n    event SuperblockBattleDecided(bytes32 superblockHash, address winner, address loser);\n    event SuperblockClaimSuccessful(bytes32 superblockHash, address submitter);\n    event SuperblockClaimPending(bytes32 superblockHash, address submitter);\n    event SuperblockClaimFailed(bytes32 superblockHash, address submitter);\n    event VerificationGameStarted(bytes32 superblockHash, address submitter, address challenger);\n    event ErrorClaim(bytes32 superblockHash, uint err);\n    modifier onlyBattleManager() {\n        require(msg.sender == address(trustedSyscoinBattleManager));\n        _;\n    }\n    modifier onlyMeOrBattleManager() {\n        require(msg.sender == address(trustedSyscoinBattleManager) || msg.sender == address(this));\n        _;\n    }\n    // @dev – Sets up the contract managing superblock challenges\n    // @param _superblocks Contract that manages superblocks\n    // @param _battleManager Contract that manages battles\n    // @param _superblockDelay Delay to accept a superblock submission (in seconds)\n    // @param _superblockTimeout Time to wait for challenges (in seconds)\n    // @param _superblockConfirmations Confirmations required to confirm semi approved superblocks\n    function init(\n        SyscoinSuperblocksI _superblocks,\n        SyscoinBattleManagerI _syscoinBattleManager,\n        uint _superblockDelay,\n        uint _superblockTimeout,\n        uint _superblockConfirmations\n    ) public initializer {\n        trustedSuperblocks = _superblocks;\n        trustedSyscoinBattleManager = _syscoinBattleManager;\n        superblockDelay = _superblockDelay;\n        superblockTimeout = _superblockTimeout;\n        superblockConfirmations = _superblockConfirmations;\n        challengeDefended = false;\n    }\n\n    // @dev – locks up part of a user's deposit into a claim.\n\n    \n          \n            \n    \n\n          \n          Expand Down\n          \n            \n    \n\n          \n          Expand Up\n    \n    @@ -206,7 +207,7 @@ contract SyscoinClaimManager is Initializable, SyscoinDepositsManager, SyscoinEr\n  \n    // @param superblockHash – claim id.\n    // @param account – user's address.\n    // @param amount – amount of deposit to lock up.\n    // @return – user's deposit bonded for the claim.\n    function bondDeposit(bytes32 superblockHash, address account, uint amount) external onlyMeOrBattleManager returns (uint) {\n        SuperblockClaim storage claim = claims[superblockHash];\n        if (!claimExists(claim)) {\n            return ERR_SUPERBLOCK_BAD_CLAIM;\n        }\n        if (deposits[account] < amount) {\n            return ERR_SUPERBLOCK_MIN_DEPOSIT;\n        }\n        deposits[account] = deposits[account].sub(amount);\n        claim.bondedDeposits[account] = claim.bondedDeposits[account].add(amount);\n        emit DepositBonded(superblockHash, account, amount);\n        return ERR_SUPERBLOCK_OK;\n    }\n    // @dev – accessor for a claim's bonded deposits.\n    // @param superblockHash – claim id.\n    // @param account – user's address.\n    // @return – user's deposit bonded for the claim.\n    function getBondedDeposit(bytes32 superblockHash, address account) external view returns (uint) {\n        SuperblockClaim storage claim = claims[superblockHash];\n        require(claimExists(claim));\n        return claim.bondedDeposits[account];\n    }\n    // @dev – unlocks a user's bonded deposits from a claim.\n    // @param superblockHash – claim id.\n    // @param account – user's address.\n    // @return – user's deposit which was unbonded from the claim.\n    function unbondDeposit(bytes32 superblockHash, address account) private returns (uint, uint) {\n        SuperblockClaim storage claim = claims[superblockHash];\n        if (!claimExists(claim)) {\n            return (ERR_SUPERBLOCK_BAD_CLAIM, 0);\n        }\n        if (!claim.decided) {\n            return (ERR_SUPERBLOCK_BAD_STATUS, 0);\n        }\n        uint bondedDeposit = claim.bondedDeposits[account];\n        delete claim.bondedDeposits[account];\n        deposits[account] = deposits[account].add(bondedDeposit);\n        emit DepositUnbonded(superblockHash, account, bondedDeposit);\n        return (ERR_SUPERBLOCK_OK, bondedDeposit);\n    }\n    // @dev – Propose a new superblock.\n    //\n    // @param _blocksMerkleRoot Root of the merkle tree of blocks contained in a superblock\n    // @param _timestamp Timestamp of the last block in the superblock\n    // @param _mtpTimestamp Median Timestamp of the last block in the superblock\n    // @param _lastHash Hash of the last block in the superblock\n    // @param _lastBits Difficulty bits of the last block in the superblock bits\n    // @param _parentHash Id of the parent superblock\n    // @return Error code and superblockHash\n    function proposeSuperblock(\n        bytes32 _blocksMerkleRoot,\n        uint _timestamp,\n        uint _mtpTimestamp,\n        bytes32 _lastHash,\n        uint32 _lastBits,\n        bytes32 _parentHash\n    ) external returns (uint, bytes32) {\n        require(address(trustedSuperblocks) != address(0));\n        if (deposits[msg.sender] < minProposalDeposit) {\n            emit ErrorClaim(0, ERR_SUPERBLOCK_MIN_DEPOSIT);\n            return (ERR_SUPERBLOCK_MIN_DEPOSIT, 0);\n        }\n        if (_mtpTimestamp + superblockDelay > block.timestamp) {\n            emit ErrorClaim(0, ERR_SUPERBLOCK_BAD_TIMESTAMP_MTP);\n            return (ERR_SUPERBLOCK_BAD_TIMESTAMP_MTP, 0);\n        }\n        if (block.timestamp + MAX_FUTURE_BLOCK_TIME_SYSCOIN + MAX_FUTURE_BLOCK_TIME_ETHEREUM <= _timestamp) {\n            emit ErrorClaim(0, ERR_SUPERBLOCK_BAD_TIMESTAMP);\n            return (ERR_SUPERBLOCK_BAD_TIMESTAMP, 0);\n        }\n        uint err;\n        bytes32 superblockHash;\n        (err, superblockHash) = trustedSuperblocks.propose(_blocksMerkleRoot, _timestamp, _mtpTimestamp, _lastHash, _lastBits, _parentHash, msg.sender);\n        if (err != 0) {\n            emit ErrorClaim(superblockHash, err);\n            return (err, superblockHash);\n        }\n        SuperblockClaim storage claim = claims[superblockHash];\n        // allow to propose an existing claim only if its invalid and decided and its a different submitter or not on the tip\n        // those are the ones that may actually be stuck and need to be proposed again,\n        // but we want to ensure its not the same submitter submitting the same thing\n        if (claimExists(claim)) {\n            require(claim.invalid == true && claim.decided == true && claim.submitter != msg.sender);\n        }\n        claim.superblockHash = superblockHash;\n        claim.submitter = msg.sender;\n        claim.challenger = address(0);\n        claim.decided = false;\n        claim.invalid = false;\n        claim.verificationOngoing = false;\n        claim.createdAt = block.timestamp;\n        claim.challengeTimeout = block.timestamp + superblockTimeout;\n        challengeDefended = false;\n        err = this.bondDeposit(superblockHash, msg.sender, minProposalDeposit);\n        require(err == ERR_SUPERBLOCK_OK);\n\n\n    \n        \n          \n    \n\n        \n        Expand All\n    \n    @@ -227,6 +228,10 @@ contract SyscoinClaimManager is Initializable, SyscoinDepositsManager, SyscoinEr\n  \n        emit SuperblockClaimCreated(superblockHash, msg.sender);\n        return (ERR_SUPERBLOCK_OK, superblockHash);\n    }\n    // @dev – challenge a superblock claim.\n    // @param superblockHash – Id of the superblock to challenge.\n    // @return - Error code and claim Id\n    function challengeSuperblock(bytes32 superblockHash) external returns (uint, bytes32) {\n        require(address(trustedSuperblocks) != address(0));\n        SuperblockClaim storage claim = claims[superblockHash];\n        if (!claimExists(claim)) {\n            emit ErrorClaim(superblockHash, ERR_SUPERBLOCK_BAD_CLAIM);\n            return (ERR_SUPERBLOCK_BAD_CLAIM, superblockHash);\n        }\n        if(challengeDefended == true){\n            emit ErrorClaim(superblockHash, ERR_SUPERBLOCK_CLAIM_ALREADY_DEFENDED);\n            return (ERR_SUPERBLOCK_CLAIM_ALREADY_DEFENDED, superblockHash);           \n        }\n        if (claim.decided || claim.invalid) {\n            emit ErrorClaim(superblockHash, ERR_SUPERBLOCK_CLAIM_DECIDED);\n            return (ERR_SUPERBLOCK_CLAIM_DECIDED, superblockHash);\n\n    \n          \n            \n    \n\n          \n          Expand Down\n          \n            \n    \n\n          \n          Expand Up\n    \n    @@ -453,7 +458,10 @@ contract SyscoinClaimManager is Initializable, SyscoinDepositsManager, SyscoinEr\n  \n        }\n        if (claim.verificationOngoing) {\n            emit ErrorClaim(superblockHash, ERR_SUPERBLOCK_CHALLENGE_EXISTS);\n            return (ERR_SUPERBLOCK_CHALLENGE_EXISTS, superblockHash);\n        }\n        if (deposits[msg.sender] < minProposalDeposit) {\n            emit ErrorClaim(superblockHash, ERR_SUPERBLOCK_MIN_DEPOSIT);\n            return (ERR_SUPERBLOCK_MIN_DEPOSIT, superblockHash);\n        }\n    \n        uint err = trustedSuperblocks.challenge(superblockHash, msg.sender);\n        if (err != 0) {\n            emit ErrorClaim(superblockHash, err);\n            return (err, 0);\n        }\n        err = this.bondDeposit(superblockHash, msg.sender, minProposalDeposit);\n        require(err == ERR_SUPERBLOCK_OK);\n        claim.challengeTimeout = block.timestamp + superblockTimeout;\n        claim.challenger = msg.sender;\n        emit SuperblockClaimChallenged(superblockHash, msg.sender);\n        trustedSyscoinBattleManager.beginBattleSession(superblockHash, claim.submitter,\n            claim.challenger);\n        emit VerificationGameStarted(superblockHash, claim.submitter,\n            claim.challenger);\n        claim.verificationOngoing = true;\n        return (ERR_SUPERBLOCK_OK, superblockHash);\n    }\n    // @dev – confirm semi approved superblock.\n    //\n    // A semi approved superblock can be confirmed if it has several descendant\n    // superblocks that are also semi-approved.\n    // If none of the descendants were challenged they will also be confirmed.\n    //\n    // @param superblockHash – the claim ID.\n    // @param descendantId - claim ID descendants\n    function confirmClaim(bytes32 superblockHash, bytes32 descendantId) external returns (bool) {\n        uint numSuperblocks = 0;\n        bool confirmDescendants = true;\n        bytes32 id = descendantId;\n        SuperblockClaim storage claim = claims[id];\n        while (id != superblockHash) {\n            if (!claimExists(claim) || claim.invalid) {\n                emit ErrorClaim(superblockHash, ERR_SUPERBLOCK_BAD_CLAIM);\n                return false;\n            }\n            if (trustedSuperblocks.getSuperblockStatus(id) != SyscoinSuperblocksI.Status.SemiApproved) {\n                emit ErrorClaim(superblockHash, ERR_SUPERBLOCK_BAD_STATUS);\n                return false;\n            }\n            if (confirmDescendants && claim.challenger != address(0)) {\n                confirmDescendants = false;\n            }\n            id = trustedSuperblocks.getSuperblockParentId(id);\n            claim = claims[id];\n            numSuperblocks += 1;\n        }\n        if (numSuperblocks < superblockConfirmations) {\n            emit ErrorClaim(superblockHash, ERR_SUPERBLOCK_MISSING_CONFIRMATIONS);\n            return false;\n        }\n        if (trustedSuperblocks.getSuperblockStatus(id) != SyscoinSuperblocksI.Status.SemiApproved) {\n            emit ErrorClaim(superblockHash, ERR_SUPERBLOCK_BAD_STATUS);\n            return false;\n        }\n        uint err = trustedSuperblocks.confirm(superblockHash, msg.sender);\n        if (err != ERR_SUPERBLOCK_OK) {\n            emit ErrorClaim(superblockHash, err);\n            return false;\n        }\n        emit SuperblockClaimSuccessful(superblockHash, claim.submitter);\n        doPaySubmitter(superblockHash, claim);\n        if (confirmDescendants) {\n            bytes32[] memory descendants = new bytes32[](numSuperblocks);\n            id = descendantId;\n            uint idx = 0;\n            while (id != superblockHash) {\n                descendants[idx] = id;\n                id = trustedSuperblocks.getSuperblockParentId(id);\n                idx += 1;\n            }\n            while (idx > 0) {\n                idx -= 1;\n                id = descendants[idx];\n                claim = claims[id];\n                err = trustedSuperblocks.confirm(id, msg.sender);\n                require(err == ERR_SUPERBLOCK_OK);\n                emit SuperblockClaimSuccessful(id, claim.submitter);\n                doPaySubmitter(id, claim);\n            }\n        }\n        return true;\n    }\n    // @dev – Reject a semi approved superblock.\n    //\n    // Superblocks that are not in the main chain can be marked as\n    // invalid.\n    //\n    // @param superblockHash – the claim ID.\n    function rejectClaim(bytes32 superblockHash) external returns (bool) {\n        SuperblockClaim storage claim = claims[superblockHash];\n        if (!claimExists(claim)) {\n            emit ErrorClaim(superblockHash, ERR_SUPERBLOCK_BAD_CLAIM);\n            return false;\n        }\n        uint height = trustedSuperblocks.getSuperblockHeight(superblockHash);\n        if (height > trustedSuperblocks.getChainHeight()) {\n            emit ErrorClaim(superblockHash, ERR_SUPERBLOCK_BAD_BLOCKHEIGHT);\n            return false;\n        }\n        SyscoinSuperblocksI.Status status = trustedSuperblocks.getSuperblockStatus(superblockHash);\n        if (status != SyscoinSuperblocksI.Status.SemiApproved) {\n            emit ErrorClaim(superblockHash, ERR_SUPERBLOCK_BAD_STATUS);\n            return false;\n        }\n        if (!claim.decided) {\n            emit ErrorClaim(superblockHash, ERR_SUPERBLOCK_CLAIM_DECIDED);\n            return false;\n        }\n        uint err = trustedSuperblocks.invalidate(superblockHash, claim.submitter);\n        require(err == ERR_SUPERBLOCK_OK);\n        emit SuperblockClaimFailed(superblockHash, claim.submitter);\n        doPayChallenger(superblockHash, claim);\n        claim.invalid = true;\n        return true;\n    }\n    // @dev – check whether a claim has successfully withstood all challenges.\n    // If successful without challenges, it will mark the superblock as confirmed.\n    // If successful with at least one challenge, it will mark the superblock as semi-approved.\n    // If verification failed, it will mark the superblock as invalid.\n    //\n    // @param superblockHash – claim ID.\n    function checkClaimFinished(bytes32 superblockHash) external returns (bool) {\n        SuperblockClaim storage claim = claims[superblockHash];\n        if (!claimExists(claim) || claim.decided) {\n            emit ErrorClaim(superblockHash, ERR_SUPERBLOCK_BAD_CLAIM);\n            return false;\n        }\n        // check that there is no ongoing verification game.\n        if (claim.verificationOngoing) {\n            emit ErrorClaim(superblockHash, ERR_SUPERBLOCK_VERIFICATION_PENDING);\n            return false;\n        }\n        // an invalid superblock can be rejected immediately\n        if (claim.invalid) {\n            // The superblock is invalid, submitter abandoned\n            // or superblock data is inconsistent\n            claim.decided = true;\n            uint err = trustedSuperblocks.invalidate(superblockHash, claim.submitter);\n            require(err == ERR_SUPERBLOCK_OK);\n            emit SuperblockClaimFailed(superblockHash, claim.submitter);\n            doPayChallenger(superblockHash, claim);\n            return false;\n        }\n        // check that the claim has exceeded the claim's specific challenge timeout.\n        if (block.timestamp <= claim.challengeTimeout) {\n            emit ErrorClaim(superblockHash, ERR_SUPERBLOCK_NO_TIMEOUT);\n            return false;\n        }\n        claim.decided = true;\n        bool confirmImmediately = false;\n        // No challenger and parent approved; confirm immediately\n        if (claim.challenger == address(0)) {\n            bytes32 parentId = trustedSuperblocks.getSuperblockParentId(superblockHash);\n            SyscoinSuperblocksI.Status status = trustedSuperblocks.getSuperblockStatus(parentId);\n            if (status == SyscoinSuperblocksI.Status.Approved) {\n                confirmImmediately = true;\n            }\n        }\n        if (confirmImmediately) {\n            uint err = trustedSuperblocks.confirm(superblockHash, msg.sender);\n            require(err == ERR_SUPERBLOCK_OK);\n            address submitter = claim.submitter;\n            unbondDeposit(superblockHash, submitter);\n            emit SuperblockClaimSuccessful(superblockHash, submitter);\n        } else {\n            uint err = trustedSuperblocks.semiApprove(superblockHash, msg.sender);\n            require(err == ERR_SUPERBLOCK_OK);\n            emit SuperblockClaimPending(superblockHash, claim.submitter);\n        }\n        return true;\n    }\n    // @dev – called when a battle session has ended.\n    //\n    // @param superblockHash - claim Id\n    // @param winner – winner of verification game.\n    // @param loser – loser of verification game.\n    function sessionDecided(bytes32 superblockHash, address winner, address loser) external onlyBattleManager {\n        SuperblockClaim storage claim = claims[superblockHash];\n        require(claimExists(claim));\n        claim.verificationOngoing = false;\n        address submitter = claim.submitter;\n\n        if (submitter == loser) {\n            claim.invalid = true;\n        } else if (submitter == winner) {\n            challengeDefended = true;\n        }\n        else{\n            revert();\n        }\n        emit SuperblockBattleDecided(superblockHash, winner, loser);\n\n    \n          \n            \n    \n\n          \n          Expand Down\n    \n    \n  \n    }\n    // @dev - Pay challenger\n    function doPayChallenger(bytes32 superblockHash, SuperblockClaim storage claim) private {\n        address challenger = claim.challenger;\n        address submitter = claim.submitter;\n        if (challenger != address(0)) {\n            uint reward = claim.bondedDeposits[submitter];\n            claim.bondedDeposits[challenger] = claim.bondedDeposits[challenger].add(reward);\n            unbondDeposit(superblockHash, challenger);\n        }\n        delete claim.bondedDeposits[submitter];\n    }\n    // @dev - Pay submitter with challenger deposit\n    function doPaySubmitter(bytes32 superblockHash, SuperblockClaim storage claim) private {\n        address challenger = claim.challenger;\n        address submitter = claim.submitter;\n        if (challenger != address(0)) {\n            uint reward = claim.bondedDeposits[challenger];\n            claim.bondedDeposits[challenger] = 0;\n            claim.bondedDeposits[submitter] = claim.bondedDeposits[submitter].add(reward);\n            unbondDeposit(superblockHash, challenger);\n        }\n        unbondDeposit(superblockHash, submitter);\n    }\n    // @dev - Check if a superblock can be semi approved by calling checkClaimFinished\n    function getInBattleAndSemiApprovable(bytes32 superblockHash) external view returns (bool) {\n        SuperblockClaim storage claim = claims[superblockHash];\n        return (trustedSuperblocks.getSuperblockStatus(superblockHash) == SyscoinSuperblocksI.Status.InBattle &&\n            !claim.invalid && !claim.verificationOngoing && block.timestamp > claim.challengeTimeout\n            && claim.challenger != address(0));\n    }\n    // @dev – Check if a claim exists\n    function claimExists(SuperblockClaim storage claim) private view returns (bool) {\n        return (claim.submitter != address(0));\n    }\n    // @dev - Return a given superblock's submitter\n    function getClaimSubmitter(bytes32 superblockHash) external view returns (address) {\n        return claims[superblockHash].submitter;\n    }\n    // @dev - Return superblock submission timestamp\n    function getNewSuperblockEventTimestamp(bytes32 superblockHash) external view returns (uint) {\n        return claims[superblockHash].createdAt;\n    }\n    // @dev - Return whether or not a claim has already been made\n    function getClaimExists(bytes32 superblockHash) external view returns (bool) {\n        return claimExists(claims[superblockHash]);\n    }\n    // @dev - Return claim status\n    function getClaimDecided(bytes32 superblockHash) external view returns (bool) {\n        return claims[superblockHash].decided;\n    }\n    // @dev - Check if a claim is invalid\n    function getClaimInvalid(bytes32 superblockHash) external view returns (bool) {\n        // TODO: see if this is redundant with superblock status\n        return claims[superblockHash].invalid;\n    }\n    function getClaimChallenger(bytes32 superblockHash) external view returns (address) {\n        SuperblockClaim storage claim = claims[superblockHash];\n        return claim.challenger;\n    }\n}"
    },
    {
        "tag": "denial of service",
        "url": "https://github.com/yieldprotocol/vault-v2/commit/2c6573d1ec7cadd28a4aba0b67c381aecbda21f9",
        "file": "contracts/other/convex/ConvexJoin.sol",
        "before": "// SPDX-License-Identifier: MIT\n// Original contract: https://github.com/convex-eth/platform/blob/main/contracts/contracts/wrappers/ConvexStakingWrapper.sol\npragma solidity 0.8.6;\nimport \"@yield-protocol/vault-interfaces/ICauldron.sol\";\nimport \"@yield-protocol/utils-v2/contracts/token/IERC20.sol\";\nimport \"@yield-protocol/utils-v2/contracts/token/TransferHelper.sol\";\nimport \"@yield-protocol/utils-v2/contracts/cast/CastU256U128.sol\";\nimport \"./interfaces/IRewardStaking.sol\";\nimport \"./CvxMining.sol\";\nimport \"../../BasicJoin.sol\";\n/// @notice Wrapper used to manage staking of Convex tokens\ncontract ConvexJoin is BasicJoin {\n    using CastU256U128 for uint256;\n    struct EarnedData {\n        address token;\n        uint256 amount;\n    }\n    struct RewardType {\n        address reward_token;\n        address reward_pool;\n        uint128 reward_integral;\n        uint128 reward_remaining;\n        mapping(address => uint256) reward_integral_for;\n        mapping(address => uint256) claimable_reward;\n    }\n    uint256 public managed_assets;\n    mapping(address => bytes12[]) public vaults; // Mapping to keep track of the user & their vaults\n    //constants/immutables\n    address public constant convexBooster = address(0xF403C135812408BFbE8713b5A23a04b3D48AAE31);\n    address public constant crv = address(0xD533a949740bb3306d119CC777fa900bA034cd52);\n    address public constant cvx = address(0x4e3FBD56CD56c3e72c1403e103b45Db9da5B9D2B);\n    address public immutable curveToken;\n    address public immutable convexToken;\n    address public immutable convexPool;\n    uint256 public immutable convexPoolId;\n    ICauldron public immutable cauldron;\n    //rewards\n    RewardType[] public rewards;\n    mapping(address => uint256) public registeredRewards;\n    uint256 private constant CRV_INDEX = 0;\n    uint256 private constant CVX_INDEX = 1;\n    //management\n    uint8 private _status = 1;\n    uint8 private constant _NOT_ENTERED = 1;\n    uint8 private constant _ENTERED = 2;\n    event Deposited(address indexed _user, address indexed _account, uint256 _amount, bool _wrapped);\n    event Withdrawn(address indexed _user, uint256 _amount, bool _unwrapped);\n    /// @notice Event called when a vault is added for a user\n    /// @param account The account for which vault is added\n    /// @param vaultId The vaultId to be added\n    event VaultAdded(address indexed account, bytes12 indexed vaultId);\n    /// @notice Event called when a vault is removed for a user\n    /// @param account The account for which vault is removed\n    /// @param vaultId The vaultId to be removed\n    event VaultRemoved(address indexed account, bytes12 indexed vaultId);\n    constructor(\n        address _curveToken,\n        address _convexToken,\n        address _convexPool,\n        uint256 _poolId,\n        ICauldron _cauldron\n    ) BasicJoin(_convexToken) {\n        curveToken = _curveToken;\n        convexToken = _convexToken;\n        convexPool = _convexPool;\n        convexPoolId = _poolId;\n        cauldron = _cauldron;\n    }\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n        _;\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n    /// @notice Give maximum approval to the pool & convex booster contract to transfer funds from wrapper\n    function setApprovals() public {\n        address _curveToken = curveToken;\n        IERC20(_curveToken).approve(convexBooster, 0);\n        IERC20(_curveToken).approve(convexBooster, type(uint256).max);\n        IERC20(convexToken).approve(convexPool, type(uint256).max);\n    }\n    /// ------ VAULT MANAGEMENT ------\n    /// @notice Adds a vault to the user's vault list\n    /// @param vaultId The id of the vault being added\n    function addVault(bytes12 vaultId) external {\n        address account = cauldron.vaults(vaultId).owner;\n        require(cauldron.assets(cauldron.vaults(vaultId).ilkId) == convexToken, \"Vault is for different ilk\");\n        require(account != address(0), \"No owner for the vault\");\n        bytes12[] storage vaults_ = vaults[account];\n        uint256 vaultsLength = vaults_.length;\n        for (uint256 i; i < vaultsLength; ++i) {\n            require(vaults_[i] != vaultId, \"Vault already added\");\n        }\n        vaults_.push(vaultId);\n        emit VaultAdded(account, vaultId);\n    }\n    /// @notice Remove a vault from the user's vault list\n    /// @param vaultId The id of the vault being removed\n    /// @param account The user from whom the vault needs to be removed\n    function removeVault(bytes12 vaultId, address account) public {\n        address owner = cauldron.vaults(vaultId).owner;\n        require(account != owner, \"vault belongs to account\");\n        bytes12[] storage vaults_ = vaults[account];\n        uint256 vaultsLength = vaults_.length;\n        for (uint256 i; i < vaultsLength; ++i) {\n            if (vaults_[i] == vaultId) {\n                bool isLast = i == vaultsLength - 1;\n                if (!isLast) {\n                    vaults_[i] = vaults_[vaultsLength - 1];\n                }\n                vaults_.pop();\n                emit VaultRemoved(account, vaultId);\n                return;\n            }\n        }\n        revert(\"Vault not found\");\n    }\n    /// @notice Get user's balance of collateral deposited in various vaults\n    /// @param account_ User's address for which balance is requested\n    /// @return User's balance of collateral\n    function aggregatedAssetsOf(address account_) internal view returns (uint256) {\n        bytes12[] memory userVault = vaults[account_];\n        //add up all balances of all vaults registered in the join and owned by the account\n        uint256 collateral;\n        DataTypes.Balances memory balance;\n        uint256 userVaultLength = userVault.length;\n        for (uint256 i; i < userVaultLength; ++i) {\n            if (cauldron.vaults(userVault[i]).owner == account_) {\n                balance = cauldron.balances(userVault[i]);\n                collateral = collateral + balance.ink;\n            }\n        }\n        return collateral;\n    }\n    /// ------ REWARDS MANAGEMENT ------\n    /// @notice Adds reward tokens by reading the available rewards from the RewardStaking pool\n    /// @dev CRV token is added as a reward by default\n    function addRewards() public {\n        address mainPool = convexPool;\n        if (rewards.length == 0) {\n            RewardType storage reward = rewards.push();\n            reward.reward_token = crv;\n            reward.reward_pool = mainPool;\n            reward = rewards.push();\n            reward.reward_token = cvx;\n            // The reward_pool is set to address(0) as initially we don't know if the pool has cvx rewards.\n            // And since the default is address(0) we don't explicitly set it\n            registeredRewards[crv] = CRV_INDEX + 1; //mark registered at index+1\n            registeredRewards[cvx] = CVX_INDEX + 1; //mark registered at index+1\n        }\n        uint256 extraCount = IRewardStaking(mainPool).extraRewardsLength();\n        for (uint256 i; i < extraCount; ++i) {\n            address extraPool = IRewardStaking(mainPool).extraRewards(i);\n            address extraToken = IRewardStaking(extraPool).rewardToken();\n            if (extraToken == cvx) {\n                //update cvx reward pool address\n                if (rewards[CVX_INDEX].reward_pool == address(0)) {\n                    rewards[CVX_INDEX].reward_pool = extraPool;\n                }\n            } else if (registeredRewards[extraToken] == 0) {\n                //add new token to list\n                RewardType storage reward = rewards.push();\n                reward.reward_token = extraToken;\n                reward.reward_pool = extraPool;\n                registeredRewards[extraToken] = rewards.length; //mark registered at index+1\n            }\n        }\n    }\n    /// ------ JOIN and EXIT ------\n    /// @dev Take convex LP token and credit it to the `user` address.\n    function join(address user, uint128 amount) external override auth returns (uint128) {\n        require(amount > 0, \"No convex token to wrap\");\n        _checkpoint(user, false);\n        managed_assets += amount;\n        _join(user, amount);\n        storedBalance -= amount;\n        IRewardStaking(convexPool).stake(amount);\n        emit Deposited(msg.sender, user, amount, false);\n        return amount;\n    }\n    /// @dev Debit convex LP tokens held by this contract and send them to the `user` address.\n    function exit(address user, uint128 amount) external override auth returns (uint128) {\n        _checkpoint(user, false);\n        managed_assets -= amount;\n        IRewardStaking(convexPool).withdraw(amount, false);\n        storedBalance += amount;\n        _exit(user, amount);\n        emit Withdrawn(user, amount, false);\n        return amount;\n    }\n    /// ------ REWARDS MATH ------\n    /// @notice Calculates & upgrades the integral for distributing the reward token\n    /// @param _index The index of the reward token for which the calculations are to be done\n    /// @param _account Account for which the CvxIntegral has to be calculated\n    /// @param _balance Balance of the accounts\n    /// @param _supply Total supply of the wrapped token\n    /// @param _isClaim Whether to claim the calculated rewards\n    function _calcRewardIntegral(\n        uint256 _index,\n        address _account,\n        uint256 _balance,\n        uint256 _supply,\n        bool _isClaim\n    ) internal {\n        RewardType storage reward = rewards[_index];\n        uint256 rewardIntegral = reward.reward_integral;\n        uint256 rewardRemaining = reward.reward_remaining;\n        //get difference in balance and remaining rewards\n        //getReward is unguarded so we use reward_remaining to keep track of how much was actually claimed\n        uint256 bal = IERC20(reward.reward_token).balanceOf(address(this));\n        if (_supply > 0 && (bal - rewardRemaining) > 0) {\n            unchecked {\n                // bal-rewardRemaining can't underflow because of the check above\n                rewardIntegral = rewardIntegral + ((bal - rewardRemaining) * 1e20) / _supply;\n                reward.reward_integral = rewardIntegral.u128();\n            }\n        }\n        //do not give rewards to this contract\n        if (_account != address(this)) {\n            //update user integrals\n            uint256 userI = reward.reward_integral_for[_account];\n            if (_isClaim || userI < rewardIntegral) {\n                if (_isClaim) {\n                    uint256 receiveable = reward.claimable_reward[_account] +\n                        ((_balance * (rewardIntegral - userI)) / 1e20);\n                    if (receiveable > 0) {\n                        reward.claimable_reward[_account] = 0;\n                        unchecked {\n                            bal -= receiveable;\n                        }\n                        TransferHelper.safeTransfer(IERC20(reward.reward_token), _account, receiveable);\n                    }\n                } else {\n                    reward.claimable_reward[_account] =\n                        reward.claimable_reward[_account] +\n                        ((_balance * (rewardIntegral - userI)) / 1e20);\n                }\n                reward.reward_integral_for[_account] = rewardIntegral;\n            }\n        }\n        //update remaining reward here since balance could have changed if claiming\n        if (bal != rewardRemaining) {\n            reward.reward_remaining = bal.u128();\n        }\n    }\n    /// ------ CHECKPOINT AND CLAIM ------\n    /// @notice Create a checkpoint for the supplied addresses by updating the reward integrals & claimable reward for them & claims the rewards\n    /// @param _account The account for which checkpoints have to be calculated\n    function _checkpoint(address _account, bool claim) internal {\n        uint256 supply = managed_assets;\n        uint256 depositedBalance;\n        depositedBalance = aggregatedAssetsOf(_account);\n        IRewardStaking(convexPool).getReward(address(this), true);\n\n        uint256 rewardCount = rewards.length;\n        for (uint256 i; i < rewardCount; ++i) {\n            _calcRewardIntegral(i, _account, depositedBalance, supply, claim);\n        }\n\n    \n          \n            \n    \n\n          \n          Expand Down\n    \n    \n  \n    }\n    /// @notice Create a checkpoint for the supplied addresses by updating the reward integrals & claimable reward for them\n    /// @param _account The accounts for which checkpoints have to be calculated\n    function checkpoint(address _account) external returns (bool) {\n        _checkpoint(_account, false);\n        return true;\n    }\n    /// @notice Claim reward for the supplied account\n    /// @param _account Address whose reward is to be claimed\n    function getReward(address _account) external nonReentrant {\n        //claim directly in checkpoint logic to save a bit of gas\n        _checkpoint(_account, true);\n    }\n    /// @notice Get the amount of tokens the user has earned\n    /// @param _account Address whose balance is to be checked\n    /// @return claimable Array of earned tokens and their amount\n    function earned(address _account) external view returns (EarnedData[] memory claimable) {\n        uint256 supply = managed_assets;\n        uint256 depositedBalance = aggregatedAssetsOf(_account);\n        uint256 rewardCount = rewards.length;\n        claimable = new EarnedData[](rewardCount);\n        for (uint256 i; i < rewardCount; ++i) {\n            RewardType storage reward = rewards[i];\n            if (reward.reward_pool == address(0)) {\n                //cvx reward may not have a reward pool yet\n                //so just add whats already been checkpointed\n                claimable[i].amount += reward.claimable_reward[_account];\n                claimable[i].token = reward.reward_token;\n                continue;\n            }\n            //change in reward is current balance - remaining reward + earned\n            uint256 bal = IERC20(reward.reward_token).balanceOf(address(this));\n            uint256 d_reward = bal - reward.reward_remaining;\n            d_reward = d_reward + IRewardStaking(reward.reward_pool).earned(address(this));\n            uint256 I = reward.reward_integral;\n            if (supply > 0) {\n                I = I + (d_reward * 1e20) / supply;\n            }\n            uint256 newlyClaimable = (depositedBalance * (I - (reward.reward_integral_for[_account]))) / (1e20);\n            claimable[i].amount += reward.claimable_reward[_account] + newlyClaimable;\n            claimable[i].token = reward.reward_token;\n            //calc cvx minted from crv and add to cvx claimables\n            //note: crv is always index 0 so will always run before cvx\n            if (i == CRV_INDEX) {\n                //because someone can call claim for the pool outside of checkpoints, need to recalculate crv without the local balance\n                I = reward.reward_integral;\n                if (supply > 0) {\n                    I = I + (IRewardStaking(reward.reward_pool).earned(address(this)) * 1e20) / supply;\n                }\n                newlyClaimable = (depositedBalance * (I - reward.reward_integral_for[_account])) / 1e20;\n                claimable[CVX_INDEX].amount = CvxMining.ConvertCrvToCvx(newlyClaimable);\n                claimable[CVX_INDEX].token = cvx;\n            }\n        }\n    }\n}",
        "after": "// SPDX-License-Identifier: MIT\n// Original contract: https://github.com/convex-eth/platform/blob/main/contracts/contracts/wrappers/ConvexStakingWrapper.sol\npragma solidity 0.8.6;\nimport \"@yield-protocol/vault-interfaces/ICauldron.sol\";\nimport \"@yield-protocol/utils-v2/contracts/token/IERC20.sol\";\nimport \"@yield-protocol/utils-v2/contracts/token/TransferHelper.sol\";\nimport \"@yield-protocol/utils-v2/contracts/cast/CastU256U128.sol\";\nimport \"./interfaces/IRewardStaking.sol\";\nimport \"./CvxMining.sol\";\nimport \"../../BasicJoin.sol\";\n/// @notice Wrapper used to manage staking of Convex tokens\ncontract ConvexJoin is BasicJoin {\n    using CastU256U128 for uint256;\n    struct EarnedData {\n        address token;\n        uint256 amount;\n    }\n    struct RewardType {\n        address reward_token;\n        address reward_pool;\n        uint128 reward_integral;\n        uint128 reward_remaining;\n        mapping(address => uint256) reward_integral_for;\n        mapping(address => uint256) claimable_reward;\n    }\n    uint256 public managed_assets;\n    mapping(address => bytes12[]) public vaults; // Mapping to keep track of the user & their vaults\n    //constants/immutables\n    address public constant convexBooster = address(0xF403C135812408BFbE8713b5A23a04b3D48AAE31);\n    address public constant crv = address(0xD533a949740bb3306d119CC777fa900bA034cd52);\n    address public constant cvx = address(0x4e3FBD56CD56c3e72c1403e103b45Db9da5B9D2B);\n    address public immutable curveToken;\n    address public immutable convexToken;\n    address public immutable convexPool;\n    uint256 public immutable convexPoolId;\n    ICauldron public immutable cauldron;\n    //rewards\n    RewardType[] public rewards;\n    mapping(address => uint256) public registeredRewards;\n    uint256 private constant CRV_INDEX = 0;\n    uint256 private constant CVX_INDEX = 1;\n    //management\n    uint8 private _status = 1;\n    uint8 private constant _NOT_ENTERED = 1;\n    uint8 private constant _ENTERED = 2;\n    event Deposited(address indexed _user, address indexed _account, uint256 _amount, bool _wrapped);\n    event Withdrawn(address indexed _user, uint256 _amount, bool _unwrapped);\n    /// @notice Event called when a vault is added for a user\n    /// @param account The account for which vault is added\n    /// @param vaultId The vaultId to be added\n    event VaultAdded(address indexed account, bytes12 indexed vaultId);\n    /// @notice Event called when a vault is removed for a user\n    /// @param account The account for which vault is removed\n    /// @param vaultId The vaultId to be removed\n    event VaultRemoved(address indexed account, bytes12 indexed vaultId);\n    constructor(\n        address _curveToken,\n        address _convexToken,\n        address _convexPool,\n        uint256 _poolId,\n        ICauldron _cauldron\n    ) BasicJoin(_convexToken) {\n        curveToken = _curveToken;\n        convexToken = _convexToken;\n        convexPool = _convexPool;\n        convexPoolId = _poolId;\n        cauldron = _cauldron;\n    }\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n        _;\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n    /// @notice Give maximum approval to the pool & convex booster contract to transfer funds from wrapper\n    function setApprovals() public {\n        address _curveToken = curveToken;\n        IERC20(_curveToken).approve(convexBooster, 0);\n        IERC20(_curveToken).approve(convexBooster, type(uint256).max);\n        IERC20(convexToken).approve(convexPool, type(uint256).max);\n    }\n    /// ------ VAULT MANAGEMENT ------\n    /// @notice Adds a vault to the user's vault list\n    /// @param vaultId The id of the vault being added\n    function addVault(bytes12 vaultId) external {\n        address account = cauldron.vaults(vaultId).owner;\n        require(cauldron.assets(cauldron.vaults(vaultId).ilkId) == convexToken, \"Vault is for different ilk\");\n        require(account != address(0), \"No owner for the vault\");\n        bytes12[] storage vaults_ = vaults[account];\n        uint256 vaultsLength = vaults_.length;\n        for (uint256 i; i < vaultsLength; ++i) {\n            require(vaults_[i] != vaultId, \"Vault already added\");\n        }\n        vaults_.push(vaultId);\n        emit VaultAdded(account, vaultId);\n    }\n    /// @notice Remove a vault from the user's vault list\n    /// @param vaultId The id of the vault being removed\n    /// @param account The user from whom the vault needs to be removed\n    function removeVault(bytes12 vaultId, address account) public {\n        address owner = cauldron.vaults(vaultId).owner;\n        require(account != owner, \"vault belongs to account\");\n        bytes12[] storage vaults_ = vaults[account];\n        uint256 vaultsLength = vaults_.length;\n        for (uint256 i; i < vaultsLength; ++i) {\n            if (vaults_[i] == vaultId) {\n                bool isLast = i == vaultsLength - 1;\n                if (!isLast) {\n                    vaults_[i] = vaults_[vaultsLength - 1];\n                }\n                vaults_.pop();\n                emit VaultRemoved(account, vaultId);\n                return;\n            }\n        }\n        revert(\"Vault not found\");\n    }\n    /// @notice Get user's balance of collateral deposited in various vaults\n    /// @param account_ User's address for which balance is requested\n    /// @return User's balance of collateral\n    function aggregatedAssetsOf(address account_) internal view returns (uint256) {\n        bytes12[] memory userVault = vaults[account_];\n        //add up all balances of all vaults registered in the join and owned by the account\n        uint256 collateral;\n        DataTypes.Balances memory balance;\n        uint256 userVaultLength = userVault.length;\n        for (uint256 i; i < userVaultLength; ++i) {\n            if (cauldron.vaults(userVault[i]).owner == account_) {\n                balance = cauldron.balances(userVault[i]);\n                collateral = collateral + balance.ink;\n            }\n        }\n        return collateral;\n    }\n    /// ------ REWARDS MANAGEMENT ------\n    /// @notice Adds reward tokens by reading the available rewards from the RewardStaking pool\n    /// @dev CRV token is added as a reward by default\n    function addRewards() public {\n        address mainPool = convexPool;\n        if (rewards.length == 0) {\n            RewardType storage reward = rewards.push();\n            reward.reward_token = crv;\n            reward.reward_pool = mainPool;\n            reward = rewards.push();\n            reward.reward_token = cvx;\n            // The reward_pool is set to address(0) as initially we don't know if the pool has cvx rewards.\n            // And since the default is address(0) we don't explicitly set it\n            registeredRewards[crv] = CRV_INDEX + 1; //mark registered at index+1\n            registeredRewards[cvx] = CVX_INDEX + 1; //mark registered at index+1\n        }\n        uint256 extraCount = IRewardStaking(mainPool).extraRewardsLength();\n        for (uint256 i; i < extraCount; ++i) {\n            address extraPool = IRewardStaking(mainPool).extraRewards(i);\n            address extraToken = IRewardStaking(extraPool).rewardToken();\n            if (extraToken == cvx) {\n                //update cvx reward pool address\n                if (rewards[CVX_INDEX].reward_pool == address(0)) {\n                    rewards[CVX_INDEX].reward_pool = extraPool;\n                }\n            } else if (registeredRewards[extraToken] == 0) {\n                //add new token to list\n                RewardType storage reward = rewards.push();\n                reward.reward_token = extraToken;\n                reward.reward_pool = extraPool;\n                registeredRewards[extraToken] = rewards.length; //mark registered at index+1\n            }\n        }\n    }\n    /// ------ JOIN and EXIT ------\n    /// @dev Take convex LP token and credit it to the `user` address.\n    function join(address user, uint128 amount) external override auth returns (uint128) {\n        require(amount > 0, \"No convex token to wrap\");\n        _checkpoint(user, false);\n        managed_assets += amount;\n        _join(user, amount);\n        storedBalance -= amount;\n        IRewardStaking(convexPool).stake(amount);\n        emit Deposited(msg.sender, user, amount, false);\n        return amount;\n    }\n    /// @dev Debit convex LP tokens held by this contract and send them to the `user` address.\n    function exit(address user, uint128 amount) external override auth returns (uint128) {\n        _checkpoint(user, false);\n        managed_assets -= amount;\n        IRewardStaking(convexPool).withdraw(amount, false);\n        storedBalance += amount;\n        _exit(user, amount);\n        emit Withdrawn(user, amount, false);\n        return amount;\n    }\n    /// ------ REWARDS MATH ------\n    /// @notice Calculates & upgrades the integral for distributing the reward token\n    /// @param _index The index of the reward token for which the calculations are to be done\n    /// @param _account Account for which the CvxIntegral has to be calculated\n    /// @param _balance Balance of the accounts\n    /// @param _supply Total supply of the wrapped token\n    /// @param _isClaim Whether to claim the calculated rewards\n    function _calcRewardIntegral(\n        uint256 _index,\n        address _account,\n        uint256 _balance,\n        uint256 _supply,\n        bool _isClaim\n    ) internal {\n        RewardType storage reward = rewards[_index];\n        uint256 rewardIntegral = reward.reward_integral;\n        uint256 rewardRemaining = reward.reward_remaining;\n        //get difference in balance and remaining rewards\n        //getReward is unguarded so we use reward_remaining to keep track of how much was actually claimed\n        uint256 bal = IERC20(reward.reward_token).balanceOf(address(this));\n        if (_supply > 0 && (bal - rewardRemaining) > 0) {\n            unchecked {\n                // bal-rewardRemaining can't underflow because of the check above\n                rewardIntegral = rewardIntegral + ((bal - rewardRemaining) * 1e20) / _supply;\n                reward.reward_integral = rewardIntegral.u128();\n            }\n        }\n        //do not give rewards to this contract\n        if (_account != address(this)) {\n            //update user integrals\n            uint256 userI = reward.reward_integral_for[_account];\n            if (_isClaim || userI < rewardIntegral) {\n                if (_isClaim) {\n                    uint256 receiveable = reward.claimable_reward[_account] +\n                        ((_balance * (rewardIntegral - userI)) / 1e20);\n                    if (receiveable > 0) {\n                        reward.claimable_reward[_account] = 0;\n                        unchecked {\n                            bal -= receiveable;\n                        }\n                        TransferHelper.safeTransfer(IERC20(reward.reward_token), _account, receiveable);\n                    }\n                } else {\n                    reward.claimable_reward[_account] =\n                        reward.claimable_reward[_account] +\n                        ((_balance * (rewardIntegral - userI)) / 1e20);\n                }\n                reward.reward_integral_for[_account] = rewardIntegral;\n            }\n        }\n        //update remaining reward here since balance could have changed if claiming\n        if (bal != rewardRemaining) {\n            reward.reward_remaining = bal.u128();\n        }\n    }\n    /// ------ CHECKPOINT AND CLAIM ------\n    /// @notice Create a checkpoint for the supplied addresses by updating the reward integrals & claimable reward for them & claims the rewards\n    /// @param _account The account for which checkpoints have to be calculated\n    function _checkpoint(address _account, bool claim) internal {\n        uint256 supply = managed_assets;\n        uint256 depositedBalance;\n        depositedBalance = aggregatedAssetsOf(_account);\n        IRewardStaking(convexPool).getReward(address(this), true);\n\n        uint256 rewardCount = rewards.length;\n        // Assuming that the reward distribution takes am avg of 230k gas per reward token we are setting an upper limit of 40 to prevent DOS attack\n        rewardCount = rewardCount >= 40 ? 40 : rewardCount;\n        for (uint256 i; i < rewardCount; ++i) {\n            _calcRewardIntegral(i, _account, depositedBalance, supply, claim);\n        }\n\n    \n          \n            \n    \n\n          \n          Expand Down\n    \n    \n  \n    }\n    /// @notice Create a checkpoint for the supplied addresses by updating the reward integrals & claimable reward for them\n    /// @param _account The accounts for which checkpoints have to be calculated\n    function checkpoint(address _account) external returns (bool) {\n        _checkpoint(_account, false);\n        return true;\n    }\n    /// @notice Claim reward for the supplied account\n    /// @param _account Address whose reward is to be claimed\n    function getReward(address _account) external nonReentrant {\n        //claim directly in checkpoint logic to save a bit of gas\n        _checkpoint(_account, true);\n    }\n    /// @notice Get the amount of tokens the user has earned\n    /// @param _account Address whose balance is to be checked\n    /// @return claimable Array of earned tokens and their amount\n    function earned(address _account) external view returns (EarnedData[] memory claimable) {\n        uint256 supply = managed_assets;\n        uint256 depositedBalance = aggregatedAssetsOf(_account);\n        uint256 rewardCount = rewards.length;\n        claimable = new EarnedData[](rewardCount);\n        for (uint256 i; i < rewardCount; ++i) {\n            RewardType storage reward = rewards[i];\n            if (reward.reward_pool == address(0)) {\n                //cvx reward may not have a reward pool yet\n                //so just add whats already been checkpointed\n                claimable[i].amount += reward.claimable_reward[_account];\n                claimable[i].token = reward.reward_token;\n                continue;\n            }\n            //change in reward is current balance - remaining reward + earned\n            uint256 bal = IERC20(reward.reward_token).balanceOf(address(this));\n            uint256 d_reward = bal - reward.reward_remaining;\n            d_reward = d_reward + IRewardStaking(reward.reward_pool).earned(address(this));\n            uint256 I = reward.reward_integral;\n            if (supply > 0) {\n                I = I + (d_reward * 1e20) / supply;\n            }\n            uint256 newlyClaimable = (depositedBalance * (I - (reward.reward_integral_for[_account]))) / (1e20);\n            claimable[i].amount += reward.claimable_reward[_account] + newlyClaimable;\n            claimable[i].token = reward.reward_token;\n            //calc cvx minted from crv and add to cvx claimables\n            //note: crv is always index 0 so will always run before cvx\n            if (i == CRV_INDEX) {\n                //because someone can call claim for the pool outside of checkpoints, need to recalculate crv without the local balance\n                I = reward.reward_integral;\n                if (supply > 0) {\n                    I = I + (IRewardStaking(reward.reward_pool).earned(address(this)) * 1e20) / supply;\n                }\n                newlyClaimable = (depositedBalance * (I - reward.reward_integral_for[_account])) / 1e20;\n                claimable[CVX_INDEX].amount = CvxMining.ConvertCrvToCvx(newlyClaimable);\n                claimable[CVX_INDEX].token = cvx;\n            }\n        }\n    }\n}"
    },
    {
        "tag": "arithmetic",
        "url": "https://github.com/pendle-finance/pendle-core/commit/f1bf503694c5b98ed5dc37f7eb35614e3462a038",
        "file": "contracts/libraries/MathLib.sol",
        "before": "// SPDX-License-Identifier: GPL-3.0-or-later\n/*\n * GNU General Public License v3.0 or later\n * ========================================\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\npragma solidity ^0.7.0;\npragma experimental ABIEncoderV2;\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nlibrary Math {\n    using SafeMath for uint256;\n    uint256 internal constant BIG_NUMBER = (uint256(1) << uint256(200));\n    uint256 internal constant PRECISION_BITS = 40;\n    uint256 internal constant RONE = uint256(1) << PRECISION_BITS;\n    uint256 internal constant PI = (314 * RONE) / 10**2;\n    uint256 internal constant PI_PLUSONE = (414 * RONE) / 10**2;\n    uint256 internal constant PRECISION_POW = 1e2;\n    function checkMultOverflow(uint256 _x, uint256 _y) internal pure returns (bool) {\n        if (_y == 0) return false;\n        return (((_x * _y) / _y) != _x);\n    }\n    /**\n    @notice find the integer part of log2(p/q)\n        => find largest x s.t p >= q * 2^x\n        => find largest x s.t 2^x <= p / q\n     */\n    function log2Int(uint256 _p, uint256 _q) internal pure returns (uint256) {\n        uint256 res = 0;\n        uint256 remain = _p / _q;\n        while (remain > 0) {\n            res++;\n            remain /= 2;\n        }\n        return res - 1;\n    }\n    /**\n    @notice log2 for a number that it in [1,2)\n    @dev _x is FP, return a FP\n    @dev function is from Kyber. Long modified the condition to be (_x >= one) && (_x < two)\n    to avoid the case where x = 2 may lead to incorrect result\n     */\n    function log2ForSmallNumber(uint256 _x) internal pure returns (uint256) {\n        uint256 res = 0;\n        uint256 one = (uint256(1) << PRECISION_BITS);\n        uint256 two = 2 * one;\n        uint256 addition = one;\n        require((_x >= one) && (_x < two), \"MATH_ERROR\");\n        require(PRECISION_BITS < 125, \"MATH_ERROR\");\n        for (uint256 i = PRECISION_BITS; i > 0; i--) {\n            _x = (_x * _x) / one;\n            addition = addition / 2;\n            if (_x >= two) {\n                _x = _x / 2;\n                res += addition;\n            }\n        }\n        return res;\n    }\n    /**\n    @notice log2 of (p/q). returns result in FP form\n    @dev function is from Kyber.\n    @dev _p & _q is FP, return a FP\n     */\n    function logBase2(uint256 _p, uint256 _q) internal pure returns (uint256) {\n        uint256 n = 0;\n        if (_p > _q) {\n            n = log2Int(_p, _q);\n        }\n        require(n * RONE <= BIG_NUMBER, \"MATH_ERROR\");\n        require(!checkMultOverflow(_p, RONE), \"MATH_ERROR\");\n        require(!checkMultOverflow(n, RONE), \"MATH_ERROR\");\n        require(!checkMultOverflow(uint256(1) << n, _q), \"MATH_ERROR\");\n        uint256 y = (_p * RONE) / (_q * (uint256(1) << n));\n        uint256 log2Small = log2ForSmallNumber(y);\n        assert(log2Small <= BIG_NUMBER);\n        return n * RONE + log2Small;\n    }\n    /**\n    @notice calculate ln(p/q). returned result >= 0\n    @dev function is from Kyber.\n    @dev _p & _q is FP, return a FP\n    */\n    function ln(uint256 p, uint256 q) internal pure returns (uint256) {\n        uint256 ln2Numerator = 6931471805599453094172;\n        uint256 ln2Denomerator = 10000000000000000000000;\n        uint256 log2x = logBase2(p, q);\n        require(!checkMultOverflow(ln2Numerator, log2x), \"MATH_ERROR\");\n        return (ln2Numerator * log2x) / ln2Denomerator;\n    }\n    /**\n    @notice extract the fractional part of a FP\n    @dev value is a FP, return a FP\n     */\n    function fpart(uint256 value) internal pure returns (uint256) {\n        return value % RONE;\n    }\n    /**\n    @notice convert a FP to an Int\n    @dev value is a FP, return an Int\n     */\n    function toInt(uint256 value) internal pure returns (uint256) {\n        return value / RONE;\n    }\n    /**\n    @notice convert an Int to a FP\n    @dev value is an Int, return a FP\n     */\n    function toFP(uint256 value) internal pure returns (uint256) {\n        return value * RONE;\n    }\n    /**\n    @notice return e^exp in FP form\n    @dev estimation by formula at http://pages.mtu.edu/~shene/COURSES/cs201/NOTES/chap04/exp.html\n        the function is based on exp function of:\n        https://github.com/NovakDistributed/macroverse/blob/master/contracts/RealMath.sol\n    @dev the function is expected to converge quite fast, after about 20 iteration\n    @dev exp is a FP, return a FP\n     */\n    function rpowe(uint256 exp) internal pure returns (uint256) {\n        uint256 res = 0;\n        uint256 curTerm = RONE;\n        /* no limit on n. If the function cannot converge, it will lead to out of gas*/\n        for (uint256 n = 0; ; n++) {\n            res += curTerm;\n            curTerm = rmul(curTerm, rdiv(exp, toFP(n + 1)));\n            if (curTerm == 0) {\n                break;\n            }\n            if (n == 500) {\n                /*\n                testing shows that in the most extreme case, it will take 430 turns to converge.\n                however, it's expected that the numbers will not exceed 2^120 in normal situation\n                the most extreme case is rpow((1<<256)-1,(1<<40)-1) (equal to rpow((2^256-1)/2^40,0.99..9))\n                */\n                revert(\"RPOWE_SLOW_CONVERGE\");\n            }\n        }\n        return res;\n    }\n    /**\n    @notice calculate base^exp with base and exp being FP int\n    @dev to improve accuracy, base^exp = base^(int(exp)+frac(exp))\n                                       = base^int(exp) * base^frac\n    @dev base & exp are FP, return a FP\n     */\n    function rpow(uint256 base, uint256 exp) internal pure returns (uint256) {\n        if (exp == 0) {\n            // Anything to the 0 is 1\n            return RONE;\n        }\n        if (base == 0) {\n            // 0 to anything except 0 is 0\n            return 0;\n        }\n        uint256 frac = fpart(exp); // get the fractional part\n        uint256 whole = exp - frac;\n        uint256 wholePow = rpowi(base, toInt(whole)); // whole is a FP, convert to Int\n        uint256 fracPow;\n        // instead of calculating base ^ frac, we will calculate e ^ (frac*ln(base))\n        if (base < RONE) {\n            /* since the base is smaller than 1.0, ln(base) < 0.\n            Since 1 / (e^(frac*ln(1/base))) = e ^ (frac*ln(base)),\n            we will calculate 1 / (e^(frac*ln(1/base))) instead.\n            */\n            uint256 newExp = rmul(frac, ln(rdiv(RONE, base), RONE));\n            fracPow = rdiv(RONE, rpowe(newExp));\n        } else {\n            /* base is greater than 1, calculate normally */\n            uint256 newExp = rmul(frac, ln(base, RONE));\n            fracPow = rpowe(newExp);\n        }\n        return rmul(wholePow, fracPow);\n    }\n    /**\n    @notice return base^exp with base in FP form and exp in Int\n    @dev this function use a technique called: exponentiating by squaring\n        complexity O(log(q))\n    @dev function is from Kyber.\n    @dev base is a FP, exp is an Int, return a FP\n     */\n    function rpowi(uint256 base, uint256 exp) internal pure returns (uint256) {\n        uint256 res = exp % 2 != 0 ? base : RONE;\n        for (exp /= 2; exp != 0; exp /= 2) {\n            base = rmul(base, base);\n            if (exp % 2 != 0) {\n                res = rmul(res, base);\n            }\n        }\n        return res;\n    }\n    /**\n    @dev y is an Int, returns an Int\n    @dev babylonian method (https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method)\n    @dev from Uniswap\n     */\n    function sqrt(uint256 y) internal pure returns (uint256 z) {\n        if (y > 3) {\n            z = y;\n            uint256 x = y / 2 + 1;\n            while (x < z) {\n                z = x;\n                x = (y / x + x) / 2;\n            }\n        } else if (y != 0) {\n            z = 1;\n        }\n    }\n    /**\n    @notice divide 2 FP, return a FP\n    @dev function is from Balancer.\n    @dev x & y are FP, return a FP\n     */\n    function rdiv(uint256 x, uint256 y) internal pure returns (uint256) {\n        return (y / 2).add(x.mul(RONE)).div(y);\n    }\n    /**\n    @notice multiply 2 FP, return a FP\n    @dev function is from Balancer.\n    @dev x & y are FP, return a FP\n     */\n    function rmul(uint256 x, uint256 y) internal pure returns (uint256) {\n        return (RONE / 2).add(x.mul(y)).div(RONE);\n    }\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a >= b ? a : b;\n    }\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n}",
        "after": "// SPDX-License-Identifier: GPL-3.0-or-later\n/*\n * GNU General Public License v3.0 or later\n * ========================================\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\npragma solidity ^0.7.0;\npragma experimental ABIEncoderV2;\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nlibrary Math {\n    using SafeMath for uint256;\n    uint256 internal constant BIG_NUMBER = (uint256(1) << uint256(200));\n    uint256 internal constant PRECISION_BITS = 40;\n    uint256 internal constant RONE = uint256(1) << PRECISION_BITS;\n    uint256 internal constant PI = (314 * RONE) / 10**2;\n    uint256 internal constant PI_PLUSONE = (414 * RONE) / 10**2;\n    uint256 internal constant PRECISION_POW = 1e2;\n    function checkMultOverflow(uint256 _x, uint256 _y) internal pure returns (bool) {\n        if (_y == 0) return false;\n        return (((_x * _y) / _y) != _x);\n    }\n    /**\n    @notice find the integer part of log2(p/q)\n        => find largest x s.t p >= q * 2^x\n        => find largest x s.t 2^x <= p / q\n     */\n    function log2Int(uint256 _p, uint256 _q) internal pure returns (uint256) {\n        uint256 res = 0;\n        uint256 remain = _p / _q;\n        while (remain > 0) {\n            res++;\n            remain /= 2;\n        }\n        return res - 1;\n    }\n    /**\n    @notice log2 for a number that it in [1,2)\n    @dev _x is FP, return a FP\n    @dev function is from Kyber. Long modified the condition to be (_x >= one) && (_x < two)\n    to avoid the case where x = 2 may lead to incorrect result\n     */\n    function log2ForSmallNumber(uint256 _x) internal pure returns (uint256) {\n        uint256 res = 0;\n        uint256 one = (uint256(1) << PRECISION_BITS);\n        uint256 two = 2 * one;\n        uint256 addition = one;\n        require((_x >= one) && (_x < two), \"MATH_ERROR\");\n        require(PRECISION_BITS < 125, \"MATH_ERROR\");\n        for (uint256 i = PRECISION_BITS; i > 0; i--) {\n            _x = (_x * _x) / one;\n            addition = addition / 2;\n            if (_x >= two) {\n                _x = _x / 2;\n                res += addition;\n            }\n        }\n        return res;\n    }\n    /**\n    @notice log2 of (p/q). returns result in FP form\n    @dev function is from Kyber.\n    @dev _p & _q is FP, return a FP\n     */\n    function logBase2(uint256 _p, uint256 _q) internal pure returns (uint256) {\n        uint256 n = 0;\n        if (_p > _q) {\n            n = log2Int(_p, _q);\n        }\n        require(n * RONE <= BIG_NUMBER, \"MATH_ERROR\");\n        require(!checkMultOverflow(_p, RONE), \"MATH_ERROR\");\n        require(!checkMultOverflow(n, RONE), \"MATH_ERROR\");\n        require(!checkMultOverflow(uint256(1) << n, _q), \"MATH_ERROR\");\n        uint256 y = (_p * RONE) / (_q * (uint256(1) << n));\n        uint256 log2Small = log2ForSmallNumber(y);\n        assert(log2Small <= BIG_NUMBER);\n        return n * RONE + log2Small;\n    }\n    /**\n    @notice calculate ln(p/q). returned result >= 0\n    @dev function is from Kyber.\n    @dev _p & _q is FP, return a FP\n    */\n    function ln(uint256 p, uint256 q) internal pure returns (uint256) {\n        uint256 ln2Numerator = 6931471805599453094172;\n        uint256 ln2Denomerator = 10000000000000000000000;\n        uint256 log2x = logBase2(p, q);\n        require(!checkMultOverflow(ln2Numerator, log2x), \"MATH_ERROR\");\n        return (ln2Numerator * log2x) / ln2Denomerator;\n    }\n    /**\n    @notice extract the fractional part of a FP\n    @dev value is a FP, return a FP\n     */\n    function fpart(uint256 value) internal pure returns (uint256) {\n        return value % RONE;\n    }\n    /**\n    @notice convert a FP to an Int\n    @dev value is a FP, return an Int\n     */\n    function toInt(uint256 value) internal pure returns (uint256) {\n        return value / RONE;\n    }\n    /**\n    @notice convert an Int to a FP\n    @dev value is an Int, return a FP\n     */\n    function toFP(uint256 value) internal pure returns (uint256) {\n        return value * RONE;\n    }\n    /**\n    @notice return e^exp in FP form\n    @dev estimation by formula at http://pages.mtu.edu/~shene/COURSES/cs201/NOTES/chap04/exp.html\n        the function is based on exp function of:\n        https://github.com/NovakDistributed/macroverse/blob/master/contracts/RealMath.sol\n    @dev the function is expected to converge quite fast, after about 20 iteration\n    @dev exp is a FP, return a FP\n     */\n    function rpowe(uint256 exp) internal pure returns (uint256) {\n        uint256 res = 0;\n        uint256 curTerm = RONE;\n        /* no limit on n. If the function cannot converge, it will lead to out of gas*/\n        for (uint256 n = 0; ; n++) {\n            res += curTerm;\n            curTerm = rmul(curTerm, rdiv(exp, toFP(n + 1)));\n            if (curTerm == 0) {\n                break;\n            }\n            if (n == 500) {\n                /*\n                testing shows that in the most extreme case, it will take 430 turns to converge.\n                however, it's expected that the numbers will not exceed 2^120 in normal situation\n                the most extreme case is rpow((1<<256)-1,(1<<40)-1) (equal to rpow((2^256-1)/2^40,0.99..9))\n                */\n                revert(\"RPOWE_SLOW_CONVERGE\");\n            }\n        }\n        return res;\n    }\n    /**\n    @notice calculate base^exp with base and exp being FP int\n    @dev to improve accuracy, base^exp = base^(int(exp)+frac(exp))\n                                       = base^int(exp) * base^frac\n    @dev base & exp are FP, return a FP\n     */\n    function rpow(uint256 base, uint256 exp) internal pure returns (uint256) {\n        if (exp == 0) {\n            // Anything to the 0 is 1\n            return RONE;\n        }\n        if (base == 0) {\n            // 0 to anything except 0 is 0\n            return 0;\n        }\n        uint256 frac = fpart(exp); // get the fractional part\n        uint256 whole = exp - frac;\n        uint256 wholePow = rpowi(base, toInt(whole)); // whole is a FP, convert to Int\n        uint256 fracPow;\n        // instead of calculating base ^ frac, we will calculate e ^ (frac*ln(base))\n        if (base < RONE) {\n            /* since the base is smaller than 1.0, ln(base) < 0.\n            Since 1 / (e^(frac*ln(1/base))) = e ^ (frac*ln(base)),\n            we will calculate 1 / (e^(frac*ln(1/base))) instead.\n            */\n            uint256 newExp = rmul(frac, ln(rdiv(RONE, base), RONE));\n            fracPow = rdiv(RONE, rpowe(newExp));\n        } else {\n            /* base is greater than 1, calculate normally */\n            uint256 newExp = rmul(frac, ln(base, RONE));\n            fracPow = rpowe(newExp);\n        }\n        return rmul(wholePow, fracPow);\n    }\n    /**\n    @notice return base^exp with base in FP form and exp in Int\n    @dev this function use a technique called: exponentiating by squaring\n        complexity O(log(q))\n    @dev function is from Kyber.\n    @dev base is a FP, exp is an Int, return a FP\n     */\n    function rpowi(uint256 base, uint256 exp) internal pure returns (uint256) {\n        uint256 res = exp % 2 != 0 ? base : RONE;\n        for (exp /= 2; exp != 0; exp /= 2) {\n            base = rmul(base, base);\n            if (exp % 2 != 0) {\n                res = rmul(res, base);\n            }\n        }\n        return res;\n    }\n    /**\n    @dev y is an Int, returns an Int\n    @dev babylonian method (https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method)\n    @dev from Uniswap\n     */\n    function sqrt(uint256 y) internal pure returns (uint256 z) {\n        if (y > 3) {\n            z = y;\n            uint256 x = y / 2 + 1;\n            while (x < z) {\n                z = x;\n                x = (y / x + x) / 2;\n            }\n        } else if (y != 0) {\n            z = 1;\n        }\n    }\n    /**\n    @notice divide 2 FP, return a FP\n    @dev function is from Balancer.\n    @dev x & y are FP, return a FP\n     */\n    function rdiv(uint256 x, uint256 y) internal pure returns (uint256) {\n        return (y / 2).add(x.mul(RONE)).div(y);\n    }\n    /**\n    @notice multiply 2 FP, return a FP\n    @dev function is from Balancer.\n    @dev x & y are FP, return a FP\n     */\n    function rmul(uint256 x, uint256 y) internal pure returns (uint256) {\n        return (RONE / 2).add(x.mul(y)).div(RONE);\n    }\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a >= b ? a : b;\n    }\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    function subMax0(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a >= b ? a - b : 0;\n    }\n}"
    },
    {
        "tag": "arithmetic",
        "url": "https://github.com/makerdao/univ2-lp-oracle/commit/d514dc3c6ca4f0be89678525a0d22171612e5b77",
        "file": "src/UNIV2LPOracle.sol",
        "before": "// SPDX-License-Identifier: GPL-3.0-or-later\n/// UNIV2LPOracle.sol\n// Copyright (C) 2017-2020 Maker Ecosystem Growth Holdings, INC.\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\n///////////////////////////////////////////////////////\n//                                                   //\n//    Methodology for Calculating LP Token Price     //\n//                                                   //\n///////////////////////////////////////////////////////\n// Two-asset constant product pools, neglecting fees, satisfy (before and after trades):\n//\n// r_0 * r_1 = k                (1)\n//\n// where r_0 and r_1 are the reserves of the two tokens held by the pool.\n// The price of LP tokens (i.e. pool shares) needs to be evaluated based on \n// reserve values r_0 and r_1 that cannot be arbitraged, i.e. values that\n// give the two halves of the pool equal economic value:\n//\n// r_0 * p_0 = r_1 * p_1        (2)\n// \n// (p_i is the price of pool asset i in some reference unit of account).\n// Using (1) and (2) we can compute the arbitrage-free reserve values in a manner\n// that depends only on k (which can be derived from the current reserve balances,\n// even if they are far from equilibrium) and market prices p_i obtained from a trusted source:\n//\n// r_0 = sqrt(k * p_1 / p_0)    (3)\n//   and\n// r_1 = sqrt(k * p_0 / p_1)    (4)\n//\n// The value of an LP token is then, combining (3) and (4):\n//\n// (p_0 * r_0 + p_1 * r_1) / LP_supply = 2 * sqrt(k * p_0 * p_1) / LP_supply\npragma solidity =0.6.12;\ninterface ERC20Like {\n    function decimals()         external view returns (uint8);\n    function balanceOf(address) external view returns (uint256);\n    function totalSupply()      external view returns (uint256);\n}\ninterface UniswapV2PairLike {\n    function sync()        external;\n    function token0()      external view returns (address);\n    function token1()      external view returns (address);\n    function getReserves() external view returns (uint112,uint112,uint32);  // reserve0, reserve1, blockTimestampLast\n}\ninterface OracleLike {\n    function read() external view returns (uint256);\n}\n// Factory for creating Uniswap V2 LP Token Oracle instances\ncontract UNIV2LPOracleFactory {\n    mapping(address => bool) public isOracle;\n    event NewUNIV2LPOracle(address sender, address orcl, bytes32 wat, address indexed tok0, address indexed tok1, address orb0, address orb1);\n    // Create new Uniswap V2 LP Token Oracle instance\n    function build(address _src, bytes32 _wat, address _orb0, address _orb1) public returns (address orcl) {\n        address tok0 = UniswapV2PairLike(_src).token0();\n        address tok1 = UniswapV2PairLike(_src).token1();\n        orcl = address(new UNIV2LPOracle(_src, _wat, _orb0, _orb1));\n        UNIV2LPOracle(orcl).rely(msg.sender);\n        isOracle[orcl] = true;\n        emit NewUNIV2LPOracle(msg.sender, orcl, _wat, tok0, tok1, _orb0, _orb1);\n    }\n}\ncontract UNIV2LPOracle {\n    // --- Auth ---\n    mapping (address => uint) public wards;                                       // Addresses with admin authority\n    function rely(address usr) external auth { wards[usr] = 1; emit Rely(usr); }  // Add admin\n    function deny(address usr) external auth { wards[usr] = 0; emit Deny(usr); }  // Remove admin\n    modifier auth {\n        require(wards[msg.sender] == 1, \"UNIV2LPOracle/not-authorized\");\n        _;\n    }\n    address public immutable src;   // Price source\n    uint16  public hop = 1 hours;   // Minimum time inbetween price updates\n    uint64  public zzz;             // Time of last price update\n    bytes32 public immutable wat;   // Label of token whose price is being tracked\n    // --- Whitelisting ---\n    mapping (address => uint256) public bud;\n    modifier toll { require(bud[msg.sender] == 1, \"UNIV2LPOracle/contract-not-whitelisted\"); _; }\n    struct Feed {\n        uint128 val;  // Price\n        uint128 has;  // Is price valid\n    }\n    Feed    internal cur;  // Current price  (mem slot 0x3)\n    Feed    internal nxt;  // Queued price   (mem slot 0x4)\n    // --- Stop ---\n    uint256 public stopped;  // Stop/start ability to read\n    modifier stoppable { require(stopped == 0, \"UNIV2LPOracle/is-stopped\"); _; }\n    // --- Data ---\n    uint256 private immutable normalizer;  // Multiplicative factor that normalizes a token pair balance product to WAD^2; 10^(36 - dec0 - dec1)\n    address public            orb0;  // Oracle for token0, ideally a Medianizer\n    address public            orb1;  // Oracle for token1, ideally a Medianizer\n    // --- Math ---\n    uint256 constant WAD = 10 ** 18;\n    function add(uint x, uint y) internal pure returns (uint z) {\n        require((z = x + y) >= x, \"ds-math-add-overflow\");\n    }\n    function sub(uint x, uint y) internal pure returns (uint z) {\n        require((z = x - y) <= x, \"ds-math-sub-underflow\");\n    }\n    function mul(uint x, uint y) internal pure returns (uint z) {\n        require(y == 0 || (z = x * y) / y == x, \"ds-math-mul-overflow\");\n    }\n    function wmul(uint x, uint y) internal pure returns (uint z) {\n        z = add(mul(x, y), WAD / 2) / WAD;\n    }\n    function wdiv(uint x, uint y) internal pure returns (uint z) {\n        z = add(mul(x, WAD), y / 2) / y;\n    }\n    // FROM https://github.com/abdk-consulting/abdk-libraries-solidity/blob/16d7e1dd8628dfa2f88d5dadab731df7ada70bdd/ABDKMath64x64.sol#L687\n    function sqrt (uint256 x) private pure returns (uint128) {\n        if (x == 0) return 0;\n        else {\n            uint256 xx = x;\n            uint256 r = 1;\n            if (xx >= 0x100000000000000000000000000000000) { xx >>= 128; r <<= 64; }\n            if (xx >= 0x10000000000000000) { xx >>= 64; r <<= 32; }\n            if (xx >= 0x100000000) { xx >>= 32; r <<= 16; }\n            if (xx >= 0x10000) { xx >>= 16; r <<= 8; }\n            if (xx >= 0x100) { xx >>= 8; r <<= 4; }\n            if (xx >= 0x10) { xx >>= 4; r <<= 2; }\n            if (xx >= 0x8) { r <<= 1; }\n            r = (r + x / r) >> 1;\n            r = (r + x / r) >> 1;\n            r = (r + x / r) >> 1;\n            r = (r + x / r) >> 1;\n            r = (r + x / r) >> 1;\n            r = (r + x / r) >> 1;\n            r = (r + x / r) >> 1; // Seven iterations should be enough\n            uint256 r1 = x / r;\n            return uint128 (r < r1 ? r : r1);\n        }\n    }\n    // --- Events ---\n    event Rely(address indexed usr);\n    event Deny(address indexed usr);\n    event Step(uint256 hop);\n    event Stop();\n    event Start();\n    event Value(uint128 curVal, uint128 nxtVal);\n    event Link(uint256 id, address orb);\n    event Kiss(address a);\n    event Diss(address a);\n    // --- Init ---\n    constructor (address _src, bytes32 _wat, address _orb0, address _orb1) public {\n        require(_src  != address(0),                        \"UNIV2LPOracle/invalid-src-address\");\n        require(_orb0 != address(0) && _orb1 != address(0), \"UNIV2LPOracle/invalid-oracle-address\");\n        wards[msg.sender] = 1;\n        emit Rely(msg.sender);\n        src  = _src;\n        wat  = _wat;\n        uint256 dec0 = uint256(ERC20Like(UniswapV2PairLike(_src).token0()).decimals());\n        require(dec0 <= 18, \"UNIV2LPOracle/token0-dec-gt-18\");\n        uint256 dec1 = uint256(ERC20Like(UniswapV2PairLike(_src).token1()).decimals());\n        require(dec1 <= 18, \"UNIV2LPOracle/token1-dec-gt-18\");\n        normalizer = mul(10 ** (18 - dec1), 10 ** (18 - dec0));  // Calculate normalization factor of token1\n        orb0 = _orb0;\n        orb1 = _orb1;\n    }\n    function stop() external auth {\n        stopped = 1;\n        delete cur;\n        delete nxt;\n        zzz = 0;\n        emit Stop();\n    }\n    function start() external auth {\n        stopped = 0;\n        emit Start();\n    }\n    function step(uint256 _hop) external auth {\n        require(_hop <= uint16(-1), \"UNIV2LPOracle/invalid-hop\");\n        hop = uint16(_hop);\n        emit Step(hop);\n    }\n    function link(uint256 id, address orb) external auth {\n        require(orb != address(0), \"UNIV2LPOracle/no-contract-0\");\n        if(id == 0) {\n            orb0 = orb;\n        } else if (id == 1) {\n            orb1 = orb;\n        } else {\n            revert(\"UNIV2LPOracle/invalid-id\");\n        }\n        emit Link(id, orb);\n    }\n    function pass() public view returns (bool ok) {\n        return block.timestamp >= add(zzz, hop);\n    }\n    function seek() internal returns (uint128 quote) {\n        // Sync up reserves of uniswap liquidity pool\n        UniswapV2PairLike(src).sync();\n        // Get reserves of uniswap liquidity pool\n        (uint112 res0, uint112 res1, uint32 ts) = UniswapV2PairLike(src).getReserves();\n        require(res0 > 0 && res1 > 0, \"UNIV2LPOracle/invalid-reserves\");\n        require(ts == block.timestamp);\n        // Calculate constant product invariant k (WAD * WAD)\n        // Explicitly cast reserves to uint256\n        uint256 k = mul(normalizer, mul(uint256(res0), uint256(res1)));\n        // All Oracle prices are priced with 18 decimals against USD\n        uint256 val0 = OracleLike(orb0).read();  // Query token0 price from oracle (WAD)\n        uint256 val1 = OracleLike(orb1).read();  // Query token1 price from oracle (WAD)\n        require(val0 != 0, \"UNIV2LPOracle/invalid-oracle-0-price\");\n        require(val1 != 0, \"UNIV2LPOracle/invalid-oracle-1-price\");\n        // Get LP token supply\n        uint256 supply = ERC20Like(src).totalSupply();\n\n        // No need to check that the supply is nonzero, Solidity reverts on division by zero.\n        quote = uint128(\n                mul(2 * WAD, sqrt(wmul(k, wmul(val0, val1))))\n                    / supply\n        );\n    }\n\n    function poke() external stoppable {\n\n    \n          \n            \n    \n\n          \n          Expand Down\n    \n    \n  \n        require(pass(), \"UNIV2LPOracle/not-passed\");\n        uint128 val = seek();\n        require(val != 0, \"UNIV2LPOracle/invalid-price\");\n        cur = nxt;\n        nxt = Feed(val, 1);\n        zzz = uint64(block.timestamp);\n        emit Value(cur.val, nxt.val);\n    }\n    function peek() external view toll returns (bytes32,bool) {\n        return (bytes32(uint(cur.val)), cur.has == 1);\n    }\n    function peep() external view toll returns (bytes32,bool) {\n        return (bytes32(uint(nxt.val)), nxt.has == 1);\n    }\n    function read() external view toll returns (bytes32) {\n        require(cur.has == 1, \"UNIV2LPOracle/no-current-value\");\n        return (bytes32(uint(cur.val)));\n    }\n    function kiss(address a) external auth {\n        require(a != address(0), \"UNIV2LPOracle/no-contract-0\");\n        bud[a] = 1;\n        emit Kiss(a);\n    }\n    function kiss(address[] calldata a) external auth {\n        for(uint i = 0; i < a.length; i++) {\n            require(a[i] != address(0), \"UNIV2LPOracle/no-contract-0\");\n            bud[a[i]] = 1;\n            emit Kiss(a[i]);\n        }\n    }\n    function diss(address a) external auth {\n        bud[a] = 0;\n        emit Diss(a);\n    }\n    function diss(address[] calldata a) external auth {\n        for(uint i = 0; i < a.length; i++) {\n            bud[a[i]] = 0;\n            emit Diss(a[i]);\n        }\n    }\n}",
        "after": "// SPDX-License-Identifier: GPL-3.0-or-later\n/// UNIV2LPOracle.sol\n// Copyright (C) 2017-2020 Maker Ecosystem Growth Holdings, INC.\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\n///////////////////////////////////////////////////////\n//                                                   //\n//    Methodology for Calculating LP Token Price     //\n//                                                   //\n///////////////////////////////////////////////////////\n// Two-asset constant product pools, neglecting fees, satisfy (before and after trades):\n//\n// r_0 * r_1 = k                (1)\n//\n// where r_0 and r_1 are the reserves of the two tokens held by the pool.\n// The price of LP tokens (i.e. pool shares) needs to be evaluated based on \n// reserve values r_0 and r_1 that cannot be arbitraged, i.e. values that\n// give the two halves of the pool equal economic value:\n//\n// r_0 * p_0 = r_1 * p_1        (2)\n// \n// (p_i is the price of pool asset i in some reference unit of account).\n// Using (1) and (2) we can compute the arbitrage-free reserve values in a manner\n// that depends only on k (which can be derived from the current reserve balances,\n// even if they are far from equilibrium) and market prices p_i obtained from a trusted source:\n//\n// r_0 = sqrt(k * p_1 / p_0)    (3)\n//   and\n// r_1 = sqrt(k * p_0 / p_1)    (4)\n//\n// The value of an LP token is then, combining (3) and (4):\n//\n// (p_0 * r_0 + p_1 * r_1) / LP_supply = 2 * sqrt(k * p_0 * p_1) / LP_supply\npragma solidity =0.6.12;\ninterface ERC20Like {\n    function decimals()         external view returns (uint8);\n    function balanceOf(address) external view returns (uint256);\n    function totalSupply()      external view returns (uint256);\n}\ninterface UniswapV2PairLike {\n    function sync()        external;\n    function token0()      external view returns (address);\n    function token1()      external view returns (address);\n    function getReserves() external view returns (uint112,uint112,uint32);  // reserve0, reserve1, blockTimestampLast\n}\ninterface OracleLike {\n    function read() external view returns (uint256);\n}\n// Factory for creating Uniswap V2 LP Token Oracle instances\ncontract UNIV2LPOracleFactory {\n    mapping(address => bool) public isOracle;\n    event NewUNIV2LPOracle(address sender, address orcl, bytes32 wat, address indexed tok0, address indexed tok1, address orb0, address orb1);\n    // Create new Uniswap V2 LP Token Oracle instance\n    function build(address _src, bytes32 _wat, address _orb0, address _orb1) public returns (address orcl) {\n        address tok0 = UniswapV2PairLike(_src).token0();\n        address tok1 = UniswapV2PairLike(_src).token1();\n        orcl = address(new UNIV2LPOracle(_src, _wat, _orb0, _orb1));\n        UNIV2LPOracle(orcl).rely(msg.sender);\n        isOracle[orcl] = true;\n        emit NewUNIV2LPOracle(msg.sender, orcl, _wat, tok0, tok1, _orb0, _orb1);\n    }\n}\ncontract UNIV2LPOracle {\n    // --- Auth ---\n    mapping (address => uint) public wards;                                       // Addresses with admin authority\n    function rely(address usr) external auth { wards[usr] = 1; emit Rely(usr); }  // Add admin\n    function deny(address usr) external auth { wards[usr] = 0; emit Deny(usr); }  // Remove admin\n    modifier auth {\n        require(wards[msg.sender] == 1, \"UNIV2LPOracle/not-authorized\");\n        _;\n    }\n    address public immutable src;   // Price source\n    uint16  public hop = 1 hours;   // Minimum time inbetween price updates\n    uint64  public zzz;             // Time of last price update\n    bytes32 public immutable wat;   // Label of token whose price is being tracked\n    // --- Whitelisting ---\n    mapping (address => uint256) public bud;\n    modifier toll { require(bud[msg.sender] == 1, \"UNIV2LPOracle/contract-not-whitelisted\"); _; }\n    struct Feed {\n        uint128 val;  // Price\n        uint128 has;  // Is price valid\n    }\n    Feed    internal cur;  // Current price  (mem slot 0x3)\n    Feed    internal nxt;  // Queued price   (mem slot 0x4)\n    // --- Stop ---\n    uint256 public stopped;  // Stop/start ability to read\n    modifier stoppable { require(stopped == 0, \"UNIV2LPOracle/is-stopped\"); _; }\n    // --- Data ---\n    uint256 private immutable normalizer;  // Multiplicative factor that normalizes a token pair balance product to WAD^2; 10^(36 - dec0 - dec1)\n    address public            orb0;  // Oracle for token0, ideally a Medianizer\n    address public            orb1;  // Oracle for token1, ideally a Medianizer\n    // --- Math ---\n    uint256 constant WAD = 10 ** 18;\n    function add(uint x, uint y) internal pure returns (uint z) {\n        require((z = x + y) >= x, \"ds-math-add-overflow\");\n    }\n    function sub(uint x, uint y) internal pure returns (uint z) {\n        require((z = x - y) <= x, \"ds-math-sub-underflow\");\n    }\n    function mul(uint x, uint y) internal pure returns (uint z) {\n        require(y == 0 || (z = x * y) / y == x, \"ds-math-mul-overflow\");\n    }\n    function wmul(uint x, uint y) internal pure returns (uint z) {\n        z = add(mul(x, y), WAD / 2) / WAD;\n    }\n    function wdiv(uint x, uint y) internal pure returns (uint z) {\n        z = add(mul(x, WAD), y / 2) / y;\n    }\n    // FROM https://github.com/abdk-consulting/abdk-libraries-solidity/blob/16d7e1dd8628dfa2f88d5dadab731df7ada70bdd/ABDKMath64x64.sol#L687\n    function sqrt (uint256 x) private pure returns (uint128) {\n        if (x == 0) return 0;\n        else {\n            uint256 xx = x;\n            uint256 r = 1;\n            if (xx >= 0x100000000000000000000000000000000) { xx >>= 128; r <<= 64; }\n            if (xx >= 0x10000000000000000) { xx >>= 64; r <<= 32; }\n            if (xx >= 0x100000000) { xx >>= 32; r <<= 16; }\n            if (xx >= 0x10000) { xx >>= 16; r <<= 8; }\n            if (xx >= 0x100) { xx >>= 8; r <<= 4; }\n            if (xx >= 0x10) { xx >>= 4; r <<= 2; }\n            if (xx >= 0x8) { r <<= 1; }\n            r = (r + x / r) >> 1;\n            r = (r + x / r) >> 1;\n            r = (r + x / r) >> 1;\n            r = (r + x / r) >> 1;\n            r = (r + x / r) >> 1;\n            r = (r + x / r) >> 1;\n            r = (r + x / r) >> 1; // Seven iterations should be enough\n            uint256 r1 = x / r;\n            return uint128 (r < r1 ? r : r1);\n        }\n    }\n    // --- Events ---\n    event Rely(address indexed usr);\n    event Deny(address indexed usr);\n    event Step(uint256 hop);\n    event Stop();\n    event Start();\n    event Value(uint128 curVal, uint128 nxtVal);\n    event Link(uint256 id, address orb);\n    event Kiss(address a);\n    event Diss(address a);\n    // --- Init ---\n    constructor (address _src, bytes32 _wat, address _orb0, address _orb1) public {\n        require(_src  != address(0),                        \"UNIV2LPOracle/invalid-src-address\");\n        require(_orb0 != address(0) && _orb1 != address(0), \"UNIV2LPOracle/invalid-oracle-address\");\n        wards[msg.sender] = 1;\n        emit Rely(msg.sender);\n        src  = _src;\n        wat  = _wat;\n        uint256 dec0 = uint256(ERC20Like(UniswapV2PairLike(_src).token0()).decimals());\n        require(dec0 <= 18, \"UNIV2LPOracle/token0-dec-gt-18\");\n        uint256 dec1 = uint256(ERC20Like(UniswapV2PairLike(_src).token1()).decimals());\n        require(dec1 <= 18, \"UNIV2LPOracle/token1-dec-gt-18\");\n        normalizer = mul(10 ** (18 - dec1), 10 ** (18 - dec0));  // Calculate normalization factor of token1\n        orb0 = _orb0;\n        orb1 = _orb1;\n    }\n    function stop() external auth {\n        stopped = 1;\n        delete cur;\n        delete nxt;\n        zzz = 0;\n        emit Stop();\n    }\n    function start() external auth {\n        stopped = 0;\n        emit Start();\n    }\n    function step(uint256 _hop) external auth {\n        require(_hop <= uint16(-1), \"UNIV2LPOracle/invalid-hop\");\n        hop = uint16(_hop);\n        emit Step(hop);\n    }\n    function link(uint256 id, address orb) external auth {\n        require(orb != address(0), \"UNIV2LPOracle/no-contract-0\");\n        if(id == 0) {\n            orb0 = orb;\n        } else if (id == 1) {\n            orb1 = orb;\n        } else {\n            revert(\"UNIV2LPOracle/invalid-id\");\n        }\n        emit Link(id, orb);\n    }\n    function pass() public view returns (bool ok) {\n        return block.timestamp >= add(zzz, hop);\n    }\n    function seek() internal returns (uint128 quote) {\n        // Sync up reserves of uniswap liquidity pool\n        UniswapV2PairLike(src).sync();\n        // Get reserves of uniswap liquidity pool\n        (uint112 res0, uint112 res1, uint32 ts) = UniswapV2PairLike(src).getReserves();\n        require(res0 > 0 && res1 > 0, \"UNIV2LPOracle/invalid-reserves\");\n        require(ts == block.timestamp);\n        // Calculate constant product invariant k (WAD * WAD)\n        // Explicitly cast reserves to uint256\n        uint256 k = mul(normalizer, mul(uint256(res0), uint256(res1)));\n        // All Oracle prices are priced with 18 decimals against USD\n        uint256 val0 = OracleLike(orb0).read();  // Query token0 price from oracle (WAD)\n        uint256 val1 = OracleLike(orb1).read();  // Query token1 price from oracle (WAD)\n        require(val0 != 0, \"UNIV2LPOracle/invalid-oracle-0-price\");\n        require(val1 != 0, \"UNIV2LPOracle/invalid-oracle-1-price\");\n        // Get LP token supply\n        uint256 supply = ERC20Like(src).totalSupply();\n\n        // No need to check that the supply is nonzero, Solidity reverts on division by zero.\n        uint256 preq = mul(2 * WAD, sqrt(wmul(k, wmul(val0, val1)))) / supply;\n\n        require(preq < 2 ** 128, \"UNIV2LPOracle/quote-overflow\");\n        quote = uint128(preq);\n    }\n\n    function poke() external stoppable {\n\n    \n          \n            \n    \n\n          \n          Expand Down\n    \n    \n  \n        require(pass(), \"UNIV2LPOracle/not-passed\");\n        uint128 val = seek();\n        require(val != 0, \"UNIV2LPOracle/invalid-price\");\n        cur = nxt;\n        nxt = Feed(val, 1);\n        zzz = uint64(block.timestamp);\n        emit Value(cur.val, nxt.val);\n    }\n    function peek() external view toll returns (bytes32,bool) {\n        return (bytes32(uint(cur.val)), cur.has == 1);\n    }\n    function peep() external view toll returns (bytes32,bool) {\n        return (bytes32(uint(nxt.val)), nxt.has == 1);\n    }\n    function read() external view toll returns (bytes32) {\n        require(cur.has == 1, \"UNIV2LPOracle/no-current-value\");\n        return (bytes32(uint(cur.val)));\n    }\n    function kiss(address a) external auth {\n        require(a != address(0), \"UNIV2LPOracle/no-contract-0\");\n        bud[a] = 1;\n        emit Kiss(a);\n    }\n    function kiss(address[] calldata a) external auth {\n        for(uint i = 0; i < a.length; i++) {\n            require(a[i] != address(0), \"UNIV2LPOracle/no-contract-0\");\n            bud[a[i]] = 1;\n            emit Kiss(a[i]);\n        }\n    }\n    function diss(address a) external auth {\n        bud[a] = 0;\n        emit Diss(a);\n    }\n    function diss(address[] calldata a) external auth {\n        for(uint i = 0; i < a.length; i++) {\n            bud[a[i]] = 0;\n            emit Diss(a[i]);\n        }\n    }\n}"
    },
    {
        "tag": "short addresses attack",
        "url": "https://github.com/tatumio/smart-contracts/commit/d9b9ed227b175262234fac0f5bd47e19f9556a9c",
        "file": "contracts/token/BasicToken.sol",
        "before": "pragma solidity ^0.4.8;\n\n\nimport './ERC20Basic.sol';\nimport '../SafeMath.sol';\n\n\n/*\n * Basic token\n * Basic version of StandardToken, with no allowances\n */\ncontract BasicToken is ERC20Basic, SafeMath {\n\n  mapping(address => uint) balances;\n\n  function transfer(address _to, uint _value) {\n    balances[msg.sender] = safeSub(balances[msg.sender], _value);\n    balances[_to] = safeAdd(balances[_to], _value);\n    Transfer(msg.sender, _to, _value);\n  }\n\n  function balanceOf(address _owner) constant returns (uint balance) {\n    return balances[_owner];\n  }\n\n}",
        "after": "\npragma solidity ^0.4.8;\n\n\nimport './ERC20Basic.sol';\nimport '../SafeMath.sol';\n\n\n/*\n * Basic token\n * Basic version of StandardToken, with no allowances\n */\ncontract BasicToken is ERC20Basic, SafeMath {\n\n  mapping(address => uint) balances;\n\n/*\n * Fix for the ERC20 short address attack  \n */\n  modifier onlyPayloadSize(uint size) {\n     assert(msg.data.length == size + 4);\n     _;\n  }\n  function transfer(address _to, uint _value) onlyPayloadSize(2 * 32) {\n    balances[msg.sender] = safeSub(balances[msg.sender], _value);\n    balances[_to] = safeAdd(balances[_to], _value);\n    Transfer(msg.sender, _to, _value);\n  }\n\n  function balanceOf(address _owner) constant returns (uint balance) {\n    return balances[_owner];\n  }\n\n}"
    },
    {
        "tag": "reentrancy",
        "url": "https://github.com/tatumio/smart-contracts/commit/3b4c951838ddf82f4d2b44ae7c967f0573039f28",
        "file": "contracts/token/ERC777/ERC777.sol",
        "before": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.0 <0.8.0;\nimport \"../../utils/Context.sol\";\nimport \"./IERC777.sol\";\nimport \"./IERC777Recipient.sol\";\nimport \"./IERC777Sender.sol\";\nimport \"../../token/ERC20/IERC20.sol\";\nimport \"../../math/SafeMath.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../introspection/IERC1820Registry.sol\";\n/**\n * @dev Implementation of the {IERC777} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n *\n * Support for ERC20 is included in this contract, as specified by the EIP: both\n * the ERC777 and ERC20 interfaces can be safely used when interacting with it.\n * Both {IERC777-Sent} and {IERC20-Transfer} events are emitted on token\n * movements.\n *\n * Additionally, the {IERC777-granularity} value is hard-coded to `1`, meaning that there\n * are no special restrictions in the amount of tokens that created, moved, or\n * destroyed. This makes integration with ERC20 applications seamless.\n */\ncontract ERC777 is Context, IERC777, IERC20 {\n    using SafeMath for uint256;\n    using Address for address;\n    IERC1820Registry constant internal _ERC1820_REGISTRY = IERC1820Registry(0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24);\n    mapping(address => uint256) private _balances;\n    uint256 private _totalSupply;\n    string private _name;\n    string private _symbol;\n    // We inline the result of the following hashes because Solidity doesn't resolve them at compile time.\n    // See https://github.com/ethereum/solidity/issues/4024.\n    // keccak256(\"ERC777TokensSender\")\n    bytes32 constant private _TOKENS_SENDER_INTERFACE_HASH =\n        0x29ddb589b1fb5fc7cf394961c1adf5f8c6454761adf795e67fe149f658abe895;\n    // keccak256(\"ERC777TokensRecipient\")\n    bytes32 constant private _TOKENS_RECIPIENT_INTERFACE_HASH =\n        0xb281fc8c12954d22544db45de3159a39272895b169a852b314f9cc762e44c53b;\n    // This isn't ever read from - it's only used to respond to the defaultOperators query.\n    address[] private _defaultOperatorsArray;\n    // Immutable, but accounts may revoke them (tracked in __revokedDefaultOperators).\n    mapping(address => bool) private _defaultOperators;\n    // For each account, a mapping of its operators and revoked default operators.\n    mapping(address => mapping(address => bool)) private _operators;\n    mapping(address => mapping(address => bool)) private _revokedDefaultOperators;\n    // ERC20-allowances\n    mapping (address => mapping (address => uint256)) private _allowances;\n    /**\n     * @dev `defaultOperators` may be an empty array.\n     */\n    constructor(\n        string memory name_,\n        string memory symbol_,\n        address[] memory defaultOperators_\n    )\n        public\n    {\n        _name = name_;\n        _symbol = symbol_;\n        _defaultOperatorsArray = defaultOperators_;\n        for (uint256 i = 0; i < _defaultOperatorsArray.length; i++) {\n            _defaultOperators[_defaultOperatorsArray[i]] = true;\n        }\n        // register interfaces\n        _ERC1820_REGISTRY.setInterfaceImplementer(address(this), keccak256(\"ERC777Token\"), address(this));\n        _ERC1820_REGISTRY.setInterfaceImplementer(address(this), keccak256(\"ERC20Token\"), address(this));\n    }\n    /**\n     * @dev See {IERC777-name}.\n     */\n    function name() public view override returns (string memory) {\n        return _name;\n    }\n    /**\n     * @dev See {IERC777-symbol}.\n     */\n    function symbol() public view override returns (string memory) {\n        return _symbol;\n    }\n    /**\n     * @dev See {ERC20-decimals}.\n     *\n     * Always returns 18, as per the\n     * [ERC777 EIP](https://eips.ethereum.org/EIPS/eip-777#backward-compatibility).\n     */\n    function decimals() public pure returns (uint8) {\n        return 18;\n    }\n    /**\n     * @dev See {IERC777-granularity}.\n     *\n     * This implementation always returns `1`.\n     */\n    function granularity() public view override returns (uint256) {\n        return 1;\n    }\n    /**\n     * @dev See {IERC777-totalSupply}.\n     */\n    function totalSupply() public view override(IERC20, IERC777) returns (uint256) {\n        return _totalSupply;\n    }\n    /**\n     * @dev Returns the amount of tokens owned by an account (`tokenHolder`).\n     */\n    function balanceOf(address tokenHolder) public view override(IERC20, IERC777) returns (uint256) {\n        return _balances[tokenHolder];\n    }\n    /**\n     * @dev See {IERC777-send}.\n     *\n     * Also emits a {IERC20-Transfer} event for ERC20 compatibility.\n     */\n    function send(address recipient, uint256 amount, bytes memory data) public virtual override  {\n        _send(_msgSender(), recipient, amount, data, \"\", true);\n    }\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Unlike `send`, `recipient` is _not_ required to implement the {IERC777Recipient}\n     * interface if it is a contract.\n     *\n     * Also emits a {Sent} event.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        require(recipient != address(0), \"ERC777: transfer to the zero address\");\n        address from = _msgSender();\n        _callTokensToSend(from, from, recipient, amount, \"\", \"\");\n        _move(from, from, recipient, amount, \"\", \"\");\n        _callTokensReceived(from, from, recipient, amount, \"\", \"\", false);\n        return true;\n    }\n    /**\n     * @dev See {IERC777-burn}.\n     *\n     * Also emits a {IERC20-Transfer} event for ERC20 compatibility.\n     */\n    function burn(uint256 amount, bytes memory data) public virtual override  {\n        _burn(_msgSender(), amount, data, \"\");\n    }\n    /**\n     * @dev See {IERC777-isOperatorFor}.\n     */\n    function isOperatorFor(address operator, address tokenHolder) public view override returns (bool) {\n        return operator == tokenHolder ||\n            (_defaultOperators[operator] && !_revokedDefaultOperators[tokenHolder][operator]) ||\n            _operators[tokenHolder][operator];\n    }\n    /**\n     * @dev See {IERC777-authorizeOperator}.\n     */\n    function authorizeOperator(address operator) public virtual override  {\n        require(_msgSender() != operator, \"ERC777: authorizing self as operator\");\n        if (_defaultOperators[operator]) {\n            delete _revokedDefaultOperators[_msgSender()][operator];\n        } else {\n            _operators[_msgSender()][operator] = true;\n        }\n        emit AuthorizedOperator(operator, _msgSender());\n    }\n    /**\n     * @dev See {IERC777-revokeOperator}.\n     */\n    function revokeOperator(address operator) public virtual override  {\n        require(operator != _msgSender(), \"ERC777: revoking self as operator\");\n        if (_defaultOperators[operator]) {\n            _revokedDefaultOperators[_msgSender()][operator] = true;\n        } else {\n            delete _operators[_msgSender()][operator];\n        }\n        emit RevokedOperator(operator, _msgSender());\n    }\n    /**\n     * @dev See {IERC777-defaultOperators}.\n     */\n    function defaultOperators() public view override returns (address[] memory) {\n        return _defaultOperatorsArray;\n    }\n    /**\n     * @dev See {IERC777-operatorSend}.\n     *\n     * Emits {Sent} and {IERC20-Transfer} events.\n     */\n    function operatorSend(\n        address sender,\n        address recipient,\n        uint256 amount,\n        bytes memory data,\n        bytes memory operatorData\n    )\n        public\n        virtual\n        override\n    {\n        require(isOperatorFor(_msgSender(), sender), \"ERC777: caller is not an operator for holder\");\n        _send(sender, recipient, amount, data, operatorData, true);\n    }\n    /**\n     * @dev See {IERC777-operatorBurn}.\n     *\n     * Emits {Burned} and {IERC20-Transfer} events.\n     */\n    function operatorBurn(address account, uint256 amount, bytes memory data, bytes memory operatorData) public virtual override {\n        require(isOperatorFor(_msgSender(), account), \"ERC777: caller is not an operator for holder\");\n        _burn(account, amount, data, operatorData);\n    }\n    /**\n     * @dev See {IERC20-allowance}.\n     *\n     * Note that operator and allowance concepts are orthogonal: operators may\n     * not have allowance, and accounts with allowance may not be operators\n     * themselves.\n     */\n    function allowance(address holder, address spender) public view override returns (uint256) {\n        return _allowances[holder][spender];\n    }\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Note that accounts cannot have allowance issued by their operators.\n     */\n    function approve(address spender, uint256 value) public virtual override returns (bool) {\n        address holder = _msgSender();\n        _approve(holder, spender, value);\n        return true;\n    }\n   /**\n    * @dev See {IERC20-transferFrom}.\n    *\n    * Note that operator and allowance concepts are orthogonal: operators cannot\n    * call `transferFrom` (unless they have allowance), and accounts with\n    * allowance cannot call `operatorSend` (unless they are operators).\n    *\n    * Emits {Sent}, {IERC20-Transfer} and {IERC20-Approval} events.\n    */\n    function transferFrom(address holder, address recipient, uint256 amount) public virtual override returns (bool) {\n        require(recipient != address(0), \"ERC777: transfer to the zero address\");\n        require(holder != address(0), \"ERC777: transfer from the zero address\");\n        address spender = _msgSender();\n        _callTokensToSend(spender, holder, recipient, amount, \"\", \"\");\n        _move(spender, holder, recipient, amount, \"\", \"\");\n        _approve(holder, spender, _allowances[holder][spender].sub(amount, \"ERC777: transfer amount exceeds allowance\"));\n        _callTokensReceived(spender, holder, recipient, amount, \"\", \"\", false);\n        return true;\n    }\n    /**\n     * @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * If a send hook is registered for `account`, the corresponding function\n     * will be called with `operator`, `data` and `operatorData`.\n     *\n     * See {IERC777Sender} and {IERC777Recipient}.\n     *\n     * Emits {Minted} and {IERC20-Transfer} events.\n     *\n     * Requirements\n     *\n     * - `account` cannot be the zero address.\n     * - if `account` is a contract, it must implement the {IERC777Recipient}\n     * interface.\n     */\n    function _mint(\n        address account,\n        uint256 amount,\n        bytes memory userData,\n        bytes memory operatorData\n    )\n        internal\n        virtual\n    {\n        require(account != address(0), \"ERC777: mint to the zero address\");\n        address operator = _msgSender();\n        _beforeTokenTransfer(operator, address(0), account, amount);\n        // Update state variables\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        _callTokensReceived(operator, address(0), account, amount, userData, operatorData, true);\n        emit Minted(operator, account, amount, userData, operatorData);\n        emit Transfer(address(0), account, amount);\n    }\n    /**\n     * @dev Send tokens\n     * @param from address token holder address\n     * @param to address recipient address\n     * @param amount uint256 amount of tokens to transfer\n     * @param userData bytes extra information provided by the token holder (if any)\n     * @param operatorData bytes extra information provided by the operator (if any)\n     * @param requireReceptionAck if true, contract recipients are required to implement ERC777TokensRecipient\n     */\n    function _send(\n        address from,\n        address to,\n        uint256 amount,\n        bytes memory userData,\n        bytes memory operatorData,\n        bool requireReceptionAck\n    )\n        internal\n        virtual\n    {\n        require(from != address(0), \"ERC777: send from the zero address\");\n        require(to != address(0), \"ERC777: send to the zero address\");\n        address operator = _msgSender();\n        _callTokensToSend(operator, from, to, amount, userData, operatorData);\n        _move(operator, from, to, amount, userData, operatorData);\n        _callTokensReceived(operator, from, to, amount, userData, operatorData, requireReceptionAck);\n    }\n    /**\n     * @dev Burn tokens\n     * @param from address token holder address\n     * @param amount uint256 amount of tokens to burn\n     * @param data bytes extra information provided by the token holder\n     * @param operatorData bytes extra information provided by the operator (if any)\n     */\n    function _burn(\n        address from,\n        uint256 amount,\n        bytes memory data,\n        bytes memory operatorData\n    )\n        internal\n        virtual\n    {\n        require(from != address(0), \"ERC777: burn from the zero address\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, address(0), amount);\n\n        _callTokensToSend(operator, from, address(0), amount, data, operatorData);\n\n        // Update state variables\n        _balances[from] = _balances[from].sub(amount, \"ERC777: burn amount exceeds balance\");\n        _totalSupply = _totalSupply.sub(amount);\n\n    \n          \n            \n    \n\n          \n          Expand Down\n    \n    \n  \n        emit Burned(operator, from, amount, data, operatorData);\n        emit Transfer(from, address(0), amount);\n    }\n    function _move(\n        address operator,\n        address from,\n        address to,\n        uint256 amount,\n        bytes memory userData,\n        bytes memory operatorData\n    )\n        private\n    {\n        _beforeTokenTransfer(operator, from, to, amount);\n        _balances[from] = _balances[from].sub(amount, \"ERC777: transfer amount exceeds balance\");\n        _balances[to] = _balances[to].add(amount);\n        emit Sent(operator, from, to, amount, userData, operatorData);\n        emit Transfer(from, to, amount);\n    }\n    /**\n     * @dev See {ERC20-_approve}.\n     *\n     * Note that accounts cannot have allowance issued by their operators.\n     */\n    function _approve(address holder, address spender, uint256 value) internal {\n        require(holder != address(0), \"ERC777: approve from the zero address\");\n        require(spender != address(0), \"ERC777: approve to the zero address\");\n        _allowances[holder][spender] = value;\n        emit Approval(holder, spender, value);\n    }\n    /**\n     * @dev Call from.tokensToSend() if the interface is registered\n     * @param operator address operator requesting the transfer\n     * @param from address token holder address\n     * @param to address recipient address\n     * @param amount uint256 amount of tokens to transfer\n     * @param userData bytes extra information provided by the token holder (if any)\n     * @param operatorData bytes extra information provided by the operator (if any)\n     */\n    function _callTokensToSend(\n        address operator,\n        address from,\n        address to,\n        uint256 amount,\n        bytes memory userData,\n        bytes memory operatorData\n    )\n        private\n    {\n        address implementer = _ERC1820_REGISTRY.getInterfaceImplementer(from, _TOKENS_SENDER_INTERFACE_HASH);\n        if (implementer != address(0)) {\n            IERC777Sender(implementer).tokensToSend(operator, from, to, amount, userData, operatorData);\n        }\n    }\n    /**\n     * @dev Call to.tokensReceived() if the interface is registered. Reverts if the recipient is a contract but\n     * tokensReceived() was not registered for the recipient\n     * @param operator address operator requesting the transfer\n     * @param from address token holder address\n     * @param to address recipient address\n     * @param amount uint256 amount of tokens to transfer\n     * @param userData bytes extra information provided by the token holder (if any)\n     * @param operatorData bytes extra information provided by the operator (if any)\n     * @param requireReceptionAck if true, contract recipients are required to implement ERC777TokensRecipient\n     */\n    function _callTokensReceived(\n        address operator,\n        address from,\n        address to,\n        uint256 amount,\n        bytes memory userData,\n        bytes memory operatorData,\n        bool requireReceptionAck\n    )\n        private\n    {\n        address implementer = _ERC1820_REGISTRY.getInterfaceImplementer(to, _TOKENS_RECIPIENT_INTERFACE_HASH);\n        if (implementer != address(0)) {\n            IERC777Recipient(implementer).tokensReceived(operator, from, to, amount, userData, operatorData);\n        } else if (requireReceptionAck) {\n            require(!to.isContract(), \"ERC777: token recipient contract has no implementer for ERC777TokensRecipient\");\n        }\n    }\n    /**\n     * @dev Hook that is called before any token transfer. This includes\n     * calls to {send}, {transfer}, {operatorSend}, minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be to transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address operator, address from, address to, uint256 amount) internal virtual { }\n}",
        "after": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.0 <0.8.0;\nimport \"../../utils/Context.sol\";\nimport \"./IERC777.sol\";\nimport \"./IERC777Recipient.sol\";\nimport \"./IERC777Sender.sol\";\nimport \"../../token/ERC20/IERC20.sol\";\nimport \"../../math/SafeMath.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../introspection/IERC1820Registry.sol\";\n/**\n * @dev Implementation of the {IERC777} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n *\n * Support for ERC20 is included in this contract, as specified by the EIP: both\n * the ERC777 and ERC20 interfaces can be safely used when interacting with it.\n * Both {IERC777-Sent} and {IERC20-Transfer} events are emitted on token\n * movements.\n *\n * Additionally, the {IERC777-granularity} value is hard-coded to `1`, meaning that there\n * are no special restrictions in the amount of tokens that created, moved, or\n * destroyed. This makes integration with ERC20 applications seamless.\n */\ncontract ERC777 is Context, IERC777, IERC20 {\n    using SafeMath for uint256;\n    using Address for address;\n    IERC1820Registry constant internal _ERC1820_REGISTRY = IERC1820Registry(0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24);\n    mapping(address => uint256) private _balances;\n    uint256 private _totalSupply;\n    string private _name;\n    string private _symbol;\n    // We inline the result of the following hashes because Solidity doesn't resolve them at compile time.\n    // See https://github.com/ethereum/solidity/issues/4024.\n    // keccak256(\"ERC777TokensSender\")\n    bytes32 constant private _TOKENS_SENDER_INTERFACE_HASH =\n        0x29ddb589b1fb5fc7cf394961c1adf5f8c6454761adf795e67fe149f658abe895;\n    // keccak256(\"ERC777TokensRecipient\")\n    bytes32 constant private _TOKENS_RECIPIENT_INTERFACE_HASH =\n        0xb281fc8c12954d22544db45de3159a39272895b169a852b314f9cc762e44c53b;\n    // This isn't ever read from - it's only used to respond to the defaultOperators query.\n    address[] private _defaultOperatorsArray;\n    // Immutable, but accounts may revoke them (tracked in __revokedDefaultOperators).\n    mapping(address => bool) private _defaultOperators;\n    // For each account, a mapping of its operators and revoked default operators.\n    mapping(address => mapping(address => bool)) private _operators;\n    mapping(address => mapping(address => bool)) private _revokedDefaultOperators;\n    // ERC20-allowances\n    mapping (address => mapping (address => uint256)) private _allowances;\n    /**\n     * @dev `defaultOperators` may be an empty array.\n     */\n    constructor(\n        string memory name_,\n        string memory symbol_,\n        address[] memory defaultOperators_\n    )\n        public\n    {\n        _name = name_;\n        _symbol = symbol_;\n        _defaultOperatorsArray = defaultOperators_;\n        for (uint256 i = 0; i < _defaultOperatorsArray.length; i++) {\n            _defaultOperators[_defaultOperatorsArray[i]] = true;\n        }\n        // register interfaces\n        _ERC1820_REGISTRY.setInterfaceImplementer(address(this), keccak256(\"ERC777Token\"), address(this));\n        _ERC1820_REGISTRY.setInterfaceImplementer(address(this), keccak256(\"ERC20Token\"), address(this));\n    }\n    /**\n     * @dev See {IERC777-name}.\n     */\n    function name() public view override returns (string memory) {\n        return _name;\n    }\n    /**\n     * @dev See {IERC777-symbol}.\n     */\n    function symbol() public view override returns (string memory) {\n        return _symbol;\n    }\n    /**\n     * @dev See {ERC20-decimals}.\n     *\n     * Always returns 18, as per the\n     * [ERC777 EIP](https://eips.ethereum.org/EIPS/eip-777#backward-compatibility).\n     */\n    function decimals() public pure returns (uint8) {\n        return 18;\n    }\n    /**\n     * @dev See {IERC777-granularity}.\n     *\n     * This implementation always returns `1`.\n     */\n    function granularity() public view override returns (uint256) {\n        return 1;\n    }\n    /**\n     * @dev See {IERC777-totalSupply}.\n     */\n    function totalSupply() public view override(IERC20, IERC777) returns (uint256) {\n        return _totalSupply;\n    }\n    /**\n     * @dev Returns the amount of tokens owned by an account (`tokenHolder`).\n     */\n    function balanceOf(address tokenHolder) public view override(IERC20, IERC777) returns (uint256) {\n        return _balances[tokenHolder];\n    }\n    /**\n     * @dev See {IERC777-send}.\n     *\n     * Also emits a {IERC20-Transfer} event for ERC20 compatibility.\n     */\n    function send(address recipient, uint256 amount, bytes memory data) public virtual override  {\n        _send(_msgSender(), recipient, amount, data, \"\", true);\n    }\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Unlike `send`, `recipient` is _not_ required to implement the {IERC777Recipient}\n     * interface if it is a contract.\n     *\n     * Also emits a {Sent} event.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        require(recipient != address(0), \"ERC777: transfer to the zero address\");\n        address from = _msgSender();\n        _callTokensToSend(from, from, recipient, amount, \"\", \"\");\n        _move(from, from, recipient, amount, \"\", \"\");\n        _callTokensReceived(from, from, recipient, amount, \"\", \"\", false);\n        return true;\n    }\n    /**\n     * @dev See {IERC777-burn}.\n     *\n     * Also emits a {IERC20-Transfer} event for ERC20 compatibility.\n     */\n    function burn(uint256 amount, bytes memory data) public virtual override  {\n        _burn(_msgSender(), amount, data, \"\");\n    }\n    /**\n     * @dev See {IERC777-isOperatorFor}.\n     */\n    function isOperatorFor(address operator, address tokenHolder) public view override returns (bool) {\n        return operator == tokenHolder ||\n            (_defaultOperators[operator] && !_revokedDefaultOperators[tokenHolder][operator]) ||\n            _operators[tokenHolder][operator];\n    }\n    /**\n     * @dev See {IERC777-authorizeOperator}.\n     */\n    function authorizeOperator(address operator) public virtual override  {\n        require(_msgSender() != operator, \"ERC777: authorizing self as operator\");\n        if (_defaultOperators[operator]) {\n            delete _revokedDefaultOperators[_msgSender()][operator];\n        } else {\n            _operators[_msgSender()][operator] = true;\n        }\n        emit AuthorizedOperator(operator, _msgSender());\n    }\n    /**\n     * @dev See {IERC777-revokeOperator}.\n     */\n    function revokeOperator(address operator) public virtual override  {\n        require(operator != _msgSender(), \"ERC777: revoking self as operator\");\n        if (_defaultOperators[operator]) {\n            _revokedDefaultOperators[_msgSender()][operator] = true;\n        } else {\n            delete _operators[_msgSender()][operator];\n        }\n        emit RevokedOperator(operator, _msgSender());\n    }\n    /**\n     * @dev See {IERC777-defaultOperators}.\n     */\n    function defaultOperators() public view override returns (address[] memory) {\n        return _defaultOperatorsArray;\n    }\n    /**\n     * @dev See {IERC777-operatorSend}.\n     *\n     * Emits {Sent} and {IERC20-Transfer} events.\n     */\n    function operatorSend(\n        address sender,\n        address recipient,\n        uint256 amount,\n        bytes memory data,\n        bytes memory operatorData\n    )\n        public\n        virtual\n        override\n    {\n        require(isOperatorFor(_msgSender(), sender), \"ERC777: caller is not an operator for holder\");\n        _send(sender, recipient, amount, data, operatorData, true);\n    }\n    /**\n     * @dev See {IERC777-operatorBurn}.\n     *\n     * Emits {Burned} and {IERC20-Transfer} events.\n     */\n    function operatorBurn(address account, uint256 amount, bytes memory data, bytes memory operatorData) public virtual override {\n        require(isOperatorFor(_msgSender(), account), \"ERC777: caller is not an operator for holder\");\n        _burn(account, amount, data, operatorData);\n    }\n    /**\n     * @dev See {IERC20-allowance}.\n     *\n     * Note that operator and allowance concepts are orthogonal: operators may\n     * not have allowance, and accounts with allowance may not be operators\n     * themselves.\n     */\n    function allowance(address holder, address spender) public view override returns (uint256) {\n        return _allowances[holder][spender];\n    }\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Note that accounts cannot have allowance issued by their operators.\n     */\n    function approve(address spender, uint256 value) public virtual override returns (bool) {\n        address holder = _msgSender();\n        _approve(holder, spender, value);\n        return true;\n    }\n   /**\n    * @dev See {IERC20-transferFrom}.\n    *\n    * Note that operator and allowance concepts are orthogonal: operators cannot\n    * call `transferFrom` (unless they have allowance), and accounts with\n    * allowance cannot call `operatorSend` (unless they are operators).\n    *\n    * Emits {Sent}, {IERC20-Transfer} and {IERC20-Approval} events.\n    */\n    function transferFrom(address holder, address recipient, uint256 amount) public virtual override returns (bool) {\n        require(recipient != address(0), \"ERC777: transfer to the zero address\");\n        require(holder != address(0), \"ERC777: transfer from the zero address\");\n        address spender = _msgSender();\n        _callTokensToSend(spender, holder, recipient, amount, \"\", \"\");\n        _move(spender, holder, recipient, amount, \"\", \"\");\n        _approve(holder, spender, _allowances[holder][spender].sub(amount, \"ERC777: transfer amount exceeds allowance\"));\n        _callTokensReceived(spender, holder, recipient, amount, \"\", \"\", false);\n        return true;\n    }\n    /**\n     * @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * If a send hook is registered for `account`, the corresponding function\n     * will be called with `operator`, `data` and `operatorData`.\n     *\n     * See {IERC777Sender} and {IERC777Recipient}.\n     *\n     * Emits {Minted} and {IERC20-Transfer} events.\n     *\n     * Requirements\n     *\n     * - `account` cannot be the zero address.\n     * - if `account` is a contract, it must implement the {IERC777Recipient}\n     * interface.\n     */\n    function _mint(\n        address account,\n        uint256 amount,\n        bytes memory userData,\n        bytes memory operatorData\n    )\n        internal\n        virtual\n    {\n        require(account != address(0), \"ERC777: mint to the zero address\");\n        address operator = _msgSender();\n        _beforeTokenTransfer(operator, address(0), account, amount);\n        // Update state variables\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        _callTokensReceived(operator, address(0), account, amount, userData, operatorData, true);\n        emit Minted(operator, account, amount, userData, operatorData);\n        emit Transfer(address(0), account, amount);\n    }\n    /**\n     * @dev Send tokens\n     * @param from address token holder address\n     * @param to address recipient address\n     * @param amount uint256 amount of tokens to transfer\n     * @param userData bytes extra information provided by the token holder (if any)\n     * @param operatorData bytes extra information provided by the operator (if any)\n     * @param requireReceptionAck if true, contract recipients are required to implement ERC777TokensRecipient\n     */\n    function _send(\n        address from,\n        address to,\n        uint256 amount,\n        bytes memory userData,\n        bytes memory operatorData,\n        bool requireReceptionAck\n    )\n        internal\n        virtual\n    {\n        require(from != address(0), \"ERC777: send from the zero address\");\n        require(to != address(0), \"ERC777: send to the zero address\");\n        address operator = _msgSender();\n        _callTokensToSend(operator, from, to, amount, userData, operatorData);\n        _move(operator, from, to, amount, userData, operatorData);\n        _callTokensReceived(operator, from, to, amount, userData, operatorData, requireReceptionAck);\n    }\n    /**\n     * @dev Burn tokens\n     * @param from address token holder address\n     * @param amount uint256 amount of tokens to burn\n     * @param data bytes extra information provided by the token holder\n     * @param operatorData bytes extra information provided by the operator (if any)\n     */\n    function _burn(\n        address from,\n        uint256 amount,\n        bytes memory data,\n        bytes memory operatorData\n    )\n        internal\n        virtual\n    {\n        require(from != address(0), \"ERC777: burn from the zero address\");\n\n        address operator = _msgSender();\n\n        _callTokensToSend(operator, from, address(0), amount, data, operatorData);\n\n        _beforeTokenTransfer(operator, from, address(0), amount);\n\n        // Update state variables\n        _balances[from] = _balances[from].sub(amount, \"ERC777: burn amount exceeds balance\");\n        _totalSupply = _totalSupply.sub(amount);\n\n    \n          \n            \n    \n\n          \n          Expand Down\n    \n    \n  \n        emit Burned(operator, from, amount, data, operatorData);\n        emit Transfer(from, address(0), amount);\n    }\n    function _move(\n        address operator,\n        address from,\n        address to,\n        uint256 amount,\n        bytes memory userData,\n        bytes memory operatorData\n    )\n        private\n    {\n        _beforeTokenTransfer(operator, from, to, amount);\n        _balances[from] = _balances[from].sub(amount, \"ERC777: transfer amount exceeds balance\");\n        _balances[to] = _balances[to].add(amount);\n        emit Sent(operator, from, to, amount, userData, operatorData);\n        emit Transfer(from, to, amount);\n    }\n    /**\n     * @dev See {ERC20-_approve}.\n     *\n     * Note that accounts cannot have allowance issued by their operators.\n     */\n    function _approve(address holder, address spender, uint256 value) internal {\n        require(holder != address(0), \"ERC777: approve from the zero address\");\n        require(spender != address(0), \"ERC777: approve to the zero address\");\n        _allowances[holder][spender] = value;\n        emit Approval(holder, spender, value);\n    }\n    /**\n     * @dev Call from.tokensToSend() if the interface is registered\n     * @param operator address operator requesting the transfer\n     * @param from address token holder address\n     * @param to address recipient address\n     * @param amount uint256 amount of tokens to transfer\n     * @param userData bytes extra information provided by the token holder (if any)\n     * @param operatorData bytes extra information provided by the operator (if any)\n     */\n    function _callTokensToSend(\n        address operator,\n        address from,\n        address to,\n        uint256 amount,\n        bytes memory userData,\n        bytes memory operatorData\n    )\n        private\n    {\n        address implementer = _ERC1820_REGISTRY.getInterfaceImplementer(from, _TOKENS_SENDER_INTERFACE_HASH);\n        if (implementer != address(0)) {\n            IERC777Sender(implementer).tokensToSend(operator, from, to, amount, userData, operatorData);\n        }\n    }\n    /**\n     * @dev Call to.tokensReceived() if the interface is registered. Reverts if the recipient is a contract but\n     * tokensReceived() was not registered for the recipient\n     * @param operator address operator requesting the transfer\n     * @param from address token holder address\n     * @param to address recipient address\n     * @param amount uint256 amount of tokens to transfer\n     * @param userData bytes extra information provided by the token holder (if any)\n     * @param operatorData bytes extra information provided by the operator (if any)\n     * @param requireReceptionAck if true, contract recipients are required to implement ERC777TokensRecipient\n     */\n    function _callTokensReceived(\n        address operator,\n        address from,\n        address to,\n        uint256 amount,\n        bytes memory userData,\n        bytes memory operatorData,\n        bool requireReceptionAck\n    )\n        private\n    {\n        address implementer = _ERC1820_REGISTRY.getInterfaceImplementer(to, _TOKENS_RECIPIENT_INTERFACE_HASH);\n        if (implementer != address(0)) {\n            IERC777Recipient(implementer).tokensReceived(operator, from, to, amount, userData, operatorData);\n        } else if (requireReceptionAck) {\n            require(!to.isContract(), \"ERC777: token recipient contract has no implementer for ERC777TokensRecipient\");\n        }\n    }\n    /**\n     * @dev Hook that is called before any token transfer. This includes\n     * calls to {send}, {transfer}, {operatorSend}, minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be to transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address operator, address from, address to, uint256 amount) internal virtual { }\n}"
    },
    {
        "tag": "arithmetic",
        "url": "https://github.com/AztecProtocol/aztec-connect-bridges/commit/89129e99529b0095310d52396a68edf251043a9b",
        "file": "src/bridges/liquity/TroveBridge.sol\n",
        "before": "// SPDX-License-Identifier: Apache-2.0\n// Copyright 2022 Aztec.\npragma solidity >=0.8.4;\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport {Strings} from \"@openzeppelin/contracts/utils/Strings.sol\";\nimport {AztecTypes} from \"rollup-encoder/libraries/AztecTypes.sol\";\nimport {IRollupProcessor} from \"rollup-encoder/interfaces/IRollupProcessor.sol\";\nimport {BridgeBase} from \"../base/BridgeBase.sol\";\nimport {ErrorLib} from \"../base/ErrorLib.sol\";\nimport {IWETH} from \"../../interfaces/IWETH.sol\";\nimport {IBorrowerOperations} from \"../../interfaces/liquity/IBorrowerOperations.sol\";\nimport {ITroveManager} from \"../../interfaces/liquity/ITroveManager.sol\";\nimport {ISortedTroves} from \"../../interfaces/liquity/ISortedTroves.sol\";\nimport {IUniswapV3SwapCallback} from \"../../interfaces/uniswapv3/callback/IUniswapV3SwapCallback.sol\";\nimport {IUniswapV3PoolActions} from \"../../interfaces/uniswapv3/pool/IUniswapV3PoolActions.sol\";\n/**\n * @title Aztec Connect Bridge for opening and closing Liquity's troves\n * @author Jan Benes (@benesjan on Github and Telegram)\n * @notice You can use this contract to borrow and repay LUSD\n * @dev The contract inherits from OpenZeppelin's implementation of ERC20 token because token balances are used to track\n * the depositor's ownership of the assets controlled by the bridge contract. The token is called TroveBridge and\n * the token symbol is TB-[initial ICR] (ICR is an acronym for individual collateral ratio). 1 TB token represents\n * 1 LUSD worth of debt if no redistribution took place (Liquity whitepaper section 4.2). If redistribution took place\n * 1 TB corresponds to more than 1 LUSD. In case the trove is not closed by redemption or liquidation, users can\n * withdraw their collateral by supplying TB and an equal amount of LUSD to the bridge. Alternatively, they supply only\n * TB on input in which case their debt will be repaid with a part their collateral. In case a user supplies both TB and\n * LUSD on input and 1 TB corresponds to more than 1 LUSD part of the ETH collateral withdrawn is swapped to LUSD and\n * the output amount is repaid. This swap is necessary because it's impossible to provide different amounts of\n * _inputAssetA and _inputAssetB. 1 deployment of the bridge contract controls 1 trove. The bridge keeps precise\n * accounting of debt by making sure that no user can change the trove's ICR. This means that when a price goes down\n * the only way how a user can avoid liquidation penalty is to repay their debt.\n *\n * In case the trove gets liquidated, the bridge no longer controls any ETH and all the TB balances are irrelevant.\n * At this point the bridge is defunct (unless owner is the only one who borrowed). If owner is the only who borrowed\n * calling closeTrove() will succeed and owner's balance will get burned, making TB total supply 0.\n *\n * If the trove is closed by redemption, users can withdraw their remaining collateral by supplying their TB.\n *\n * DISCLAIMER: Users are not able to exit the Trove in case the Liquity system is in recovery mode (total CR < 150%).\n * This is because in recovery mode only pure collateral top-up or debt repayment is allowed. This makes exit\n * from this bridge impossible in recovery mode because such exit is always a combination of debt repayment and\n * collateral withdrawal.\n */\ncontract TroveBridge is BridgeBase, ERC20, Ownable, IUniswapV3SwapCallback {\n    using Strings for uint256;\n    error NonZeroTotalSupply();\n    error InvalidStatus(Status status);\n    error InvalidDeltaAmounts();\n    error OwnerNotLast();\n    error MaxCostExceeded();\n    error SwapFailed();\n    // Trove status taken from TroveManager.sol\n    enum Status {\n        nonExistent,\n        active,\n        closedByOwner,\n        closedByLiquidation,\n        closedByRedemption\n    }\n    struct SwapCallbackData {\n        uint256 debtToRepay;\n        uint256 collToWithdraw;\n    }\n    address public constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n    address public constant USDC = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;\n    address public constant LUSD = 0x5f98805A4E8be255a32880FDeC7F6728C6568bA0;\n    IBorrowerOperations public constant BORROWER_OPERATIONS =\n        IBorrowerOperations(0x24179CD81c9e782A4096035f7eC97fB8B783e007);\n    ITroveManager public constant TROVE_MANAGER = ITroveManager(0xA39739EF8b0231DbFA0DcdA07d7e29faAbCf4bb2);\n    ISortedTroves public constant SORTED_TROVES = ISortedTroves(0x8FdD3fbFEb32b28fb73555518f8b361bCeA741A6);\n    // Both pools are Uniswap V3 500 bps fee tier pools\n    address public constant LUSD_USDC_POOL = 0x4e0924d3a751bE199C426d52fb1f2337fa96f736;\n    address public constant USDC_ETH_POOL = 0x88e6A0c2dDD26FEEb64F039a2c41296FcB3f5640;\n    // The amount of dust to leave in the contract\n    // Optimization based on EIP-1087\n    uint256 public constant DUST = 1;\n    uint256 public immutable INITIAL_ICR;\n    // Price precision\n    uint256 public constant PRECISION = 1e18;\n    // We are not setting price impact protection and in both swaps zeroForOne is false so sqrtPriceLimitX96\n    // is set to TickMath.MAX_SQRT_RATIO - 1 = 1461446703485210103287273052203988822378723970341\n    // See https://github.com/Uniswap/v3-periphery/blob/22a7ead071fff53f00d9ddc13434f285f4ed5c7d/contracts/SwapRouter.sol#L187\n    // for more information.\n    uint160 private constant SQRT_PRICE_LIMIT_X96 = 1461446703485210103287273052203988822378723970341;\n    // Used to check whether collateral has already been claimed during redemptions.\n    bool private collateralClaimed;\n    /**\n     * @notice Set the address of RollupProcessor.sol and initial ICR\n     * @param _rollupProcessor Address of the RollupProcessor.sol\n     * @param _initialICRPerc Collateral ratio denominated in percents to be used when opening the Trove\n     */\n    constructor(address _rollupProcessor, uint256 _initialICRPerc)\n        BridgeBase(_rollupProcessor)\n        ERC20(\"TroveBridge\", string(abi.encodePacked(\"TB-\", _initialICRPerc.toString())))\n    {\n        INITIAL_ICR = _initialICRPerc * 1e16;\n        _mint(address(this), DUST);\n        // Registering the bridge for subsidy\n        uint256[] memory criteria = new uint256[](2);\n        uint32[] memory gasUsage = new uint32[](2);\n        uint32[] memory minGasPerMinute = new uint32[](2);\n        criteria[0] = 0; // Borrow flow\n        criteria[1] = 1; // Repay/redeem flow\n        gasUsage[0] = 520000;\n        gasUsage[1] = 410000;\n        // This is approximately 520k / (24 * 60) / 2 --> targeting 1 full subsidized call per 2 days\n        minGasPerMinute[0] = 180;\n        // This is approximately 410k / (24 * 60) / 4 --> targeting 1 full subsidized call per 4 days\n        minGasPerMinute[1] = 70;\n        // We set gas usage and minGasPerMinute in the Subsidy contract\n        SUBSIDY.setGasUsageAndMinGasPerMinute(criteria, gasUsage, minGasPerMinute);\n    }\n    receive() external payable {}\n    fallback() external payable {}\n    /**\n     * @notice A function which opens the trove.\n     * @param _upperHint Address of a Trove with a position in the sorted list before the correct insert position.\n     * @param _lowerHint Address of a Trove with a position in the sorted list after the correct insert position.\n     * See https://github.com/liquity/dev#supplying-hints-to-trove-operations for more details about hints.\n     * @param _maxFee Maximum borrower fee.\n     * @dev Sufficient amount of ETH has to be send so that at least 2000 LUSD gets borrowed. 2000 LUSD is a minimum\n     * amount allowed by Liquity.\n     */\n    function openTrove(\n        address _upperHint,\n        address _lowerHint,\n        uint256 _maxFee\n    ) external payable onlyOwner {\n        // Checks whether the trove can be safely opened/reopened\n        if (totalSupply() != 0) revert NonZeroTotalSupply();\n        if (!IERC20(LUSD).approve(ROLLUP_PROCESSOR, type(uint256).max)) revert ErrorLib.ApproveFailed(LUSD);\n        if (!this.approve(ROLLUP_PROCESSOR, type(uint256).max)) revert ErrorLib.ApproveFailed(address(this));\n        uint256 amtToBorrow = computeAmtToBorrow(msg.value);\n        (uint256 debtBefore, , , ) = TROVE_MANAGER.getEntireDebtAndColl(address(this));\n        BORROWER_OPERATIONS.openTrove{value: msg.value}(_maxFee, amtToBorrow, _upperHint, _lowerHint);\n        (uint256 debtAfter, , , ) = TROVE_MANAGER.getEntireDebtAndColl(address(this));\n        IERC20(LUSD).transfer(msg.sender, IERC20(LUSD).balanceOf(address(this)) - DUST);\n        // I mint TB token to msg.sender to be able to track collateral ownership. Minted amount equals debt increase.\n        _mint(msg.sender, debtAfter - debtBefore);\n    }\n    /**\n     * @notice A function which allows interaction with this bridge's trove from within Aztec Connect.\n     * @dev This method can only be called from the RollupProcessor.sol. If the input asset is ETH, borrowing flow is\n     * executed. If TB, repaying. RollupProcessor.sol has to transfer the tokens to the bridge before calling\n     * the method. If this is not the case, the function will revert.\n     *\n     *                            Borrowing        | Repaying        | Repaying (redis.)| Repay. (coll.)| Redeeming\n     * @param _inputAssetA -      ETH              | TB              | TB               | TB            | TB\n     * @param _inputAssetB -      None             | LUSD            | LUSD             | None          | None\n     * @param _outputAssetA -     TB               | ETH             | ETH              | ETH           | ETH\n     * @param _outputAssetB -     LUSD             | LUSD            | TB               | None          | None\n     * @param _totalInputValue -  ETH amount       | TB and LUSD amt.| TB and LUSD amt. | TB amount     | TB amount\n     * @param _interactionNonce - nonce            | nonce           | nonce            | nonce         | nonce\n     * @param _auxData -          max borrower fee | 0               | max ETH price    | max ETH price | 0\n     * @param _rollupBeneficiary - Address which receives subsidy if the call is eligible for it\n     * @return outputValueA -     TB amount        | ETH amount      | ETH amount       | ETH amount    | ETH amount\n     * @return outputValueB -     LUSD amount      | LUSD amount     | TB amount        | 0             | 0\n     * @dev The amount of LUSD returned (outputValueB) during repayment will be non-zero only when the trove was\n     * partially redeemed.\n     */\n    function convert(\n        AztecTypes.AztecAsset calldata _inputAssetA,\n        AztecTypes.AztecAsset calldata _inputAssetB,\n        AztecTypes.AztecAsset calldata _outputAssetA,\n        AztecTypes.AztecAsset calldata _outputAssetB,\n        uint256 _totalInputValue,\n        uint256 _interactionNonce,\n        uint64 _auxData,\n        address _rollupBeneficiary\n    )\n        external\n        payable\n        override(BridgeBase)\n        onlyRollup\n        returns (\n            uint256 outputValueA,\n            uint256 outputValueB,\n            bool\n        )\n    {\n        Status troveStatus = Status(TROVE_MANAGER.getTroveStatus(address(this)));\n        uint256 subsidyCriteria;\n        if (\n            _inputAssetA.assetType == AztecTypes.AztecAssetType.ETH &&\n            _outputAssetA.erc20Address == address(this) &&\n            _outputAssetB.erc20Address == LUSD\n        ) {\n            // Borrowing\n            if (troveStatus != Status.active) revert InvalidStatus(troveStatus);\n            (outputValueA, outputValueB) = _borrow(_totalInputValue, _auxData);\n            subsidyCriteria = 0;\n        } else if (\n            _inputAssetA.erc20Address == address(this) &&\n            _inputAssetB.erc20Address == LUSD &&\n            _outputAssetA.assetType == AztecTypes.AztecAssetType.ETH\n        ) {\n            // Repaying\n            if (troveStatus != Status.active) revert InvalidStatus(troveStatus);\n            if (_outputAssetB.erc20Address == LUSD) {\n                // A case when the trove was partially redeemed (1 TB corresponding to less than 1 LUSD of debt) or not\n                // redeemed and not touched by redistribution (1 TB corresponding to exactly 1 LUSD of debt)\n                (outputValueA, outputValueB) = _repay(_totalInputValue, _interactionNonce);\n            } else if (_outputAssetB.erc20Address == address(this)) {\n                // A case when the trove was touched by redistribution (1 TB corresponding to more than 1 LUSD of\n                // debt). For this reason it was impossible to provide enough LUSD on input since it's not currently\n                // allowed to have different input token amounts. Swap part of the collateral to be able to repay\n                // the debt in full.\n                (outputValueA, outputValueB) = _repayWithCollateral(\n                    _totalInputValue,\n                    _auxData,\n                    _interactionNonce,\n                    true\n                );\n            } else {\n                revert ErrorLib.InvalidOutputB();\n            }\n            subsidyCriteria = 1;\n        } else if (\n            _inputAssetA.erc20Address == address(this) && _outputAssetA.assetType == AztecTypes.AztecAssetType.ETH\n        ) {\n            if (troveStatus == Status.active) {\n                // Repaying debt with collateral (using flash swaps)\n                (outputValueA, ) = _repayWithCollateral(_totalInputValue, _auxData, _interactionNonce, false);\n            } else if (troveStatus == Status.closedByRedemption || troveStatus == Status.closedByLiquidation) {\n                // Redeeming remaining collateral after the Trove is closed\n                outputValueA = _redeem(_totalInputValue, _interactionNonce);\n            } else {\n                revert InvalidStatus(troveStatus);\n            }\n            subsidyCriteria = 1;\n        } else {\n            revert ErrorLib.InvalidInput();\n        }\n        SUBSIDY.claimSubsidy(subsidyCriteria, _rollupBeneficiary);\n    }\n    /**\n     * @notice A function which closes the trove.\n     * @dev LUSD allowance has to be at least (remaining debt - 200 LUSD).\n     */\n    function closeTrove() external onlyOwner {\n        address payable owner = payable(owner());\n        uint256 ownerTBBalance = balanceOf(owner);\n        if (ownerTBBalance != totalSupply()) revert OwnerNotLast();\n        _burn(owner, ownerTBBalance);\n        Status troveStatus = Status(TROVE_MANAGER.getTroveStatus(address(this)));\n        if (troveStatus == Status.active) {\n            (uint256 remainingDebt, , , ) = TROVE_MANAGER.getEntireDebtAndColl(address(this));\n            // 200e18 is a part of debt which gets repaid from LUSD_GAS_COMPENSATION.\n            if (!IERC20(LUSD).transferFrom(owner, address(this), remainingDebt - 200e18)) {\n                revert ErrorLib.TransferFailed(LUSD);\n            }\n            BORROWER_OPERATIONS.closeTrove();\n        } else if (troveStatus == Status.closedByRedemption || troveStatus == Status.closedByLiquidation) {\n            if (!collateralClaimed) {\n                BORROWER_OPERATIONS.claimCollateral();\n            } else {\n                collateralClaimed = false;\n            }\n        }\n        owner.transfer(address(this).balance);\n    }\n    // @inheritdoc IUniswapV3SwapCallback\n    // @dev See _repayWithCollateral(...) method for more information about how this callback is entered.\n    function uniswapV3SwapCallback(\n        int256 _amount0Delta,\n        int256 _amount1Delta,\n        bytes calldata _data\n    ) external override(IUniswapV3SwapCallback) {\n        // Swaps entirely within 0-liquidity regions are not supported\n        if (_amount0Delta <= 0 && _amount1Delta <= 0) revert InvalidDeltaAmounts();\n        // Uniswap pools always call callback on msg.sender so this check is enough to prevent malicious behavior\n        if (msg.sender == LUSD_USDC_POOL) {\n            SwapCallbackData memory data = abi.decode(_data, (SwapCallbackData));\n            // Repay debt in full\n            (address upperHint, address lowerHint) = _getHints();\n            BORROWER_OPERATIONS.adjustTrove(0, data.collToWithdraw, data.debtToRepay, false, upperHint, lowerHint);\n            // Pay LUSD_USDC_POOL for the swap by passing it as a recipient to the next swap (WETH -> USDC)\n            IUniswapV3PoolActions(USDC_ETH_POOL).swap(\n                LUSD_USDC_POOL, // recipient\n                false, // zeroForOne\n                -_amount1Delta, // amount of USDC to pay to LUSD_USDC_POOL for the swap\n                SQRT_PRICE_LIMIT_X96,\n                \"\"\n            );\n        } else if (msg.sender == USDC_ETH_POOL) {\n            // Pay USDC_ETH_POOL for the USDC\n            uint256 amountToPay = uint256(_amount1Delta);\n            IWETH(WETH).deposit{value: amountToPay}(); // wrap only what is needed to pay\n            IWETH(WETH).transfer(address(USDC_ETH_POOL), amountToPay);\n        } else {\n            revert ErrorLib.InvalidCaller();\n        }\n    }\n    /**\n     * @notice Compute how much LUSD to borrow against collateral in order to keep ICR constant and by how much total\n     * trove debt will increase.\n     * @param _collateral Amount of ETH denominated in Wei\n     * @return amtToBorrow Amount of LUSD to borrow to keep ICR constant.\n     * + borrowing fee)\n     * @dev I don't use view modifier here because the function updates PriceFeed state.\n     *\n     * Since the Trove opening and adjustment processes have desired amount of LUSD to borrow on the input and not\n     * the desired ICR I have to do the computation of borrowing fee \"backwards\". Here are the operations I did in order\n     * to get the final formula:\n     *      1) debtIncrease = amtToBorrow + amtToBorrow * BORROWING_RATE / DECIMAL_PRECISION + 200LUSD\n     *      2) debtIncrease - 200LUSD = amtToBorrow * (1 + BORROWING_RATE / DECIMAL_PRECISION)\n     *      3) amtToBorrow = (debtIncrease - 200LUSD) / (1 + BORROWING_RATE / DECIMAL_PRECISION)\n     *      4) amtToBorrow = (debtIncrease - 200LUSD) * DECIMAL_PRECISION / (DECIMAL_PRECISION + BORROWING_RATE)\n     * Note1: For trove adjustments (not opening) remove the 200 LUSD fee compensation from the formulas above.\n     * Note2: Step 4 is necessary to avoid loss of precision. BORROWING_RATE / DECIMAL_PRECISION was rounded to 0.\n     * Note3: The borrowing fee computation is on this line in Liquity code: https://github.com/liquity/dev/blob/cb583ddf5e7de6010e196cfe706bd0ca816ea40e/packages/contracts/contracts/TroveManager.sol#L1433\n     */\n    function computeAmtToBorrow(uint256 _collateral) public returns (uint256 amtToBorrow) {\n        uint256 price = TROVE_MANAGER.priceFeed().fetchPrice();\n        if (TROVE_MANAGER.getTroveStatus(address(this)) == 1) {\n            // Trove is active - use current ICR and not the initial one\n            uint256 icr = TROVE_MANAGER.getCurrentICR(address(this), price);\n            amtToBorrow = (_collateral * price) / icr;\n        } else {\n            // Trove is inactive - I will use initial ICR to compute debt\n            // 200e18 - 200 LUSD gas compensation to liquidators\n            amtToBorrow = (_collateral * price) / INITIAL_ICR - 200e18;\n        }\n        if (!TROVE_MANAGER.checkRecoveryMode(price)) {\n            // Liquity is not in recovery mode so borrowing fee applies\n            uint256 borrowingRate = TROVE_MANAGER.getBorrowingRateWithDecay();\n            amtToBorrow = (amtToBorrow * 1e18) / (borrowingRate + 1e18);\n        }\n    }\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view override(ERC20) returns (uint256) {\n        return super.totalSupply() - DUST;\n    }\n    /**\n     * @notice Borrow LUSD\n     * @param _collateral Amount of ETH denominated in Wei\n     * @param _maxFee Maximum borrowing fee\n     * @return tbMinted Amount of TB minted for borrower.\n     * @return lusdBorrowed Amount of LUSD borrowed.\n     */\n    function _borrow(uint256 _collateral, uint64 _maxFee) private returns (uint256 tbMinted, uint256 lusdBorrowed) {\n        lusdBorrowed = computeAmtToBorrow(_collateral); // LUSD amount to borrow\n        (uint256 debtBefore, , , ) = TROVE_MANAGER.getEntireDebtAndColl(address(this));\n        (address upperHint, address lowerHint) = _getHints();\n        BORROWER_OPERATIONS.adjustTrove{value: _collateral}(_maxFee, 0, lusdBorrowed, true, upperHint, lowerHint);\n        (uint256 debtAfter, , , ) = TROVE_MANAGER.getEntireDebtAndColl(address(this));\n        // tbMinted = amount of TB to mint = (debtIncrease [LUSD] / debtBefore [LUSD]) * tbTotalSupply\n        // debtIncrease = debtAfter - debtBefore\n        // In case no redistribution took place (TB/LUSD = 1) then debt_before = TB_total_supply\n        // and debt_increase amount of TB is minted.\n        // In case there was redistribution, 1 TB corresponds to more than 1 LUSD and the amount of TB minted\n        // will be lower than the amount of LUSD borrowed.\n        tbMinted = ((debtAfter - debtBefore) * totalSupply()) / debtBefore;\n        _mint(address(this), tbMinted);\n    }\n    /**\n     * @notice Repay debt.\n     * @param _tbAmount Amount of TB to burn.\n     * @param _interactionNonce Same as in convert(...) method.\n     * @return collateral Amount of collateral withdrawn.\n     * @return lusdReturned Amount of LUSD returned (non-zero only if the trove was partially redeemed)\n     */\n    function _repay(uint256 _tbAmount, uint256 _interactionNonce)\n        private\n        returns (uint256 collateral, uint256 lusdReturned)\n    {\n        (uint256 debtBefore, uint256 collBefore, , ) = TROVE_MANAGER.getEntireDebtAndColl(address(this));\n        // Compute how much debt to be repay\n        uint256 tbTotalSupply = totalSupply(); // SLOAD optimization\n        uint256 debtToRepay = (_tbAmount * debtBefore) / tbTotalSupply;\n        if (debtToRepay > _tbAmount) revert ErrorLib.InvalidOutputB();\n        // Compute how much collateral to withdraw\n        uint256 collToWithdraw = (_tbAmount * collBefore) / tbTotalSupply;\n        // Repay _totalInputValue of LUSD and withdraw collateral\n        (address upperHint, address lowerHint) = _getHints();\n        BORROWER_OPERATIONS.adjustTrove(0, collToWithdraw, debtToRepay, false, upperHint, lowerHint);\n        lusdReturned = _tbAmount - debtToRepay; // LUSD to return --> 0 unless trove was partially redeemed\n        // Burn input TB and return ETH to rollup processor\n        collateral = address(this).balance;\n        _burn(address(this), _tbAmount);\n        IRollupProcessor(ROLLUP_PROCESSOR).receiveEthFromBridge{value: collateral}(_interactionNonce);\n    }\n    /**\n     * @notice Repay debt by selling part of the collateral for LUSD.\n     * @param _totalInputValue Amount of TB to burn (and input LUSD to use for repayment if `_lusdInput` param is set\n     *                         to true).\n     * @param _maxPrice Maximum acceptable price of LUSD denominated in ETH.\n     * @param _interactionNonce Same as in convert(...) method.\n     * @param _lusdInput If true the debt will be covered by both the LUSD on input and by selling part of the\n     *                   collateral. If false the debt will be covered only by selling the collateral.\n     * @return collateralReturned Amount of collateral withdrawn.\n     * @return tbReturned Amount of TB returned (non-zero only when the flash swap fails)\n     * @dev It's important that CR never drops because if the trove was near minimum CR (MCR) the tx would revert.\n     *      This would effectively stop users from being able to exit. Unfortunately users are also not able\n     *      to exit when Liquity is in recovery mode (total collateral ratio < 150%) because in such a case\n     *      only pure collateral top-up or debt repayment is allowed.\n     *      To avoid CR from ever dropping bellow MCR I came up with the following construction:\n     *        1) Flash swap USDC to LUSD,\n     *        2) repay the user's trove debt in full (in the 1st callback),\n     *        3) flash swap WETH to USDC with recipient being the LUSD_USDC_POOL - this pays for the first swap,\n     *        4) in the 2nd callback deposit part of the withdrawn collateral to WETH and pay for the 2nd swap.\n     *      In case the flash swap fails only a part of the debt gets repaid and the remaining TB balance corresponding\n     *      to the unpaid debt gets returned.\n     *      Note: Since owner is not able to exit until all the TB of everyone else gets burned his funds will be\n     *      stuck forever unless the Uniswap pools recover.\n     */\n    function _repayWithCollateral(\n        uint256 _totalInputValue,\n        uint256 _maxPrice,\n        uint256 _interactionNonce,\n        bool _lusdInput\n    ) private returns (uint256 collateralReturned, uint256 tbReturned) {\n        (uint256 debtBefore, uint256 collBefore, , ) = TROVE_MANAGER.getEntireDebtAndColl(address(this));\n        // Compute how much debt to be repay\n        uint256 tbTotalSupply = totalSupply(); // SLOAD optimization\n        uint256 debtToRepay = (_totalInputValue * debtBefore) / tbTotalSupply;\n        uint256 collToWithdraw = (_totalInputValue * collBefore) / tbTotalSupply;\n        uint256 lusdToBuy;\n        if (_lusdInput) {\n            // Reverting here because an incorrect flow has been chosen --> there is no reason to be using flash swaps\n            // when the amount of LUSD on input is enough to cover the debt\n            if (debtToRepay <= _totalInputValue) revert ErrorLib.InvalidOutputB();\n            uint256 lusdToBuy = debtToRepay - _totalInputValue;\n        } else {\n            lusdToBuy = debtToRepay;\n        }\n\n        (bool success, ) = LUSD_USDC_POOL.call(\n            abi.encodeWithSignature(\n                \"swap(address,bool,int256,uint160,bytes)\",\n\n    \n        \n          \n    \n\n        \n        Expand All\n    \n    @@ -489,7 +494,7 @@ contract TroveBridge is BridgeBase, ERC20, Ownable, IUniswapV3SwapCallback {\n  \n                address(this), // recipient\n                false, // zeroForOne\n                -int256(lusdToBuy),\n                SQRT_PRICE_LIMIT_X96,\n                abi.encode(SwapCallbackData({debtToRepay: debtToRepay, collToWithdraw: collToWithdraw}))\n            )\n        );\n\n        if (success) {\n            // Note: Debt repayment took place in the `uniswapV3SwapCallback(...)` function\n            collateralReturned = address(this).balance;\n\n            {\n                // Check that at most `maxCost` of ETH collateral was sold for `debtToRepay` worth of LUSD\n\n    \n          \n            \n    \n\n          \n          Expand Down\n    \n    \n  \n                uint256 maxCost = (lusdToBuy * _maxPrice) / PRECISION;\n                uint256 collateralSold = collToWithdraw - collateralReturned;\n                if (collateralSold > maxCost) revert MaxCostExceeded();\n            }\n            // Burn all input TB\n            _burn(address(this), _totalInputValue);\n        } else if (_lusdInput) {\n            // Flash swap failed and some LUSD was provided on input --> repay as much debt as you can with current\n            // LUSD balance and return the remaining TB\n            debtToRepay = _totalInputValue;\n            uint256 tbToBurn = (debtToRepay * tbTotalSupply) / debtBefore;\n            collToWithdraw = (tbToBurn * collBefore) / tbTotalSupply;\n            {\n                // Repay _totalInputValue of LUSD and withdraw collateral\n                (address upperHint, address lowerHint) = _getHints();\n                BORROWER_OPERATIONS.adjustTrove(0, collToWithdraw, debtToRepay, false, upperHint, lowerHint);\n            }\n            tbReturned = _totalInputValue - tbToBurn;\n            _burn(address(this), tbToBurn);\n            collateralReturned = address(this).balance;\n        } else {\n            revert SwapFailed();\n        }\n        // Return ETH to rollup processor\n        IRollupProcessor(ROLLUP_PROCESSOR).receiveEthFromBridge{value: collateralReturned}(_interactionNonce);\n    }\n    /**\n     * @notice Redeem collateral.\n     * @param _tbAmount Amount of TB to burn.\n     * @param _interactionNonce Same as in convert(...) method.\n     * @return collateral Amount of collateral withdrawn.\n     */\n    function _redeem(uint256 _tbAmount, uint256 _interactionNonce) private returns (uint256 collateral) {\n        if (!collateralClaimed) {\n            BORROWER_OPERATIONS.claimCollateral();\n            collateralClaimed = true;\n        }\n        collateral = (address(this).balance * _tbAmount) / totalSupply();\n        _burn(address(this), _tbAmount);\n        IRollupProcessor(ROLLUP_PROCESSOR).receiveEthFromBridge{value: collateral}(_interactionNonce);\n    }\n    /**\n     * @notice Get lower and upper insertion hints.\n     * @return upperHint Upper insertion hint.\n     * @return lowerHint Lower insertion hint.\n     * @dev See https://github.com/liquity/dev#supplying-hints-to-trove-operations for more details on hints.\n     */\n    function _getHints() private view returns (address upperHint, address lowerHint) {\n        return (SORTED_TROVES.getPrev(address(this)), SORTED_TROVES.getNext(address(this)));\n    }\n}",
        "after": "// SPDX-License-Identifier: Apache-2.0\n// Copyright 2022 Aztec.\npragma solidity >=0.8.4;\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport {Strings} from \"@openzeppelin/contracts/utils/Strings.sol\";\nimport {AztecTypes} from \"rollup-encoder/libraries/AztecTypes.sol\";\nimport {IRollupProcessor} from \"rollup-encoder/interfaces/IRollupProcessor.sol\";\nimport {BridgeBase} from \"../base/BridgeBase.sol\";\nimport {ErrorLib} from \"../base/ErrorLib.sol\";\nimport {IWETH} from \"../../interfaces/IWETH.sol\";\nimport {IBorrowerOperations} from \"../../interfaces/liquity/IBorrowerOperations.sol\";\nimport {ITroveManager} from \"../../interfaces/liquity/ITroveManager.sol\";\nimport {ISortedTroves} from \"../../interfaces/liquity/ISortedTroves.sol\";\nimport {IUniswapV3SwapCallback} from \"../../interfaces/uniswapv3/callback/IUniswapV3SwapCallback.sol\";\nimport {IUniswapV3PoolActions} from \"../../interfaces/uniswapv3/pool/IUniswapV3PoolActions.sol\";\n/**\n * @title Aztec Connect Bridge for opening and closing Liquity's troves\n * @author Jan Benes (@benesjan on Github and Telegram)\n * @notice You can use this contract to borrow and repay LUSD\n * @dev The contract inherits from OpenZeppelin's implementation of ERC20 token because token balances are used to track\n * the depositor's ownership of the assets controlled by the bridge contract. The token is called TroveBridge and\n * the token symbol is TB-[initial ICR] (ICR is an acronym for individual collateral ratio). 1 TB token represents\n * 1 LUSD worth of debt if no redistribution took place (Liquity whitepaper section 4.2). If redistribution took place\n * 1 TB corresponds to more than 1 LUSD. In case the trove is not closed by redemption or liquidation, users can\n * withdraw their collateral by supplying TB and an equal amount of LUSD to the bridge. Alternatively, they supply only\n * TB on input in which case their debt will be repaid with a part their collateral. In case a user supplies both TB and\n * LUSD on input and 1 TB corresponds to more than 1 LUSD part of the ETH collateral withdrawn is swapped to LUSD and\n * the output amount is repaid. This swap is necessary because it's impossible to provide different amounts of\n * _inputAssetA and _inputAssetB. 1 deployment of the bridge contract controls 1 trove. The bridge keeps precise\n * accounting of debt by making sure that no user can change the trove's ICR. This means that when a price goes down\n * the only way how a user can avoid liquidation penalty is to repay their debt.\n *\n * In case the trove gets liquidated, the bridge no longer controls any ETH and all the TB balances are irrelevant.\n * At this point the bridge is defunct (unless owner is the only one who borrowed). If owner is the only who borrowed\n * calling closeTrove() will succeed and owner's balance will get burned, making TB total supply 0.\n *\n * If the trove is closed by redemption, users can withdraw their remaining collateral by supplying their TB.\n *\n * DISCLAIMER: Users are not able to exit the Trove in case the Liquity system is in recovery mode (total CR < 150%).\n * This is because in recovery mode only pure collateral top-up or debt repayment is allowed. This makes exit\n * from this bridge impossible in recovery mode because such exit is always a combination of debt repayment and\n * collateral withdrawal.\n */\ncontract TroveBridge is BridgeBase, ERC20, Ownable, IUniswapV3SwapCallback {\n    using Strings for uint256;\n    error NonZeroTotalSupply();\n    error InvalidStatus(Status status);\n    error InvalidDeltaAmounts();\n    error OwnerNotLast();\n    error MaxCostExceeded();\n    error SwapFailed();\n    // Trove status taken from TroveManager.sol\n    enum Status {\n        nonExistent,\n        active,\n        closedByOwner,\n        closedByLiquidation,\n        closedByRedemption\n    }\n    struct SwapCallbackData {\n        uint256 debtToRepay;\n        uint256 collToWithdraw;\n    }\n    address public constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n    address public constant USDC = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;\n    address public constant LUSD = 0x5f98805A4E8be255a32880FDeC7F6728C6568bA0;\n    IBorrowerOperations public constant BORROWER_OPERATIONS =\n        IBorrowerOperations(0x24179CD81c9e782A4096035f7eC97fB8B783e007);\n    ITroveManager public constant TROVE_MANAGER = ITroveManager(0xA39739EF8b0231DbFA0DcdA07d7e29faAbCf4bb2);\n    ISortedTroves public constant SORTED_TROVES = ISortedTroves(0x8FdD3fbFEb32b28fb73555518f8b361bCeA741A6);\n    // Both pools are Uniswap V3 500 bps fee tier pools\n    address public constant LUSD_USDC_POOL = 0x4e0924d3a751bE199C426d52fb1f2337fa96f736;\n    address public constant USDC_ETH_POOL = 0x88e6A0c2dDD26FEEb64F039a2c41296FcB3f5640;\n    // The amount of dust to leave in the contract\n    // Optimization based on EIP-1087\n    uint256 public constant DUST = 1;\n    uint256 public immutable INITIAL_ICR;\n    // Price precision\n    uint256 public constant PRECISION = 1e18;\n    // We are not setting price impact protection and in both swaps zeroForOne is false so sqrtPriceLimitX96\n    // is set to TickMath.MAX_SQRT_RATIO - 1 = 1461446703485210103287273052203988822378723970341\n    // See https://github.com/Uniswap/v3-periphery/blob/22a7ead071fff53f00d9ddc13434f285f4ed5c7d/contracts/SwapRouter.sol#L187\n    // for more information.\n    uint160 private constant SQRT_PRICE_LIMIT_X96 = 1461446703485210103287273052203988822378723970341;\n    // Used to check whether collateral has already been claimed during redemptions.\n    bool private collateralClaimed;\n    /**\n     * @notice Set the address of RollupProcessor.sol and initial ICR\n     * @param _rollupProcessor Address of the RollupProcessor.sol\n     * @param _initialICRPerc Collateral ratio denominated in percents to be used when opening the Trove\n     */\n    constructor(address _rollupProcessor, uint256 _initialICRPerc)\n        BridgeBase(_rollupProcessor)\n        ERC20(\"TroveBridge\", string(abi.encodePacked(\"TB-\", _initialICRPerc.toString())))\n    {\n        INITIAL_ICR = _initialICRPerc * 1e16;\n        _mint(address(this), DUST);\n        // Registering the bridge for subsidy\n        uint256[] memory criteria = new uint256[](2);\n        uint32[] memory gasUsage = new uint32[](2);\n        uint32[] memory minGasPerMinute = new uint32[](2);\n        criteria[0] = 0; // Borrow flow\n        criteria[1] = 1; // Repay/redeem flow\n        gasUsage[0] = 520000;\n        gasUsage[1] = 410000;\n        // This is approximately 520k / (24 * 60) / 2 --> targeting 1 full subsidized call per 2 days\n        minGasPerMinute[0] = 180;\n        // This is approximately 410k / (24 * 60) / 4 --> targeting 1 full subsidized call per 4 days\n        minGasPerMinute[1] = 70;\n        // We set gas usage and minGasPerMinute in the Subsidy contract\n        SUBSIDY.setGasUsageAndMinGasPerMinute(criteria, gasUsage, minGasPerMinute);\n    }\n    receive() external payable {}\n    fallback() external payable {}\n    /**\n     * @notice A function which opens the trove.\n     * @param _upperHint Address of a Trove with a position in the sorted list before the correct insert position.\n     * @param _lowerHint Address of a Trove with a position in the sorted list after the correct insert position.\n     * See https://github.com/liquity/dev#supplying-hints-to-trove-operations for more details about hints.\n     * @param _maxFee Maximum borrower fee.\n     * @dev Sufficient amount of ETH has to be send so that at least 2000 LUSD gets borrowed. 2000 LUSD is a minimum\n     * amount allowed by Liquity.\n     */\n    function openTrove(\n        address _upperHint,\n        address _lowerHint,\n        uint256 _maxFee\n    ) external payable onlyOwner {\n        // Checks whether the trove can be safely opened/reopened\n        if (totalSupply() != 0) revert NonZeroTotalSupply();\n        if (!IERC20(LUSD).approve(ROLLUP_PROCESSOR, type(uint256).max)) revert ErrorLib.ApproveFailed(LUSD);\n        if (!this.approve(ROLLUP_PROCESSOR, type(uint256).max)) revert ErrorLib.ApproveFailed(address(this));\n        uint256 amtToBorrow = computeAmtToBorrow(msg.value);\n        (uint256 debtBefore, , , ) = TROVE_MANAGER.getEntireDebtAndColl(address(this));\n        BORROWER_OPERATIONS.openTrove{value: msg.value}(_maxFee, amtToBorrow, _upperHint, _lowerHint);\n        (uint256 debtAfter, , , ) = TROVE_MANAGER.getEntireDebtAndColl(address(this));\n        IERC20(LUSD).transfer(msg.sender, IERC20(LUSD).balanceOf(address(this)) - DUST);\n        // I mint TB token to msg.sender to be able to track collateral ownership. Minted amount equals debt increase.\n        _mint(msg.sender, debtAfter - debtBefore);\n    }\n    /**\n     * @notice A function which allows interaction with this bridge's trove from within Aztec Connect.\n     * @dev This method can only be called from the RollupProcessor.sol. If the input asset is ETH, borrowing flow is\n     * executed. If TB, repaying. RollupProcessor.sol has to transfer the tokens to the bridge before calling\n     * the method. If this is not the case, the function will revert.\n     *\n     *                            Borrowing        | Repaying        | Repaying (redis.)| Repay. (coll.)| Redeeming\n     * @param _inputAssetA -      ETH              | TB              | TB               | TB            | TB\n     * @param _inputAssetB -      None             | LUSD            | LUSD             | None          | None\n     * @param _outputAssetA -     TB               | ETH             | ETH              | ETH           | ETH\n     * @param _outputAssetB -     LUSD             | LUSD            | TB               | None          | None\n     * @param _totalInputValue -  ETH amount       | TB and LUSD amt.| TB and LUSD amt. | TB amount     | TB amount\n     * @param _interactionNonce - nonce            | nonce           | nonce            | nonce         | nonce\n     * @param _auxData -          max borrower fee | 0               | max ETH price    | max ETH price | 0\n     * @param _rollupBeneficiary - Address which receives subsidy if the call is eligible for it\n     * @return outputValueA -     TB amount        | ETH amount      | ETH amount       | ETH amount    | ETH amount\n     * @return outputValueB -     LUSD amount      | LUSD amount     | TB amount        | 0             | 0\n     * @dev The amount of LUSD returned (outputValueB) during repayment will be non-zero only when the trove was\n     * partially redeemed.\n     */\n    function convert(\n        AztecTypes.AztecAsset calldata _inputAssetA,\n        AztecTypes.AztecAsset calldata _inputAssetB,\n        AztecTypes.AztecAsset calldata _outputAssetA,\n        AztecTypes.AztecAsset calldata _outputAssetB,\n        uint256 _totalInputValue,\n        uint256 _interactionNonce,\n        uint64 _auxData,\n        address _rollupBeneficiary\n    )\n        external\n        payable\n        override(BridgeBase)\n        onlyRollup\n        returns (\n            uint256 outputValueA,\n            uint256 outputValueB,\n            bool\n        )\n    {\n        Status troveStatus = Status(TROVE_MANAGER.getTroveStatus(address(this)));\n        uint256 subsidyCriteria;\n        if (\n            _inputAssetA.assetType == AztecTypes.AztecAssetType.ETH &&\n            _outputAssetA.erc20Address == address(this) &&\n            _outputAssetB.erc20Address == LUSD\n        ) {\n            // Borrowing\n            if (troveStatus != Status.active) revert InvalidStatus(troveStatus);\n            (outputValueA, outputValueB) = _borrow(_totalInputValue, _auxData);\n            subsidyCriteria = 0;\n        } else if (\n            _inputAssetA.erc20Address == address(this) &&\n            _inputAssetB.erc20Address == LUSD &&\n            _outputAssetA.assetType == AztecTypes.AztecAssetType.ETH\n        ) {\n            // Repaying\n            if (troveStatus != Status.active) revert InvalidStatus(troveStatus);\n            if (_outputAssetB.erc20Address == LUSD) {\n                // A case when the trove was partially redeemed (1 TB corresponding to less than 1 LUSD of debt) or not\n                // redeemed and not touched by redistribution (1 TB corresponding to exactly 1 LUSD of debt)\n                (outputValueA, outputValueB) = _repay(_totalInputValue, _interactionNonce);\n            } else if (_outputAssetB.erc20Address == address(this)) {\n                // A case when the trove was touched by redistribution (1 TB corresponding to more than 1 LUSD of\n                // debt). For this reason it was impossible to provide enough LUSD on input since it's not currently\n                // allowed to have different input token amounts. Swap part of the collateral to be able to repay\n                // the debt in full.\n                (outputValueA, outputValueB) = _repayWithCollateral(\n                    _totalInputValue,\n                    _auxData,\n                    _interactionNonce,\n                    true\n                );\n            } else {\n                revert ErrorLib.InvalidOutputB();\n            }\n            subsidyCriteria = 1;\n        } else if (\n            _inputAssetA.erc20Address == address(this) && _outputAssetA.assetType == AztecTypes.AztecAssetType.ETH\n        ) {\n            if (troveStatus == Status.active) {\n                // Repaying debt with collateral (using flash swaps)\n                (outputValueA, ) = _repayWithCollateral(_totalInputValue, _auxData, _interactionNonce, false);\n            } else if (troveStatus == Status.closedByRedemption || troveStatus == Status.closedByLiquidation) {\n                // Redeeming remaining collateral after the Trove is closed\n                outputValueA = _redeem(_totalInputValue, _interactionNonce);\n            } else {\n                revert InvalidStatus(troveStatus);\n            }\n            subsidyCriteria = 1;\n        } else {\n            revert ErrorLib.InvalidInput();\n        }\n        SUBSIDY.claimSubsidy(subsidyCriteria, _rollupBeneficiary);\n    }\n    /**\n     * @notice A function which closes the trove.\n     * @dev LUSD allowance has to be at least (remaining debt - 200 LUSD).\n     */\n    function closeTrove() external onlyOwner {\n        address payable owner = payable(owner());\n        uint256 ownerTBBalance = balanceOf(owner);\n        if (ownerTBBalance != totalSupply()) revert OwnerNotLast();\n        _burn(owner, ownerTBBalance);\n        Status troveStatus = Status(TROVE_MANAGER.getTroveStatus(address(this)));\n        if (troveStatus == Status.active) {\n            (uint256 remainingDebt, , , ) = TROVE_MANAGER.getEntireDebtAndColl(address(this));\n            // 200e18 is a part of debt which gets repaid from LUSD_GAS_COMPENSATION.\n            if (!IERC20(LUSD).transferFrom(owner, address(this), remainingDebt - 200e18)) {\n                revert ErrorLib.TransferFailed(LUSD);\n            }\n            BORROWER_OPERATIONS.closeTrove();\n        } else if (troveStatus == Status.closedByRedemption || troveStatus == Status.closedByLiquidation) {\n            if (!collateralClaimed) {\n                BORROWER_OPERATIONS.claimCollateral();\n            } else {\n                collateralClaimed = false;\n            }\n        }\n        owner.transfer(address(this).balance);\n    }\n    // @inheritdoc IUniswapV3SwapCallback\n    // @dev See _repayWithCollateral(...) method for more information about how this callback is entered.\n    function uniswapV3SwapCallback(\n        int256 _amount0Delta,\n        int256 _amount1Delta,\n        bytes calldata _data\n    ) external override(IUniswapV3SwapCallback) {\n        // Swaps entirely within 0-liquidity regions are not supported\n        if (_amount0Delta <= 0 && _amount1Delta <= 0) revert InvalidDeltaAmounts();\n        // Uniswap pools always call callback on msg.sender so this check is enough to prevent malicious behavior\n        if (msg.sender == LUSD_USDC_POOL) {\n            SwapCallbackData memory data = abi.decode(_data, (SwapCallbackData));\n            // Repay debt in full\n            (address upperHint, address lowerHint) = _getHints();\n            BORROWER_OPERATIONS.adjustTrove(0, data.collToWithdraw, data.debtToRepay, false, upperHint, lowerHint);\n            // Pay LUSD_USDC_POOL for the swap by passing it as a recipient to the next swap (WETH -> USDC)\n            IUniswapV3PoolActions(USDC_ETH_POOL).swap(\n                LUSD_USDC_POOL, // recipient\n                false, // zeroForOne\n                -_amount1Delta, // amount of USDC to pay to LUSD_USDC_POOL for the swap\n                SQRT_PRICE_LIMIT_X96,\n                \"\"\n            );\n        } else if (msg.sender == USDC_ETH_POOL) {\n            // Pay USDC_ETH_POOL for the USDC\n            uint256 amountToPay = uint256(_amount1Delta);\n            IWETH(WETH).deposit{value: amountToPay}(); // wrap only what is needed to pay\n            IWETH(WETH).transfer(address(USDC_ETH_POOL), amountToPay);\n        } else {\n            revert ErrorLib.InvalidCaller();\n        }\n    }\n    /**\n     * @notice Compute how much LUSD to borrow against collateral in order to keep ICR constant and by how much total\n     * trove debt will increase.\n     * @param _collateral Amount of ETH denominated in Wei\n     * @return amtToBorrow Amount of LUSD to borrow to keep ICR constant.\n     * + borrowing fee)\n     * @dev I don't use view modifier here because the function updates PriceFeed state.\n     *\n     * Since the Trove opening and adjustment processes have desired amount of LUSD to borrow on the input and not\n     * the desired ICR I have to do the computation of borrowing fee \"backwards\". Here are the operations I did in order\n     * to get the final formula:\n     *      1) debtIncrease = amtToBorrow + amtToBorrow * BORROWING_RATE / DECIMAL_PRECISION + 200LUSD\n     *      2) debtIncrease - 200LUSD = amtToBorrow * (1 + BORROWING_RATE / DECIMAL_PRECISION)\n     *      3) amtToBorrow = (debtIncrease - 200LUSD) / (1 + BORROWING_RATE / DECIMAL_PRECISION)\n     *      4) amtToBorrow = (debtIncrease - 200LUSD) * DECIMAL_PRECISION / (DECIMAL_PRECISION + BORROWING_RATE)\n     * Note1: For trove adjustments (not opening) remove the 200 LUSD fee compensation from the formulas above.\n     * Note2: Step 4 is necessary to avoid loss of precision. BORROWING_RATE / DECIMAL_PRECISION was rounded to 0.\n     * Note3: The borrowing fee computation is on this line in Liquity code: https://github.com/liquity/dev/blob/cb583ddf5e7de6010e196cfe706bd0ca816ea40e/packages/contracts/contracts/TroveManager.sol#L1433\n     */\n    function computeAmtToBorrow(uint256 _collateral) public returns (uint256 amtToBorrow) {\n        uint256 price = TROVE_MANAGER.priceFeed().fetchPrice();\n        if (TROVE_MANAGER.getTroveStatus(address(this)) == 1) {\n            // Trove is active - use current ICR and not the initial one\n            uint256 icr = TROVE_MANAGER.getCurrentICR(address(this), price);\n            amtToBorrow = (_collateral * price) / icr;\n        } else {\n            // Trove is inactive - I will use initial ICR to compute debt\n            // 200e18 - 200 LUSD gas compensation to liquidators\n            amtToBorrow = (_collateral * price) / INITIAL_ICR - 200e18;\n        }\n        if (!TROVE_MANAGER.checkRecoveryMode(price)) {\n            // Liquity is not in recovery mode so borrowing fee applies\n            uint256 borrowingRate = TROVE_MANAGER.getBorrowingRateWithDecay();\n            amtToBorrow = (amtToBorrow * 1e18) / (borrowingRate + 1e18);\n        }\n    }\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view override(ERC20) returns (uint256) {\n        return super.totalSupply() - DUST;\n    }\n    /**\n     * @notice Borrow LUSD\n     * @param _collateral Amount of ETH denominated in Wei\n     * @param _maxFee Maximum borrowing fee\n     * @return tbMinted Amount of TB minted for borrower.\n     * @return lusdBorrowed Amount of LUSD borrowed.\n     */\n    function _borrow(uint256 _collateral, uint64 _maxFee) private returns (uint256 tbMinted, uint256 lusdBorrowed) {\n        lusdBorrowed = computeAmtToBorrow(_collateral); // LUSD amount to borrow\n        (uint256 debtBefore, , , ) = TROVE_MANAGER.getEntireDebtAndColl(address(this));\n        (address upperHint, address lowerHint) = _getHints();\n        BORROWER_OPERATIONS.adjustTrove{value: _collateral}(_maxFee, 0, lusdBorrowed, true, upperHint, lowerHint);\n        (uint256 debtAfter, , , ) = TROVE_MANAGER.getEntireDebtAndColl(address(this));\n        // tbMinted = amount of TB to mint = (debtIncrease [LUSD] / debtBefore [LUSD]) * tbTotalSupply\n        // debtIncrease = debtAfter - debtBefore\n        // In case no redistribution took place (TB/LUSD = 1) then debt_before = TB_total_supply\n        // and debt_increase amount of TB is minted.\n        // In case there was redistribution, 1 TB corresponds to more than 1 LUSD and the amount of TB minted\n        // will be lower than the amount of LUSD borrowed.\n        tbMinted = ((debtAfter - debtBefore) * totalSupply()) / debtBefore;\n        _mint(address(this), tbMinted);\n    }\n    /**\n     * @notice Repay debt.\n     * @param _tbAmount Amount of TB to burn.\n     * @param _interactionNonce Same as in convert(...) method.\n     * @return collateral Amount of collateral withdrawn.\n     * @return lusdReturned Amount of LUSD returned (non-zero only if the trove was partially redeemed)\n     */\n    function _repay(uint256 _tbAmount, uint256 _interactionNonce)\n        private\n        returns (uint256 collateral, uint256 lusdReturned)\n    {\n        (uint256 debtBefore, uint256 collBefore, , ) = TROVE_MANAGER.getEntireDebtAndColl(address(this));\n        // Compute how much debt to be repay\n        uint256 tbTotalSupply = totalSupply(); // SLOAD optimization\n        uint256 debtToRepay = (_tbAmount * debtBefore) / tbTotalSupply;\n        if (debtToRepay > _tbAmount) revert ErrorLib.InvalidOutputB();\n        // Compute how much collateral to withdraw\n        uint256 collToWithdraw = (_tbAmount * collBefore) / tbTotalSupply;\n        // Repay _totalInputValue of LUSD and withdraw collateral\n        (address upperHint, address lowerHint) = _getHints();\n        BORROWER_OPERATIONS.adjustTrove(0, collToWithdraw, debtToRepay, false, upperHint, lowerHint);\n        lusdReturned = _tbAmount - debtToRepay; // LUSD to return --> 0 unless trove was partially redeemed\n        // Burn input TB and return ETH to rollup processor\n        collateral = address(this).balance;\n        _burn(address(this), _tbAmount);\n        IRollupProcessor(ROLLUP_PROCESSOR).receiveEthFromBridge{value: collateral}(_interactionNonce);\n    }\n    /**\n     * @notice Repay debt by selling part of the collateral for LUSD.\n     * @param _totalInputValue Amount of TB to burn (and input LUSD to use for repayment if `_lusdInput` param is set\n     *                         to true).\n     * @param _maxPrice Maximum acceptable price of LUSD denominated in ETH.\n     * @param _interactionNonce Same as in convert(...) method.\n     * @param _lusdInput If true the debt will be covered by both the LUSD on input and by selling part of the\n     *                   collateral. If false the debt will be covered only by selling the collateral.\n     * @return collateralReturned Amount of collateral withdrawn.\n     * @return tbReturned Amount of TB returned (non-zero only when the flash swap fails)\n     * @dev It's important that CR never drops because if the trove was near minimum CR (MCR) the tx would revert.\n     *      This would effectively stop users from being able to exit. Unfortunately users are also not able\n     *      to exit when Liquity is in recovery mode (total collateral ratio < 150%) because in such a case\n     *      only pure collateral top-up or debt repayment is allowed.\n     *      To avoid CR from ever dropping bellow MCR I came up with the following construction:\n     *        1) Flash swap USDC to LUSD,\n     *        2) repay the user's trove debt in full (in the 1st callback),\n     *        3) flash swap WETH to USDC with recipient being the LUSD_USDC_POOL - this pays for the first swap,\n     *        4) in the 2nd callback deposit part of the withdrawn collateral to WETH and pay for the 2nd swap.\n     *      In case the flash swap fails only a part of the debt gets repaid and the remaining TB balance corresponding\n     *      to the unpaid debt gets returned.\n     *      Note: Since owner is not able to exit until all the TB of everyone else gets burned his funds will be\n     *      stuck forever unless the Uniswap pools recover.\n     */\n    function _repayWithCollateral(\n        uint256 _totalInputValue,\n        uint256 _maxPrice,\n        uint256 _interactionNonce,\n        bool _lusdInput\n    ) private returns (uint256 collateralReturned, uint256 tbReturned) {\n        (uint256 debtBefore, uint256 collBefore, , ) = TROVE_MANAGER.getEntireDebtAndColl(address(this));\n        // Compute how much debt to be repay\n        uint256 tbTotalSupply = totalSupply(); // SLOAD optimization\n        uint256 debtToRepay = (_totalInputValue * debtBefore) / tbTotalSupply;\n        uint256 collToWithdraw = (_totalInputValue * collBefore) / tbTotalSupply;\n        uint256 lusdToBuy;\n        if (_lusdInput) {\n            // Reverting here because an incorrect flow has been chosen --> there is no reason to be using flash swaps\n            // when the amount of LUSD on input is enough to cover the debt\n            if (debtToRepay <= _totalInputValue) revert ErrorLib.InvalidOutputB();\n            uint256 lusdToBuy = debtToRepay - _totalInputValue;\n        } else {\n            lusdToBuy = debtToRepay;\n        }\n\n        // Saving a balance to a local variable to later get a `collateralReturned` value unaffected by a previously\n        // held balance --> This is important because if we set `collateralReturned` to `address(this).balance`\n        // the value might be larger than `collToWithdraw` which could cause underflow when computing `collateralSold`\n        uint256 ethBalanceBeforeSwap = address(this).balance;\n\n        (bool success, ) = LUSD_USDC_POOL.call(\n            abi.encodeWithSignature(\n                \"swap(address,bool,int256,uint160,bytes)\",\n\n    \n        \n          \n    \n\n        \n        Expand All\n    \n    @@ -489,7 +494,7 @@ contract TroveBridge is BridgeBase, ERC20, Ownable, IUniswapV3SwapCallback {\n  \n                address(this), // recipient\n                false, // zeroForOne\n                -int256(lusdToBuy),\n                SQRT_PRICE_LIMIT_X96,\n                abi.encode(SwapCallbackData({debtToRepay: debtToRepay, collToWithdraw: collToWithdraw}))\n            )\n        );\n\n        if (success) {\n            // Note: Debt repayment took place in the `uniswapV3SwapCallback(...)` function\n            collateralReturned = address(this).balance - ethBalanceBeforeSwap;\n\n            {\n                // Check that at most `maxCost` of ETH collateral was sold for `debtToRepay` worth of LUSD\n\n    \n          \n            \n    \n\n          \n          Expand Down\n    \n    \n  \n                uint256 maxCost = (lusdToBuy * _maxPrice) / PRECISION;\n                uint256 collateralSold = collToWithdraw - collateralReturned;\n                if (collateralSold > maxCost) revert MaxCostExceeded();\n            }\n            // Burn all input TB\n            _burn(address(this), _totalInputValue);\n        } else if (_lusdInput) {\n            // Flash swap failed and some LUSD was provided on input --> repay as much debt as you can with current\n            // LUSD balance and return the remaining TB\n            debtToRepay = _totalInputValue;\n            uint256 tbToBurn = (debtToRepay * tbTotalSupply) / debtBefore;\n            collToWithdraw = (tbToBurn * collBefore) / tbTotalSupply;\n            {\n                // Repay _totalInputValue of LUSD and withdraw collateral\n                (address upperHint, address lowerHint) = _getHints();\n                BORROWER_OPERATIONS.adjustTrove(0, collToWithdraw, debtToRepay, false, upperHint, lowerHint);\n            }\n            tbReturned = _totalInputValue - tbToBurn;\n            _burn(address(this), tbToBurn);\n            collateralReturned = address(this).balance;\n        } else {\n            revert SwapFailed();\n        }\n        // Return ETH to rollup processor\n        IRollupProcessor(ROLLUP_PROCESSOR).receiveEthFromBridge{value: collateralReturned}(_interactionNonce);\n    }\n    /**\n     * @notice Redeem collateral.\n     * @param _tbAmount Amount of TB to burn.\n     * @param _interactionNonce Same as in convert(...) method.\n     * @return collateral Amount of collateral withdrawn.\n     */\n    function _redeem(uint256 _tbAmount, uint256 _interactionNonce) private returns (uint256 collateral) {\n        if (!collateralClaimed) {\n            BORROWER_OPERATIONS.claimCollateral();\n            collateralClaimed = true;\n        }\n        collateral = (address(this).balance * _tbAmount) / totalSupply();\n        _burn(address(this), _tbAmount);\n        IRollupProcessor(ROLLUP_PROCESSOR).receiveEthFromBridge{value: collateral}(_interactionNonce);\n    }\n    /**\n     * @notice Get lower and upper insertion hints.\n     * @return upperHint Upper insertion hint.\n     * @return lowerHint Lower insertion hint.\n     * @dev See https://github.com/liquity/dev#supplying-hints-to-trove-operations for more details on hints.\n     */\n    function _getHints() private view returns (address upperHint, address lowerHint) {\n        return (SORTED_TROVES.getPrev(address(this)), SORTED_TROVES.getNext(address(this)));\n    }\n}"
    },
    {
        "tag": "arithmetic",
        "url": "https://github.com/ethereum/solidity-examples/commit/82a5397467b5348e569301b89963a73991381d2e",
        "file": "src/unsafe/Memory.sol",
        "before": "pragma solidity ^0.4.16;\npragma experimental \"v0.5.0\";\npragma experimental \"ABIEncoderV2\";\nlibrary Memory {\n    // Size of a word, in bytes.\n    uint internal constant WORD_SIZE = 32;\n    // Size of the header of a 'bytes' array.\n    uint internal constant BYTES_HEADER_SIZE = 32;\n    // Address of the free memory pointer.\n    uint internal constant FREE_MEM_PTR = 0x40;\n    // Compares the 'len' bytes starting at address 'addr' in memory with the 'len'\n    // bytes starting at 'addr2'.\n    // Returns 'true' if the bytes are the same, otherwise 'false'.\n    function equals(uint addr, uint addr2, uint len) internal pure returns (bool equal) {\n        assembly {\n            equal := eq(keccak256(addr, len), keccak256(addr2, len))\n        }\n    }\n    // Compares the 'len' bytes starting at address 'addr' in memory with the bytes stored in\n    // 'bts'. It is allowed to set 'len' to a lower value then 'bts.length', in which case only\n    // the first 'len' bytes will be compared.\n    // Requires that 'bts.length >= len'\n    function equals(uint addr, uint len, bytes memory bts) internal pure returns (bool equal) {\n        require(bts.length >= len);\n        uint addr2;\n        assembly {\n            addr2 := add(bts, /*BYTES_HEADER_SIZE*/32)\n        }\n        return equals(addr, addr2, len);\n    }\n    // Allocates 'numBytes' bytes in memory. This will prevent the Solidity compiler\n    // from using this area of memory. It will also initialize the area by setting\n    // each byte to '0'.\n    function allocate(uint numBytes) internal pure returns (uint addr) {\n        // Take the current value of the free memory pointer, and update.\n        assembly {\n            addr := mload(/*FREE_MEM_PTR*/0x40)\n            mstore(/*FREE_MEM_PTR*/0x40, add(addr, numBytes))\n        }\n        uint words = (numBytes + WORD_SIZE - 1) / WORD_SIZE;\n        for (uint i = 0; i < words; i++) {\n            assembly {\n                mstore(add(addr, mul(i, /*WORD_SIZE*/32)), 0)\n            }\n        }\n    }\n    // Copy 'len' bytes from memory address 'src', to address 'dest'.\n    // This function does not check the or destination, it only copies\n    // the bytes.\n    function copy(uint src, uint dest, uint len) internal pure {\n        // Copy word-length chunks while possible\n        for (; len >= WORD_SIZE; len -= WORD_SIZE) {\n            assembly {\n                mstore(dest, mload(src))\n            }\n            dest += WORD_SIZE;\n            src += WORD_SIZE;\n        }\n\n        // Copy remaining bytes\n        uint mask = 256 ** (WORD_SIZE - len) - 1;\n        assembly {\n\n    \n          \n            \n    \n\n          \n          Expand Down\n    \n    \n  \n            let srcpart := and(mload(src), not(mask))\n            let destpart := and(mload(dest), mask)\n            mstore(dest, or(destpart, srcpart))\n        }\n    }\n    // Returns a memory pointer to the provided bytes array.\n    function ptr(bytes memory bts) internal pure returns (uint addr) {\n        assembly {\n            addr := bts\n        }\n    }\n    // Returns a memory pointer to the data portion of the provided bytes array.\n    function dataPtr(bytes memory bts) internal pure returns (uint addr) {\n        assembly {\n            addr := add(bts, /*BYTES_HEADER_SIZE*/32)\n        }\n    }\n    // This function does the same as 'dataPtr(bytes memory)', but will also return the\n    // length of the provided bytes array.\n    function fromBytes(bytes memory bts) internal pure returns (uint addr, uint len) {\n        len = bts.length;\n        assembly {\n            addr := add(bts, /*BYTES_HEADER_SIZE*/32)\n        }\n    }\n    // Creates a 'bytes memory' variable from the memory address 'addr', with the\n    // length 'len'. The function will allocate new memory for the bytes array, and\n    // the 'len bytes starting at 'addr' will be copied into that new memory.\n    function toBytes(uint addr, uint len) internal pure returns (bytes memory bts) {\n        bts = new bytes(len);\n        uint btsptr;\n        assembly {\n            btsptr := add(bts, /*BYTES_HEADER_SIZE*/32)\n        }\n        copy(addr, btsptr, len);\n    }\n    // Get the word stored at memory address 'addr' as a 'uint'.\n    function toUint(uint addr) internal pure returns (uint n) {\n        assembly {\n            n := mload(addr)\n        }\n    }\n    // Get the word stored at memory address 'addr' as a 'bytes32'.\n    function toBytes32(uint addr) internal pure returns (bytes32 bts) {\n        assembly {\n            bts := mload(addr)\n        }\n    }\n    /*\n    // Get the byte stored at memory address 'addr' as a 'byte'.\n    function toByte(uint addr, uint8 index) internal pure returns (byte b) {\n        require(index < WORD_SIZE);\n        uint8 n;\n        assembly {\n            n := byte(index, mload(addr))\n        }\n        b = byte(n);\n    }\n    */\n}",
        "after": "pragma solidity ^0.4.16;\npragma experimental \"v0.5.0\";\npragma experimental \"ABIEncoderV2\";\nlibrary Memory {\n    // Size of a word, in bytes.\n    uint internal constant WORD_SIZE = 32;\n    // Size of the header of a 'bytes' array.\n    uint internal constant BYTES_HEADER_SIZE = 32;\n    // Address of the free memory pointer.\n    uint internal constant FREE_MEM_PTR = 0x40;\n    // Compares the 'len' bytes starting at address 'addr' in memory with the 'len'\n    // bytes starting at 'addr2'.\n    // Returns 'true' if the bytes are the same, otherwise 'false'.\n    function equals(uint addr, uint addr2, uint len) internal pure returns (bool equal) {\n        assembly {\n            equal := eq(keccak256(addr, len), keccak256(addr2, len))\n        }\n    }\n    // Compares the 'len' bytes starting at address 'addr' in memory with the bytes stored in\n    // 'bts'. It is allowed to set 'len' to a lower value then 'bts.length', in which case only\n    // the first 'len' bytes will be compared.\n    // Requires that 'bts.length >= len'\n    function equals(uint addr, uint len, bytes memory bts) internal pure returns (bool equal) {\n        require(bts.length >= len);\n        uint addr2;\n        assembly {\n            addr2 := add(bts, /*BYTES_HEADER_SIZE*/32)\n        }\n        return equals(addr, addr2, len);\n    }\n    // Allocates 'numBytes' bytes in memory. This will prevent the Solidity compiler\n    // from using this area of memory. It will also initialize the area by setting\n    // each byte to '0'.\n    function allocate(uint numBytes) internal pure returns (uint addr) {\n        // Take the current value of the free memory pointer, and update.\n        assembly {\n            addr := mload(/*FREE_MEM_PTR*/0x40)\n            mstore(/*FREE_MEM_PTR*/0x40, add(addr, numBytes))\n        }\n        uint words = (numBytes + WORD_SIZE - 1) / WORD_SIZE;\n        for (uint i = 0; i < words; i++) {\n            assembly {\n                mstore(add(addr, mul(i, /*WORD_SIZE*/32)), 0)\n            }\n        }\n    }\n    // Copy 'len' bytes from memory address 'src', to address 'dest'.\n    // This function does not check the or destination, it only copies\n    // the bytes.\n    function copy(uint src, uint dest, uint len) internal pure {\n        // Copy word-length chunks while possible\n        for (; len >= WORD_SIZE; len -= WORD_SIZE) {\n            assembly {\n                mstore(dest, mload(src))\n            }\n            dest += WORD_SIZE;\n            src += WORD_SIZE;\n        }\n\n        if (len == 0) return;\n\n        // Copy remaining bytes\n        uint mask = 256 ** (WORD_SIZE - len) - 1;\n        assembly {\n\n    \n          \n            \n    \n\n          \n          Expand Down\n    \n    \n  \n            let srcpart := and(mload(src), not(mask))\n            let destpart := and(mload(dest), mask)\n            mstore(dest, or(destpart, srcpart))\n        }\n    }\n    // Returns a memory pointer to the provided bytes array.\n    function ptr(bytes memory bts) internal pure returns (uint addr) {\n        assembly {\n            addr := bts\n        }\n    }\n    // Returns a memory pointer to the data portion of the provided bytes array.\n    function dataPtr(bytes memory bts) internal pure returns (uint addr) {\n        assembly {\n            addr := add(bts, /*BYTES_HEADER_SIZE*/32)\n        }\n    }\n    // This function does the same as 'dataPtr(bytes memory)', but will also return the\n    // length of the provided bytes array.\n    function fromBytes(bytes memory bts) internal pure returns (uint addr, uint len) {\n        len = bts.length;\n        assembly {\n            addr := add(bts, /*BYTES_HEADER_SIZE*/32)\n        }\n    }\n    // Creates a 'bytes memory' variable from the memory address 'addr', with the\n    // length 'len'. The function will allocate new memory for the bytes array, and\n    // the 'len bytes starting at 'addr' will be copied into that new memory.\n    function toBytes(uint addr, uint len) internal pure returns (bytes memory bts) {\n        bts = new bytes(len);\n        uint btsptr;\n        assembly {\n            btsptr := add(bts, /*BYTES_HEADER_SIZE*/32)\n        }\n        copy(addr, btsptr, len);\n    }\n    // Get the word stored at memory address 'addr' as a 'uint'.\n    function toUint(uint addr) internal pure returns (uint n) {\n        assembly {\n            n := mload(addr)\n        }\n    }\n    // Get the word stored at memory address 'addr' as a 'bytes32'.\n    function toBytes32(uint addr) internal pure returns (bytes32 bts) {\n        assembly {\n            bts := mload(addr)\n        }\n    }\n    /*\n    // Get the byte stored at memory address 'addr' as a 'byte'.\n    function toByte(uint addr, uint8 index) internal pure returns (byte b) {\n        require(index < WORD_SIZE);\n        uint8 n;\n        assembly {\n            n := byte(index, mload(addr))\n        }\n        b = byte(n);\n    }\n    */\n}"
    },
    {
        "tag": "time manipulation",
        "url": "https://github.com/gnosis/pm-contracts/commit/81b40df2fe17dbcf1e4c65d7e2f946fed23cb351",
        "file": "contracts/Markets/StandardMarketWithPriceLogger.sol",
        "before": "pragma solidity 0.4.15;\nimport \"../Markets/StandardMarket.sol\";\ncontract StandardMarketWithPriceLogger is StandardMarket {\n    /*\n     *  Constants\n     */\n    uint8 public constant LONG = 1;\n    /*\n     *  Storage\n     */\n    uint public startDate;\n    uint public endDate;\n    uint public lastTrade;\n    uint public priceIntegral;\n    /*\n     *  Public functions\n     */\n    /// @dev Constructor validates and sets market properties\n    /// @param _creator Market creator\n    /// @param _eventContract Event contract\n    /// @param _marketMaker Market maker contract\n    /// @param _fee Market fee\n    /// @param _startDate Start date for price logging\n    function StandardMarketWithPriceLogger(address _creator, Event _eventContract, MarketMaker _marketMaker, uint24 _fee, uint _startDate)\n        public\n        StandardMarket(_creator, _eventContract, _marketMaker, _fee)\n    {\n        if (_startDate == 0)\n            startDate = now;\n        else {\n            // The earliest start date is the market creation date\n            require(startDate >= now);\n            startDate = _startDate;\n        }\n    }\n\n    \n          \n            \n    \n\n          \n          Expand Down\n    \n    \n  \n    /// @dev Allows market creator to close the markets by transferring all remaining outcome tokens to the creator\n    function close()\n        public\n    {\n        endDate = now;\n        super.close();\n    }\n    /// @dev Allows to buy outcome tokens from market maker\n    /// @param outcomeTokenIndex Index of the outcome token to buy\n    /// @param outcomeTokenCount Amount of outcome tokens to buy\n    /// @param maxCost The maximum cost in collateral tokens to pay for outcome tokens\n    /// @return Cost in collateral tokens\n    function buy(uint8 outcomeTokenIndex, uint outcomeTokenCount, uint maxCost)\n        public\n        returns (uint cost)\n    {\n        logPrice();\n        cost = super.buy(outcomeTokenIndex, outcomeTokenCount, maxCost);\n    }\n    /// @dev Allows to sell outcome tokens to market maker\n    /// @param outcomeTokenIndex Index of the outcome token to sell\n    /// @param outcomeTokenCount Amount of outcome tokens to sell\n    /// @param minProfit The minimum profit in collateral tokens to earn for outcome tokens\n    /// @return Profit in collateral tokens\n    function sell(uint8 outcomeTokenIndex, uint outcomeTokenCount, uint minProfit)\n        public\n        returns (uint profit)\n    {\n        logPrice();\n        profit = super.sell(outcomeTokenIndex, outcomeTokenCount, minProfit);\n    }\n    /// @dev Buys all outcomes, then sells all shares of selected outcome which were bought, keeping\n    ///      shares of all other outcome tokens.\n    /// @param outcomeTokenIndex Index of the outcome token to short sell\n    /// @param outcomeTokenCount Amount of outcome tokens to short sell\n    /// @param minProfit The minimum profit in collateral tokens to earn for short sold outcome tokens\n    /// @return Cost to short sell outcome in collateral tokens\n    function shortSell(uint8 outcomeTokenIndex, uint outcomeTokenCount, uint minProfit)\n        public\n        returns (uint cost)\n    {\n        logPrice();\n        cost = super.shortSell(outcomeTokenIndex, outcomeTokenCount, minProfit);\n    }\n    /// @dev Calculates average price for long tokens based on price integral\n    /// @return Average price for long tokens\n    function getAvgPrice()\n        public\n        returns (uint)\n    {\n        return priceIntegral / (now - startDate);\n    }\n    /*\n     *  Private functions\n     */\n    /// @dev Adds price integral since the last trade to the total price integral and updates last\n    ///      trade timestamp\n    function logPrice()\n        private\n    {\n        if (now >= startDate) {\n            // Calculate price of long tokens\n            uint price = marketMaker.calcMarginalPrice(this, LONG);\n            if (lastTrade > 0)\n                priceIntegral += price * (now - lastTrade);\n            else\n                priceIntegral += price * (now - startDate);\n            lastTrade = now;\n        }\n    }\n}",
        "after": "pragma solidity 0.4.15;\nimport \"../Markets/StandardMarket.sol\";\ncontract StandardMarketWithPriceLogger is StandardMarket {\n    /*\n     *  Constants\n     */\n    uint8 public constant LONG = 1;\n    /*\n     *  Storage\n     */\n    uint public startDate;\n    uint public endDate;\n    uint public lastTrade;\n    uint public priceIntegral;\n    /*\n     *  Public functions\n     */\n    /// @dev Constructor validates and sets market properties\n    /// @param _creator Market creator\n    /// @param _eventContract Event contract\n    /// @param _marketMaker Market maker contract\n    /// @param _fee Market fee\n    /// @param _startDate Start date for price logging\n    function StandardMarketWithPriceLogger(address _creator, Event _eventContract, MarketMaker _marketMaker, uint24 _fee, uint _startDate)\n        public\n        StandardMarket(_creator, _eventContract, _marketMaker, _fee)\n    {\n        if (_startDate == 0)\n            startDate = now;\n        else {\n            // The earliest start date is the market creation date\n            require(_startDate >= now);\n            startDate = _startDate;\n        }\n    }\n\n    \n          \n            \n    \n\n          \n          Expand Down\n    \n    \n  \n    /// @dev Allows market creator to close the markets by transferring all remaining outcome tokens to the creator\n    function close()\n        public\n    {\n        endDate = now;\n        super.close();\n    }\n    /// @dev Allows to buy outcome tokens from market maker\n    /// @param outcomeTokenIndex Index of the outcome token to buy\n    /// @param outcomeTokenCount Amount of outcome tokens to buy\n    /// @param maxCost The maximum cost in collateral tokens to pay for outcome tokens\n    /// @return Cost in collateral tokens\n    function buy(uint8 outcomeTokenIndex, uint outcomeTokenCount, uint maxCost)\n        public\n        returns (uint cost)\n    {\n        logPrice();\n        cost = super.buy(outcomeTokenIndex, outcomeTokenCount, maxCost);\n    }\n    /// @dev Allows to sell outcome tokens to market maker\n    /// @param outcomeTokenIndex Index of the outcome token to sell\n    /// @param outcomeTokenCount Amount of outcome tokens to sell\n    /// @param minProfit The minimum profit in collateral tokens to earn for outcome tokens\n    /// @return Profit in collateral tokens\n    function sell(uint8 outcomeTokenIndex, uint outcomeTokenCount, uint minProfit)\n        public\n        returns (uint profit)\n    {\n        logPrice();\n        profit = super.sell(outcomeTokenIndex, outcomeTokenCount, minProfit);\n    }\n    /// @dev Buys all outcomes, then sells all shares of selected outcome which were bought, keeping\n    ///      shares of all other outcome tokens.\n    /// @param outcomeTokenIndex Index of the outcome token to short sell\n    /// @param outcomeTokenCount Amount of outcome tokens to short sell\n    /// @param minProfit The minimum profit in collateral tokens to earn for short sold outcome tokens\n    /// @return Cost to short sell outcome in collateral tokens\n    function shortSell(uint8 outcomeTokenIndex, uint outcomeTokenCount, uint minProfit)\n        public\n        returns (uint cost)\n    {\n        logPrice();\n        cost = super.shortSell(outcomeTokenIndex, outcomeTokenCount, minProfit);\n    }\n    /// @dev Calculates average price for long tokens based on price integral\n    /// @return Average price for long tokens\n    function getAvgPrice()\n        public\n        returns (uint)\n    {\n        return priceIntegral / (now - startDate);\n    }\n    /*\n     *  Private functions\n     */\n    /// @dev Adds price integral since the last trade to the total price integral and updates last\n    ///      trade timestamp\n    function logPrice()\n        private\n    {\n        if (now >= startDate) {\n            // Calculate price of long tokens\n            uint price = marketMaker.calcMarginalPrice(this, LONG);\n            if (lastTrade > 0)\n                priceIntegral += price * (now - lastTrade);\n            else\n                priceIntegral += price * (now - startDate);\n            lastTrade = now;\n        }\n    }\n}"
    },
    {
        "tag": "arithmetic",
        "url": "https://github.com/B2E2/b2e2_contracts/commit/945f267fac8f936b6d081556760a66cf8827e9ea",
        "file": "contracts/IdentityContract.sol",
        "before": "pragma solidity ^0.5.0;\nimport \"./IdentityContractLib.sol\";\ncontract IdentityContract {\n    // Events ERC-725\n    event DataChanged(bytes32 indexed key, bytes value);\n    event ContractCreated(address indexed contractAddress);\n    event OwnerChanged(address indexed ownerAddress);\n    \n    // Events ERC-735\n    event ClaimRequested(uint256 indexed claimRequestId, uint256 indexed topic, uint256 scheme, address indexed issuer, bytes signature, bytes data, string uri);\n    event ClaimAdded(uint256 indexed claimId, uint256 indexed topic, uint256 scheme, address indexed issuer, bytes signature, bytes data, string uri);\n    event ClaimRemoved(uint256 indexed claimId, uint256 indexed topic, uint256 scheme, address indexed issuer, bytes signature, bytes data, string uri);\n    event ClaimChanged(uint256 indexed claimId, uint256 indexed topic, uint256 scheme, address indexed issuer, bytes signature, bytes data, string uri);\n    \n    // Constants ERC-735\n    bytes constant public ETH_PREFIX = \"\\x19Ethereum Signed Message:\\n32\";\n    uint256 constant public ECDSA_SCHEME = 1;\n    \n    // Attributes ERC-725\n    address public owner;\n    mapping (bytes32 => bytes) public data;\n    \n    // Attributes ERC-735\n    mapping (uint256 => IdentityContractLib.Claim) claims;\n    mapping (uint256 => uint256[]) topics2ClaimIds;\n    mapping (bytes => bool) burnedSignatures;\n    // Other attributes\n    IdentityContract public marketAuthority;\n    constructor(IdentityContract _marketAuthority) public {\n        if(_marketAuthority == IdentityContract(0)) {\n            marketAuthority = this;\n        } else {\n            marketAuthority = _marketAuthority;\n        }\n        \n        owner = msg.sender;\n    }\n    \n    // Modifiers ERC-725\n    modifier onlyOwner {\n        require(msg.sender == owner);\n        _;\n    }\n    \n    // Functions ERC-725\n    function changeOwner(address _owner) public onlyOwner {\n        owner = _owner;\n        emit OwnerChanged(_owner);\n    }\n    \n    function getData(bytes32 _key) external view returns (bytes memory _value) {\n        return data[_key];\n    }\n    \n    function setData(bytes32 _key, bytes calldata _value) external onlyOwner {\n        data[_key] = _value;\n        emit DataChanged(_key, _value);\n    }\n    \n    function execute(uint256 _operationType, address _to, uint256 _value, bytes calldata _data) external onlyOwner {\n        if(_operationType == 0) {\n            (bool success, ) = _to.call.value(_value)(_data);\n            if(!success)\n                require(false);\n            return;\n        }\n        \n        // Copy calldata to memory so it can easily be accessed via assembly.\n        bytes memory dataMemory = _data;\n        \n        if(_operationType == 1) {\n            address newContract;\n            assembly {\n                newContract := create(0, add(dataMemory, 0x20), mload(dataMemory))\n            }\n            emit ContractCreated(newContract);\n            return;\n        }\n        \n        require(false);\n    }\n    \n    // Functions ERC-735\n    function getClaim(uint256 _claimId) public view returns(uint256 __topic, uint256 __scheme, address __issuer, bytes memory __signature, bytes memory __data, string memory __uri) {\n        __topic = claims[_claimId].topic;\n        __scheme = claims[_claimId].scheme;\n        __issuer = claims[_claimId].issuer;\n        __signature = claims[_claimId].signature;\n        __data = claims[_claimId].data;\n        __uri = claims[_claimId].uri;\n    }\n    \n    function getClaimIdsByTopic(uint256 _topic) public view returns(uint256[] memory claimIds) {\n        return topics2ClaimIds[_topic];\n    }\n    \n    function addClaim(uint256 _topic, uint256 _scheme, address _issuer, bytes memory _signature, bytes memory _data, string memory _uri) public returns (uint256 claimRequestId) {\n        return IdentityContractLib.addClaim(claims, topics2ClaimIds, burnedSignatures, marketAuthority, _topic, _scheme, _issuer, _signature, _data, _uri);\n    }\n\n    function removeClaim(uint256 _claimId) public returns (bool success) {\n        require(msg.sender == owner || msg.sender == claims[_claimId].issuer);\n\n\n    \n        \n          \n    \n\n        \n        Expand All\n    \n    @@ -116,10 +117,13 @@ contract IdentityContract {\n  \n        // Emit event and store burned signature before deleting to save gas for copy.\n        IdentityContractLib.Claim storage claim = claims[_claimId];\n        emit ClaimRemoved(_claimId, claim.topic, claim.scheme, claim.issuer, claim.signature, claim.data, claim.uri);\n        burnedSignatures[claim.signature] = true; // Make sure that this same claim cannot be added again.\n        // Delete entries of helper directories.\n        uint256[] memory arrayMem = topics2ClaimIds[claim.topic];\n        topics2ClaimIds[claim.topic].length = 0;\n        topics2ClaimIds[claim.topic].length = arrayMem.length - 1;\n        uint256[] memory arrayStor = topics2ClaimIds[claim.topic];\n        uint32 positionInArray = 0;\n        while(_claimId != arrayMem[positionInArray]) {\n            positionInArray++;\n        }\n\n        for(uint32 i = 0; i < positionInArray; i++) {\n            arrayStor[i] = arrayMem[i];\n        }\n\n    \n          \n            \n    \n\n          \n          Expand Down\n    \n    \n  \n        \n        for(uint32 i = positionInArray; i < arrayMem.length - 1; i++) {\n            arrayStor[i] = arrayMem[i+1];\n        }\n        \n        // Delete the actual directory entry.\n        claim.topic = 0;\n        claim.scheme = 0;\n        claim.issuer = address(0);\n        claim.signature = \"\";\n        claim.data = \"\";\n        claim.uri = \"\";\n        \n        return true;\n    }\n    \n    function claimAttributes2SigningFormat(address _subject, uint256 _topic, bytes memory _data) public pure returns (bytes32 __claimInSigningFormat) {\n        return keccak256(abi.encodePacked(_subject, _topic, _data));\n    }\n    \n    function getSignerAddress(bytes32 _claimInSigningFormat, bytes memory _signature) public pure returns (address __signer) {\n        return ECDSA.recover(keccak256(abi.encodePacked(ETH_PREFIX, _claimInSigningFormat)), _signature);\n    }\n    \n    function verifySignature(uint256 _topic, uint256 _scheme, address _issuer, bytes memory _signature, bytes memory _data) public view returns (bool __valid) {\n         // Check for currently unsupported signature.\n        if(_scheme != ECDSA_SCHEME)\n            return false;\n        \n        address signer = getSignerAddress(claimAttributes2SigningFormat(address(this), _topic, _data), _signature);\n        return signer == address(this) && _issuer == address(this);\n    }\n    \n}",
        "after": "pragma solidity ^0.5.0;\nimport \"./IdentityContractLib.sol\";\ncontract IdentityContract {\n    // Events ERC-725\n    event DataChanged(bytes32 indexed key, bytes value);\n    event ContractCreated(address indexed contractAddress);\n    event OwnerChanged(address indexed ownerAddress);\n    \n    // Events ERC-735\n    event ClaimRequested(uint256 indexed claimRequestId, uint256 indexed topic, uint256 scheme, address indexed issuer, bytes signature, bytes data, string uri);\n    event ClaimAdded(uint256 indexed claimId, uint256 indexed topic, uint256 scheme, address indexed issuer, bytes signature, bytes data, string uri);\n    event ClaimRemoved(uint256 indexed claimId, uint256 indexed topic, uint256 scheme, address indexed issuer, bytes signature, bytes data, string uri);\n    event ClaimChanged(uint256 indexed claimId, uint256 indexed topic, uint256 scheme, address indexed issuer, bytes signature, bytes data, string uri);\n    \n    // Constants ERC-735\n    bytes constant public ETH_PREFIX = \"\\x19Ethereum Signed Message:\\n32\";\n    uint256 constant public ECDSA_SCHEME = 1;\n    \n    // Attributes ERC-725\n    address public owner;\n    mapping (bytes32 => bytes) public data;\n    \n    // Attributes ERC-735\n    mapping (uint256 => IdentityContractLib.Claim) claims;\n    mapping (uint256 => uint256[]) topics2ClaimIds;\n    mapping (bytes => bool) burnedSignatures;\n    // Other attributes\n    IdentityContract public marketAuthority;\n    constructor(IdentityContract _marketAuthority) public {\n        if(_marketAuthority == IdentityContract(0)) {\n            marketAuthority = this;\n        } else {\n            marketAuthority = _marketAuthority;\n        }\n        \n        owner = msg.sender;\n    }\n    \n    // Modifiers ERC-725\n    modifier onlyOwner {\n        require(msg.sender == owner);\n        _;\n    }\n    \n    // Functions ERC-725\n    function changeOwner(address _owner) public onlyOwner {\n        owner = _owner;\n        emit OwnerChanged(_owner);\n    }\n    \n    function getData(bytes32 _key) external view returns (bytes memory _value) {\n        return data[_key];\n    }\n    \n    function setData(bytes32 _key, bytes calldata _value) external onlyOwner {\n        data[_key] = _value;\n        emit DataChanged(_key, _value);\n    }\n    \n    function execute(uint256 _operationType, address _to, uint256 _value, bytes calldata _data) external onlyOwner {\n        if(_operationType == 0) {\n            (bool success, ) = _to.call.value(_value)(_data);\n            if(!success)\n                require(false);\n            return;\n        }\n        \n        // Copy calldata to memory so it can easily be accessed via assembly.\n        bytes memory dataMemory = _data;\n        \n        if(_operationType == 1) {\n            address newContract;\n            assembly {\n                newContract := create(0, add(dataMemory, 0x20), mload(dataMemory))\n            }\n            emit ContractCreated(newContract);\n            return;\n        }\n        \n        require(false);\n    }\n    \n    // Functions ERC-735\n    function getClaim(uint256 _claimId) public view returns(uint256 __topic, uint256 __scheme, address __issuer, bytes memory __signature, bytes memory __data, string memory __uri) {\n        __topic = claims[_claimId].topic;\n        __scheme = claims[_claimId].scheme;\n        __issuer = claims[_claimId].issuer;\n        __signature = claims[_claimId].signature;\n        __data = claims[_claimId].data;\n        __uri = claims[_claimId].uri;\n    }\n    \n    function getClaimIdsByTopic(uint256 _topic) public view returns(uint256[] memory claimIds) {\n        return topics2ClaimIds[_topic];\n    }\n    \n    function addClaim(uint256 _topic, uint256 _scheme, address _issuer, bytes memory _signature, bytes memory _data, string memory _uri) public returns (uint256 claimRequestId) {\n        return IdentityContractLib.addClaim(claims, topics2ClaimIds, burnedSignatures, marketAuthority, _topic, _scheme, _issuer, _signature, _data, _uri);\n    }\n\n    // TODO: Move to library.\n    function removeClaim(uint256 _claimId) public returns (bool success) {\n        require(msg.sender == owner || msg.sender == claims[_claimId].issuer);\n\n\n    \n        \n          \n    \n\n        \n        Expand All\n    \n    @@ -116,10 +117,13 @@ contract IdentityContract {\n  \n        // Emit event and store burned signature before deleting to save gas for copy.\n        IdentityContractLib.Claim storage claim = claims[_claimId];\n        emit ClaimRemoved(_claimId, claim.topic, claim.scheme, claim.issuer, claim.signature, claim.data, claim.uri);\n        burnedSignatures[claim.signature] = true; // Make sure that this same claim cannot be added again.\n        // Delete entries of helper directories.\n        uint256[] memory arrayMem = topics2ClaimIds[claim.topic];\n        topics2ClaimIds[claim.topic].length = 0;\n        topics2ClaimIds[claim.topic].length = arrayMem.length - 1;\n        uint256[] memory arrayStor = topics2ClaimIds[claim.topic];\n        uint32 positionInArray = 0;\n        while(positionInArray < arrayMem.length && _claimId != arrayMem[positionInArray]) {\n            positionInArray++;\n        }\n\n        // Make sure that the element has actually been found.\n        require(positionInArray < arrayMem.length);\n\n        for(uint32 i = 0; i < positionInArray; i++) {\n            arrayStor[i] = arrayMem[i];\n        }\n\n    \n          \n            \n    \n\n          \n          Expand Down\n    \n    \n  \n        \n        for(uint32 i = positionInArray; i < arrayMem.length - 1; i++) {\n            arrayStor[i] = arrayMem[i+1];\n        }\n        \n        // Delete the actual directory entry.\n        claim.topic = 0;\n        claim.scheme = 0;\n        claim.issuer = address(0);\n        claim.signature = \"\";\n        claim.data = \"\";\n        claim.uri = \"\";\n        \n        return true;\n    }\n    \n    function claimAttributes2SigningFormat(address _subject, uint256 _topic, bytes memory _data) public pure returns (bytes32 __claimInSigningFormat) {\n        return keccak256(abi.encodePacked(_subject, _topic, _data));\n    }\n    \n    function getSignerAddress(bytes32 _claimInSigningFormat, bytes memory _signature) public pure returns (address __signer) {\n        return ECDSA.recover(keccak256(abi.encodePacked(ETH_PREFIX, _claimInSigningFormat)), _signature);\n    }\n    \n    function verifySignature(uint256 _topic, uint256 _scheme, address _issuer, bytes memory _signature, bytes memory _data) public view returns (bool __valid) {\n         // Check for currently unsupported signature.\n        if(_scheme != ECDSA_SCHEME)\n            return false;\n        \n        address signer = getSignerAddress(claimAttributes2SigningFormat(address(this), _topic, _data), _signature);\n        return signer == address(this) && _issuer == address(this);\n    }\n    \n}"
    },
    {
        "tag": "time manipulation",
        "url": "https://github.com/SoyFinance/smart-contracts/commit/f99cf5766e5704bebf9dccf42bcec4496aea0066",
        "file": "Farming/SOYGlobalFarm.sol",
        "before": "// SPDX-License-Identifier: No License (None)\npragma solidity ^0.8.0;\n/**\n * @title Ownable\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n * functions, this simplifies the implementation of \"user permissions\".\n *\n * Source https://raw.githubusercontent.com/OpenZeppelin/openzeppelin-solidity/v2.1.3/contracts/ownership/Ownable.sol\n * This contract is copied here and renamed from the original to avoid clashes in the compiled artifacts\n * when the user imports a zos-lib contract (that transitively causes this contract to be compiled and added to the\n * build/artifacts folder) as well as the vanilla Ownable implementation from an openzeppelin version.\n */\ncontract Ownable {\n    address private _owner;\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n    /**\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n     * account.\n     */\n    constructor () {\n        _owner = msg.sender;\n        emit OwnershipTransferred(address(0), _owner);\n    }\n    /**\n     * @return the address of the owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(isOwner(),\"Not Owner\");\n        _;\n    }\n    /**\n     * @return true if `msg.sender` is the owner of the contract.\n     */\n    function isOwner() public view returns (bool) {\n        return msg.sender == _owner;\n    }\n    /**\n     * @dev Allows the current owner to relinquish control of the contract.\n     * @notice Renouncing to ownership will leave the contract without an owner.\n     * It will not be possible to call the functions with the `onlyOwner`\n     * modifier anymore.\n     */\n    function renounceOwnership() public onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n    /**\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\n     * @param newOwner The address to transfer ownership to.\n     */\n    function transferOwnership(address newOwner) public onlyOwner {\n        _transferOwnership(newOwner);\n    }\n    /**\n     * @dev Transfers control of the contract to a newOwner.\n     * @param newOwner The address to transfer ownership to.\n     */\n    function _transferOwnership(address newOwner) internal {\n        require(newOwner != address(0),\"Zero address not allowed\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\ninterface IMintableToken {\n    function mint(address _to, uint256 _amount) external;\n}\ninterface ILocalFarm {\n    function notifyRewardAmount(uint256 reward) external;\n}\n\ncontract GlobalFarm is Ownable {\n    struct LocalFarm {\n        address farmAddress;\n        uint32  multiplier;\n    }\n\n    IMintableToken public rewardsToken;          // SOY token\n    uint256 public tokensPerYear = 50 * 10**6 * 10*18;  // 50M tokens\n    uint256 public totalMultipliers;\n    //LocalFarm[] public localFarms;               // local farms list\n\n    mapping(uint256 => LocalFarm) public localFarms;\n\n    \n        \n          \n    \n\n        \n        Expand All\n    \n    @@ -112,8 +115,12 @@ contract GlobalFarm is Ownable {\n  \n    uint256                       public lastAddedFarmIndex = 0; // Farm IDs will start from 1\n    \n    mapping(address => uint256)   public localFarmId;     // locals farm address => id; localFarm at ID = 0 is considered non-existing\n    mapping(address => uint256)   public nextMint; // timestamp when token may be minted to local farm\n    event AddLocalFarm(address _localFarm, uint32 _multiplier);\n    event RemoveLocalFarm(address _localFarm);\n    event ChangeMultiplier(address _localFarm, uint32 _oldMultiplier, uint32 _newMultiplier);\n    event ChangeTokenPerYear(uint256 oldAmount, uint256 newAmount);\n    constructor (address _rewardsToken) {\n        rewardsToken = IMintableToken(_rewardsToken);\n    }\n\n    function getLocalFarmId(address _localFarm) external view returns (uint256) {\n        return localFarmId[_localFarm];\n    }\n\n    function addLocalFarm(address _localFarmAddress, uint32 _multiplier) external onlyOwner {\n\n    \n        \n          \n    \n\n        \n        Expand All\n    \n    @@ -125,8 +132,10 @@ contract GlobalFarm is Ownable {\n  \n        require(localFarmId[_localFarmAddress] == 0,  \"LocalFarm with this address already exists\");\n        \n        // Increment last index before adding a farm.\n        // Farm with index = 0 is considered non-existing.\n        lastAddedFarmIndex++;\n\n        //localFarms.push(LocalFarm(_localFarm, _multiplier));\n\n        localFarms[lastAddedFarmIndex].farmAddress = _localFarmAddress;\n        localFarms[lastAddedFarmIndex].multiplier  = _multiplier;\n        localFarmId[_localFarmAddress]             = lastAddedFarmIndex;\n\n        totalMultipliers += uint256(_multiplier);\n\n    \n          \n            \n    \n\n          \n          Expand Down\n          \n            \n    \n\n          \n          Expand Up\n    \n    @@ -165,8 +174,9 @@ contract GlobalFarm is Ownable {\n  \n        \n        emit AddLocalFarm(_localFarmAddress, _multiplier);\n    }\n    function addLocalFarmAtID(address _localFarmAddress, uint256 _id, uint32 _multiplier) external onlyOwner {\n        require(localFarmId[_localFarmAddress] == 0,  \"LocalFarm with this address already exists\");\n        require(_id != 0,  \"LocalFarm at address 0 is considered non-existing by system\");\n        require(_id < lastAddedFarmIndex, \"Can not add farms ahead of autoincremented index\");\n        \n        // Increment last index before adding a farm.\n        \n        //localFarms.push(LocalFarm(_localFarm, _multiplier));\n        \n        localFarms[_id].farmAddress = _localFarmAddress;\n        localFarms[_id].multiplier  = _multiplier;\n        localFarmId[_localFarmAddress]             = _id;\n        \n        totalMultipliers += uint256(_multiplier);\n        \n        emit AddLocalFarm(_localFarmAddress, _multiplier);\n    }\n    \n    function farmExists(address _farmAddress) public view returns (bool _exists)\n    {\n        return (localFarmId[_farmAddress] != 0) && (localFarms[localFarmId[_farmAddress]].farmAddress != address(0));\n    }\n    function removeLocalFarmByAddress(address _localFarmAddress) external onlyOwner {\n        require (farmExists(_localFarmAddress), \"LocalFarm with this address does not exist\");\n        require (localFarmId[_localFarmAddress] != 0, \"LocalFarm with this address does not exist\"); \n        \n        totalMultipliers = totalMultipliers - uint256(localFarms[localFarmId[_localFarmAddress]].multiplier); // update totalMultipliers\n\n        //delete localFarmId[_localFarmAddress];\n\n        localFarms[localFarmId[_localFarmAddress]].farmAddress = address(0);\n        localFarms[localFarmId[_localFarmAddress]].multiplier  = 0;\n\n        localFarmId[_localFarmAddress] = 0;\n\n\n    \n        \n          \n    \n\n        \n        Expand All\n    \n    @@ -191,15 +201,49 @@ contract GlobalFarm is Ownable {\n  \n        emit RemoveLocalFarm(_localFarmAddress);\n    }\n    function changeMultiplier(address _localFarmAddress, uint32 _multiplier) external onlyOwner {\n        require (farmExists(_localFarmAddress), \"LocalFarm with this address does not exist\");\n        \n        uint32 oldMultiplier = localFarms[localFarmId[_localFarmAddress]].multiplier;\n        totalMultipliers = totalMultipliers + uint256(_multiplier) - uint256(oldMultiplier); // update totalMultipliers\n        localFarms[localFarmId[_localFarmAddress]].multiplier = _multiplier;\n        emit ChangeMultiplier(_localFarmAddress, oldMultiplier, _multiplier);\n    }\n    function changeTokenPerYear(uint256 newAmount) external onlyOwner {\n        uint256 oldAmount = tokensPerYear;\n        tokensPerYear = newAmount;\n        emit ChangeTokenPerYear(oldAmount, newAmount);\n    }\n\n    function mintFarmingReward(address _localFarmAddress, uint256 _period) external {\n        require (farmExists(_localFarmAddress), \"LocalFarm with this address does not exist\");\n        require (nextMint[_localFarmAddress] < block.timestamp);\n\n\n        uint256 amount = tokensPerYear * _period / 365 days; // for all farms\n        amount = amount * localFarms[localFarmId[_localFarmAddress]].multiplier / totalMultipliers; // amount per local farm\n\n        nextMint[_localFarmAddress] = nextMint[_localFarmAddress] + _period;\n\n        rewardsToken.mint(_localFarmAddress, amount);\n        ILocalFarm(_localFarmAddress).notifyRewardAmount(amount);\n    }\n}",
        "after": "// SPDX-License-Identifier: No License (None)\npragma solidity ^0.8.0;\n/**\n * @title Ownable\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n * functions, this simplifies the implementation of \"user permissions\".\n *\n * Source https://raw.githubusercontent.com/OpenZeppelin/openzeppelin-solidity/v2.1.3/contracts/ownership/Ownable.sol\n * This contract is copied here and renamed from the original to avoid clashes in the compiled artifacts\n * when the user imports a zos-lib contract (that transitively causes this contract to be compiled and added to the\n * build/artifacts folder) as well as the vanilla Ownable implementation from an openzeppelin version.\n */\ncontract Ownable {\n    address private _owner;\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n    /**\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n     * account.\n     */\n    constructor () {\n        _owner = msg.sender;\n        emit OwnershipTransferred(address(0), _owner);\n    }\n    /**\n     * @return the address of the owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(isOwner(),\"Not Owner\");\n        _;\n    }\n    /**\n     * @return true if `msg.sender` is the owner of the contract.\n     */\n    function isOwner() public view returns (bool) {\n        return msg.sender == _owner;\n    }\n    /**\n     * @dev Allows the current owner to relinquish control of the contract.\n     * @notice Renouncing to ownership will leave the contract without an owner.\n     * It will not be possible to call the functions with the `onlyOwner`\n     * modifier anymore.\n     */\n    function renounceOwnership() public onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n    /**\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\n     * @param newOwner The address to transfer ownership to.\n     */\n    function transferOwnership(address newOwner) public onlyOwner {\n        _transferOwnership(newOwner);\n    }\n    /**\n     * @dev Transfers control of the contract to a newOwner.\n     * @param newOwner The address to transfer ownership to.\n     */\n    function _transferOwnership(address newOwner) internal {\n        require(newOwner != address(0),\"Zero address not allowed\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\ninterface IMintableToken {\n    function mint(address _to, uint256 _amount) external;\n}\ninterface ILocalFarm {\n    function notifyRewardAmount(uint256 reward) external;\n}\n\ncontract GlobalFarm is Ownable {\n\n    struct LocalFarm {\n        address farmAddress;\n        uint32  multiplier;\n        uint256 lastMintTimestamp;\n    }\n\n    IMintableToken public rewardsToken;                 // SOY token\n    uint256 public tokensPerYear = 50 * 10**6 * 10*18;  // 50M tokens\n    uint256 public totalMultipliers;\n    uint256 public rewardDuration = 1 days;\n    //LocalFarm[] public localFarms;               // local farms list\n\n    mapping(uint256 => LocalFarm) public localFarms;\n\n    \n        \n          \n    \n\n        \n        Expand All\n    \n    @@ -112,8 +115,12 @@ contract GlobalFarm is Ownable {\n  \n    uint256                       public lastAddedFarmIndex = 0; // Farm IDs will start from 1\n    \n    mapping(address => uint256)   public localFarmId;     // locals farm address => id; localFarm at ID = 0 is considered non-existing\n    mapping(address => uint256)   public nextMint; // timestamp when token may be minted to local farm\n    event AddLocalFarm(address _localFarm, uint32 _multiplier);\n    event RemoveLocalFarm(address _localFarm);\n    event ChangeMultiplier(address _localFarm, uint32 _oldMultiplier, uint32 _newMultiplier);\n    event ChangeTokenPerYear(uint256 oldAmount, uint256 newAmount);\n    constructor (address _rewardsToken) {\n        rewardsToken = IMintableToken(_rewardsToken);\n    }\n\n    function getLocalFarmId(address _localFarmAddress) external view returns (uint256) {\n        return localFarmId[_localFarmAddress];\n    }\n\n    function getLastMintTimestamp(address _localFarmAddress) external view returns (uint256) {\n        return localFarms[localFarmId[_localFarmAddress]].lastMintTimestamp;\n    }\n\n    function addLocalFarm(address _localFarmAddress, uint32 _multiplier) external onlyOwner {\n\n    \n        \n          \n    \n\n        \n        Expand All\n    \n    @@ -125,8 +132,10 @@ contract GlobalFarm is Ownable {\n  \n        require(localFarmId[_localFarmAddress] == 0,  \"LocalFarm with this address already exists\");\n        \n        // Increment last index before adding a farm.\n        // Farm with index = 0 is considered non-existing.\n        lastAddedFarmIndex++;\n\n        //localFarms.push(LocalFarm(_localFarm, _multiplier));\n\n        localFarms[lastAddedFarmIndex].farmAddress       = _localFarmAddress;\n        localFarms[lastAddedFarmIndex].multiplier        = _multiplier;\n        localFarms[lastAddedFarmIndex].lastMintTimestamp = block.timestamp;\n\n        localFarmId[_localFarmAddress]             = lastAddedFarmIndex;\n\n        totalMultipliers += uint256(_multiplier);\n\n    \n          \n            \n    \n\n          \n          Expand Down\n          \n            \n    \n\n          \n          Expand Up\n    \n    @@ -165,8 +174,9 @@ contract GlobalFarm is Ownable {\n  \n        \n        emit AddLocalFarm(_localFarmAddress, _multiplier);\n    }\n    function addLocalFarmAtID(address _localFarmAddress, uint256 _id, uint32 _multiplier) external onlyOwner {\n        require(localFarmId[_localFarmAddress] == 0,  \"LocalFarm with this address already exists\");\n        require(_id != 0,  \"LocalFarm at address 0 is considered non-existing by system\");\n        require(_id < lastAddedFarmIndex, \"Can not add farms ahead of autoincremented index\");\n        \n        // Increment last index before adding a farm.\n        \n        //localFarms.push(LocalFarm(_localFarm, _multiplier));\n        \n        localFarms[_id].farmAddress = _localFarmAddress;\n        localFarms[_id].multiplier  = _multiplier;\n        localFarmId[_localFarmAddress]             = _id;\n        \n        totalMultipliers += uint256(_multiplier);\n        \n        emit AddLocalFarm(_localFarmAddress, _multiplier);\n    }\n    \n    function farmExists(address _farmAddress) public view returns (bool _exists)\n    {\n        return (localFarmId[_farmAddress] != 0) && (localFarms[localFarmId[_farmAddress]].farmAddress != address(0));\n    }\n    function removeLocalFarmByAddress(address _localFarmAddress) external onlyOwner {\n        require (farmExists(_localFarmAddress), \"LocalFarm with this address does not exist\");\n        require (localFarmId[_localFarmAddress] != 0, \"LocalFarm with this address does not exist\"); \n        \n        totalMultipliers = totalMultipliers - uint256(localFarms[localFarmId[_localFarmAddress]].multiplier); // update totalMultipliers\n\n        //delete localFarmId[_localFarmAddress];\n\n        localFarms[localFarmId[_localFarmAddress]].farmAddress        = address(0);\n        localFarms[localFarmId[_localFarmAddress]].multiplier         = 0; // Not critically important, can be removed for gas efficiency reasons.\n        localFarms[localFarmId[_localFarmAddress]].lastMintTimestamp  = 0; // Not critically important, can be removed for gas efficiency reasons.\n\n        localFarmId[_localFarmAddress] = 0;\n\n\n    \n        \n          \n    \n\n        \n        Expand All\n    \n    @@ -191,15 +201,49 @@ contract GlobalFarm is Ownable {\n  \n        emit RemoveLocalFarm(_localFarmAddress);\n    }\n    function changeMultiplier(address _localFarmAddress, uint32 _multiplier) external onlyOwner {\n        require (farmExists(_localFarmAddress), \"LocalFarm with this address does not exist\");\n        \n        uint32 oldMultiplier = localFarms[localFarmId[_localFarmAddress]].multiplier;\n        totalMultipliers = totalMultipliers + uint256(_multiplier) - uint256(oldMultiplier); // update totalMultipliers\n        localFarms[localFarmId[_localFarmAddress]].multiplier = _multiplier;\n        emit ChangeMultiplier(_localFarmAddress, oldMultiplier, _multiplier);\n    }\n    function changeTokenPerYear(uint256 newAmount) external onlyOwner {\n        uint256 oldAmount = tokensPerYear;\n        tokensPerYear = newAmount;\n        emit ChangeTokenPerYear(oldAmount, newAmount);\n    }\n\n    function mintFarmingReward(address _localFarmAddress, uint256 _period) external {\n        require (farmExists(_localFarmAddress), \"LocalFarm with this address does not exist\");\n        require (_period > 0, \"Cannot claim reward for a timeframe of 0 seconds\");\n        //require (nextMint[_localFarmAddress] < block.timestamp); // Can not place a \"requirement\" on auto-executable function.\n\n        if(localFarms[localFarmId[_localFarmAddress]].lastMintTimestamp + rewardDuration < block.timestamp)\n        {\n            // We should check if sufficient time since the last minting session passed for this Local Farm.\n\n            if(_period < block.timestamp - localFarms[localFarmId[_localFarmAddress]].lastMintTimestamp)\n            {\n                // Claiming for less-than-maximum period.\n                // This can be necessary if the contract stayed without claiming for too long\n                // and the accumulated reward can not be minted in one transaction.\n\n                // In this case this function `mintFarmingReward` can be manually claimed by a user multiple times\n                // in order to mint reward part-by-part.\n\n                // Last Mint Timestamp of the local farm must be updated to match the time preriod\n                // that user already claimed reward for.\n\n                localFarms[localFarmId[_localFarmAddress]].lastMintTimestamp += _period;\n            }\n            else\n            {\n                // Otherwise the reward is distributed for the total reward period duration,\n                // it is important to note that user can not cause the contract to print reward in the future.\n\n                _period = block.timestamp - localFarms[localFarmId[_localFarmAddress]].lastMintTimestamp;\n                localFarms[localFarmId[_localFarmAddress]].lastMintTimestamp = block.timestamp;\n            }\n\n            // Reward is then calculated based on the _period\n            // it can be either \"specified period\" or \"now - Local Farm's previous minting timestamp\".\n            uint256 amount = tokensPerYear * _period / 365 days; // for all farms\n            amount = amount * localFarms[localFarmId[_localFarmAddress]].multiplier / totalMultipliers; // amount per local farm\n\n            // Local farm is then notified about the reward minting session.\n            rewardsToken.mint(_localFarmAddress, amount);\n            ILocalFarm(_localFarmAddress).notifyRewardAmount(amount);\n        }\n\n        // Otherwise if the previous minting session occured recently and the time condition was not met\n        // this function does nothing. It should not revert execution\n        // because it is automatically called by Local Farms sometimes\n        // therefore the call will not fail but the minting will simply not happen.\n    }\n}"
    },
    {
        "tag": "arithmetic",
        "url": "https://github.com/transmissions11/solmate/commit/0384dbaaa4fcb5715738a9254a7c0a4cb62cf458",
        "file": "src/tokens/ERC6909.sol",
        "before": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n/// @notice Minimalist and gas efficient standard ERC6909 implementation.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC6909.sol)\nabstract contract ERC6909 {\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n    event OperatorSet(address indexed owner, address indexed operator, bool approved);\n\n    event Approval(address indexed owner, address indexed spender, uint256 indexed id, uint256 amount);\n    \n    event Transfer(address caller, address indexed from, address indexed to, uint256 indexed id, uint256 amount);\n\n    /*//////////////////////////////////////////////////////////////\n\n    \n          \n            \n    \n\n          \n          Expand Down\n          \n            \n    \n\n          \n          Expand Up\n    \n    @@ -111,12 +111,12 @@ abstract contract ERC6909 {\n  \n                             ERC6909 STORAGE\n    //////////////////////////////////////////////////////////////*/\n    mapping(uint256 => uint256) public totalSupply;\n    mapping(address => mapping(address => bool)) public isOperator;\n    mapping(address => mapping(uint256 => uint256)) public balanceOf;\n    mapping(address => mapping(address => mapping(uint256 => uint256))) public allowance;\n    /*//////////////////////////////////////////////////////////////\n                              ERC6909 LOGIC\n    //////////////////////////////////////////////////////////////*/\n    function transfer(\n        address receiver,\n        uint256 id,\n        uint256 amount\n    ) public virtual returns (bool) {\n        balanceOf[msg.sender][id] -= amount;\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[receiver][id] += amount;\n        }\n        emit Transfer(msg.sender, msg.sender, receiver, id, amount);\n        return true;\n    }\n    function transferFrom(\n        address sender,\n        address receiver,\n        uint256 id,\n        uint256 amount\n    ) public virtual returns (bool) {\n        if (msg.sender != sender && !isOperator[sender][msg.sender]) {\n            uint256 allowed = allowance[sender][msg.sender][id];\n            if (allowed != type(uint256).max) allowance[sender][msg.sender][id] = allowed - amount;\n        }\n        balanceOf[sender][id] -= amount;\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[receiver][id] += amount;\n        }\n        emit Transfer(msg.sender, sender, receiver, id, amount);\n        return true;\n    }\n    function approve(\n        address spender,\n        uint256 id,\n        uint256 amount\n    ) public virtual returns (bool) {\n        allowance[msg.sender][spender][id] = amount;\n        emit Approval(msg.sender, spender, id, amount);\n        return true;\n    }\n    function setOperator(address operator, bool approved) public virtual returns (bool) {\n        isOperator[msg.sender][operator] = approved;\n        emit OperatorSet(msg.sender, operator, approved);\n        return true;\n    }\n    /*//////////////////////////////////////////////////////////////\n                              ERC165 LOGIC\n    //////////////////////////////////////////////////////////////*/\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return\n            interfaceId == 0x01ffc9a7 || // ERC165 Interface ID for ERC165\n            interfaceId == 0xb2e69f8a; // ERC165 Interface ID for ERC6909\n    }\n    /*//////////////////////////////////////////////////////////////\n                        INTERNAL MINT/BURN LOGIC\n    //////////////////////////////////////////////////////////////*/\n    function _mint(\n        address receiver,\n        uint256 id,\n        uint256 amount\n    ) internal virtual {\n        balanceOf[receiver][id] += amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            totalSupply[id] += amount;\n        }\n\n        emit Transfer(msg.sender, address(0), receiver, id, amount);\n\n    \n          \n            \n    \n\n          \n          Expand Down\n    \n    \n  \n    }\n    function _burn(\n        address sender,\n        uint256 id,\n        uint256 amount\n    ) internal virtual {\n        balanceOf[sender][id] -= amount;\n        // Cannot underflow because a user's balance\n        // will never be larger than the total supply.\n        unchecked {\n            totalSupply[id] -= amount;\n        }\n        emit Transfer(msg.sender, sender, address(0), id, amount);\n    }\n}",
        "after": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n/// @notice Minimalist and gas efficient standard ERC6909 implementation.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC6909.sol)\nabstract contract ERC6909 {\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n    event OperatorSet(address indexed owner, address indexed operator, bool approved);\n\n    event Approval(address indexed owner, address indexed spender, uint256 indexed id, uint256 amount);\n\n    event Transfer(address caller, address indexed from, address indexed to, uint256 indexed id, uint256 amount);\n\n    /*//////////////////////////////////////////////////////////////\n\n    \n          \n            \n    \n\n          \n          Expand Down\n          \n            \n    \n\n          \n          Expand Up\n    \n    @@ -111,12 +111,12 @@ abstract contract ERC6909 {\n  \n                             ERC6909 STORAGE\n    //////////////////////////////////////////////////////////////*/\n    mapping(uint256 => uint256) public totalSupply;\n    mapping(address => mapping(address => bool)) public isOperator;\n    mapping(address => mapping(uint256 => uint256)) public balanceOf;\n    mapping(address => mapping(address => mapping(uint256 => uint256))) public allowance;\n    /*//////////////////////////////////////////////////////////////\n                              ERC6909 LOGIC\n    //////////////////////////////////////////////////////////////*/\n    function transfer(\n        address receiver,\n        uint256 id,\n        uint256 amount\n    ) public virtual returns (bool) {\n        balanceOf[msg.sender][id] -= amount;\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[receiver][id] += amount;\n        }\n        emit Transfer(msg.sender, msg.sender, receiver, id, amount);\n        return true;\n    }\n    function transferFrom(\n        address sender,\n        address receiver,\n        uint256 id,\n        uint256 amount\n    ) public virtual returns (bool) {\n        if (msg.sender != sender && !isOperator[sender][msg.sender]) {\n            uint256 allowed = allowance[sender][msg.sender][id];\n            if (allowed != type(uint256).max) allowance[sender][msg.sender][id] = allowed - amount;\n        }\n        balanceOf[sender][id] -= amount;\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[receiver][id] += amount;\n        }\n        emit Transfer(msg.sender, sender, receiver, id, amount);\n        return true;\n    }\n    function approve(\n        address spender,\n        uint256 id,\n        uint256 amount\n    ) public virtual returns (bool) {\n        allowance[msg.sender][spender][id] = amount;\n        emit Approval(msg.sender, spender, id, amount);\n        return true;\n    }\n    function setOperator(address operator, bool approved) public virtual returns (bool) {\n        isOperator[msg.sender][operator] = approved;\n        emit OperatorSet(msg.sender, operator, approved);\n        return true;\n    }\n    /*//////////////////////////////////////////////////////////////\n                              ERC165 LOGIC\n    //////////////////////////////////////////////////////////////*/\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return\n            interfaceId == 0x01ffc9a7 || // ERC165 Interface ID for ERC165\n            interfaceId == 0xb2e69f8a; // ERC165 Interface ID for ERC6909\n    }\n    /*//////////////////////////////////////////////////////////////\n                        INTERNAL MINT/BURN LOGIC\n    //////////////////////////////////////////////////////////////*/\n    function _mint(\n        address receiver,\n        uint256 id,\n        uint256 amount\n    ) internal virtual {\n        totalSupply[id] += amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[receiver][id] += amount;\n        }\n\n        emit Transfer(msg.sender, address(0), receiver, id, amount);\n\n    \n          \n            \n    \n\n          \n          Expand Down\n    \n    \n  \n    }\n    function _burn(\n        address sender,\n        uint256 id,\n        uint256 amount\n    ) internal virtual {\n        balanceOf[sender][id] -= amount;\n        // Cannot underflow because a user's balance\n        // will never be larger than the total supply.\n        unchecked {\n            totalSupply[id] -= amount;\n        }\n        emit Transfer(msg.sender, sender, address(0), id, amount);\n    }\n}"
    },
    {
        "tag": "reentrancy",
        "url": "https://github.com/sudoswap/lssvm/commit/39f39467b4370a707d93bd9b99fe6ab51e43d7e8",
        "file": "src/LSSVMPairERC20.sol",
        "before": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.0;\nimport {SafeTransferLib} from \"solmate/utils/SafeTransferLib.sol\";\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {IERC721} from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport {LSSVMPair} from \"./LSSVMPair.sol\";\nimport {LSSVMPairFactoryLike} from \"./LSSVMPairFactoryLike.sol\";\nimport {LSSVMRouter} from \"./LSSVMRouter.sol\";\nimport {ICurve} from \"./bonding-curves/ICurve.sol\";\nimport {CurveErrorCodes} from \"./bonding-curves/CurveErrorCodes.sol\";\n/**\n    @title An NFT/Token pair where the token is an ERC20\n    @author boredGenius and 0xmons\n */\nabstract contract LSSVMPairERC20 is LSSVMPair {\n    using SafeTransferLib for ERC20;\n    /**\n        @notice Returns the ERC20 token associated with the pair\n        @dev See LSSVMPairCloner for an explanation on how this works\n     */\n    function token() public pure returns (ERC20 _token) {\n        uint256 paramsLength = _immutableParamsLength();\n        assembly {\n            _token := shr(\n                0x60,\n                calldataload(add(sub(calldatasize(), paramsLength), 61))\n            )\n        }\n    }\n    /**\n        @notice Verifies and takes the correct amount of tokens needed for a swap\n        @param inputAmount The amount of tokens to be sent in\n        @param isRouter Whether or not the caller is LSSVMRouter\n        @param routerCaller If called from LSSVMRouter, store the original caller\n        @param _factory The LSSVMPairFactory which stores LSSVMRouter allowlist info\n     */\n    function _validateTokenInput(\n        uint256 inputAmount,\n        bool isRouter,\n        address routerCaller,\n        LSSVMPairFactoryLike _factory\n    ) internal override {\n        require(msg.value == 0, \"ERC20 pair\");\n        ERC20 _token = token();\n        address _assetRecipient = getAssetRecipient();\n        if (isRouter) {\n            // Verify if router is allowed\n            LSSVMRouter router = LSSVMRouter(payable(msg.sender));\n            require(_factory.routerAllowed(router), \"Not router\");\n\n            // Call router to transfer tokens from user\n            uint256 beforeBalance = _token.balanceOf(_assetRecipient);\n\n            router.pairTransferERC20From(\n                _token,\n                routerCaller,\n\n    \n        \n          \n    \n\n        \n        Expand All\n    \n    @@ -71,6 +71,10 @@ abstract contract LSSVMPairERC20 is LSSVMPair {\n  \n                _assetRecipient,\n                inputAmount,\n                pairVariant()\n            );\n            // Verify token transfer (protect pair against malicious router)\n            require(\n                _token.balanceOf(_assetRecipient) - beforeBalance ==\n                    inputAmount,\n                \"ERC20 not transferred in\"\n            );\n        } else {\n            // Transfer tokens directly\n            _token.safeTransferFrom(msg.sender, _assetRecipient, inputAmount);\n\n    \n          \n            \n    \n\n          \n          Expand Down\n    \n    \n  \n        }\n    }\n    /**\n        @notice Sends excess tokens back to the caller\n     */\n    function _refundTokenToSender(uint256 inputAmount) internal override {\n        // Do nothing since we transferred the exact input amount\n    }\n    /**\n        @notice Sends protocol fee (if it exists) back to the LSSVMPairFactory\n     */\n    function _payProtocolFee(LSSVMPairFactoryLike _factory, uint256 protocolFee)\n        internal\n        override\n    {\n        // Take protocol fee (if it exists)\n        if (protocolFee > 0) {\n            ERC20 _token = token();\n            // Round down to the actual token balance if there are numerical stability issues with the bonding curve calculations\n            uint256 pairTokenBalance = _token.balanceOf(address(this));\n            if (protocolFee > pairTokenBalance) {\n                protocolFee = pairTokenBalance;\n            }\n            _token.safeTransfer(address(_factory), protocolFee);\n        }\n    }\n    /**\n        @notice Sends tokens to a recipient\n        @param tokenRecipient The address receiving the tokens\n        @param outputAmount The amount of tokens to send\n     */\n    function _sendTokenOutput(\n        address payable tokenRecipient,\n        uint256 outputAmount\n    ) internal override {\n        // Send tokens to caller\n        if (outputAmount > 0) {\n            token().safeTransfer(tokenRecipient, outputAmount);\n        }\n    }\n    /**\n        @dev Used internally to grab pair parameters from calldata, see LSSVMPairCloner for technical details\n     */\n    function _immutableParamsLength() internal pure override returns (uint256) {\n        return 81;\n    }\n    /**\n        @notice Withdraws ERC20 tokens from the pair to the owner. \n        @dev Only callable by the owner.\n        @param a The address of the token to transfer\n        @param amount The amount of tokens to send to the owner\n     */\n    function withdrawERC20(address a, uint256 amount)\n        external\n        override\n        onlyOwner\n    {\n        ERC20(a).safeTransfer(msg.sender, amount);\n        if (a == address(token())) {\n            // emit event since it is the pair token\n            emit TokenWithdrawn(amount);\n        }\n    }\n}",
        "after": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.0;\nimport {SafeTransferLib} from \"solmate/utils/SafeTransferLib.sol\";\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {IERC721} from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport {LSSVMPair} from \"./LSSVMPair.sol\";\nimport {LSSVMPairFactoryLike} from \"./LSSVMPairFactoryLike.sol\";\nimport {LSSVMRouter} from \"./LSSVMRouter.sol\";\nimport {ICurve} from \"./bonding-curves/ICurve.sol\";\nimport {CurveErrorCodes} from \"./bonding-curves/CurveErrorCodes.sol\";\n/**\n    @title An NFT/Token pair where the token is an ERC20\n    @author boredGenius and 0xmons\n */\nabstract contract LSSVMPairERC20 is LSSVMPair {\n    using SafeTransferLib for ERC20;\n    /**\n        @notice Returns the ERC20 token associated with the pair\n        @dev See LSSVMPairCloner for an explanation on how this works\n     */\n    function token() public pure returns (ERC20 _token) {\n        uint256 paramsLength = _immutableParamsLength();\n        assembly {\n            _token := shr(\n                0x60,\n                calldataload(add(sub(calldatasize(), paramsLength), 61))\n            )\n        }\n    }\n    /**\n        @notice Verifies and takes the correct amount of tokens needed for a swap\n        @param inputAmount The amount of tokens to be sent in\n        @param isRouter Whether or not the caller is LSSVMRouter\n        @param routerCaller If called from LSSVMRouter, store the original caller\n        @param _factory The LSSVMPairFactory which stores LSSVMRouter allowlist info\n     */\n    function _validateTokenInput(\n        uint256 inputAmount,\n        bool isRouter,\n        address routerCaller,\n        LSSVMPairFactoryLike _factory\n    ) internal override {\n        require(msg.value == 0, \"ERC20 pair\");\n        ERC20 _token = token();\n        address _assetRecipient = getAssetRecipient();\n        if (isRouter) {\n            // Verify if router is allowed\n            LSSVMRouter router = LSSVMRouter(payable(msg.sender));\n            require(_factory.routerAllowed(router), \"Not router\");\n\n            // Call router to transfer tokens from user\n            uint256 beforeBalance = _token.balanceOf(_assetRecipient);\n            uint256 beforeNFTBalance = nft().balanceOf(_assetRecipient);\n            router.pairTransferERC20From(\n                _token,\n                routerCaller,\n\n    \n        \n          \n    \n\n        \n        Expand All\n    \n    @@ -71,6 +71,10 @@ abstract contract LSSVMPairERC20 is LSSVMPair {\n  \n                _assetRecipient,\n                inputAmount,\n                pairVariant()\n            );\n            // Verify token transfer (protect pair against malicious router)\n            require(\n                _token.balanceOf(_assetRecipient) - beforeBalance ==\n                    inputAmount,\n                \"ERC20 not transferred in\"\n            );\n            require(\n                beforeNFTBalance == nft().balanceOf(_assetRecipient),\n                \"Reentrant call from router\"\n            );\n        } else {\n            // Transfer tokens directly\n            _token.safeTransferFrom(msg.sender, _assetRecipient, inputAmount);\n\n    \n          \n            \n    \n\n          \n          Expand Down\n    \n    \n  \n        }\n    }\n    /**\n        @notice Sends excess tokens back to the caller\n     */\n    function _refundTokenToSender(uint256 inputAmount) internal override {\n        // Do nothing since we transferred the exact input amount\n    }\n    /**\n        @notice Sends protocol fee (if it exists) back to the LSSVMPairFactory\n     */\n    function _payProtocolFee(LSSVMPairFactoryLike _factory, uint256 protocolFee)\n        internal\n        override\n    {\n        // Take protocol fee (if it exists)\n        if (protocolFee > 0) {\n            ERC20 _token = token();\n            // Round down to the actual token balance if there are numerical stability issues with the bonding curve calculations\n            uint256 pairTokenBalance = _token.balanceOf(address(this));\n            if (protocolFee > pairTokenBalance) {\n                protocolFee = pairTokenBalance;\n            }\n            _token.safeTransfer(address(_factory), protocolFee);\n        }\n    }\n    /**\n        @notice Sends tokens to a recipient\n        @param tokenRecipient The address receiving the tokens\n        @param outputAmount The amount of tokens to send\n     */\n    function _sendTokenOutput(\n        address payable tokenRecipient,\n        uint256 outputAmount\n    ) internal override {\n        // Send tokens to caller\n        if (outputAmount > 0) {\n            token().safeTransfer(tokenRecipient, outputAmount);\n        }\n    }\n    /**\n        @dev Used internally to grab pair parameters from calldata, see LSSVMPairCloner for technical details\n     */\n    function _immutableParamsLength() internal pure override returns (uint256) {\n        return 81;\n    }\n    /**\n        @notice Withdraws ERC20 tokens from the pair to the owner. \n        @dev Only callable by the owner.\n        @param a The address of the token to transfer\n        @param amount The amount of tokens to send to the owner\n     */\n    function withdrawERC20(address a, uint256 amount)\n        external\n        override\n        onlyOwner\n    {\n        ERC20(a).safeTransfer(msg.sender, amount);\n        if (a == address(token())) {\n            // emit event since it is the pair token\n            emit TokenWithdrawn(amount);\n        }\n    }\n}"
    },
    {
        "tag": "Front-Running",
        "url": "https://github.com  /PaulRBerg/prb-proxy/commit/58ba03981b9b770ad7d74717b180c5a7cb3767bb",
        "file": "contracts/PRBProxyFactory.sol",
        "before": "// SPDX-License-Identifier: WTFPL\npragma solidity >=0.8.4;\nimport \"./IPRBProxy.sol\";\nimport \"./IPRBProxyFactory.sol\";\nimport \"./PRBProxy.sol\";\n/// @title PRBProxyFactory\n/// @author Paul Razvan Berg\ncontract PRBProxyFactory is IPRBProxyFactory {\n    /// PUBLIC STORAGE ///\n    /// @inheritdoc IPRBProxyFactory\n    mapping(address => bool) public override isProxy;\n    /// PUBLIC NON-CONSTANT FUNCTIONS ///\n\n    /// @inheritdoc IPRBProxyFactory\n    function deploy() external override returns (address payable proxy) {\n        proxy = deployFor(msg.sender);\n    }\n\n    /// @inheritdoc IPRBProxyFactory\n    function deployFor(address owner) public override returns (address payable proxy) {\n        // Deploy the proxy contract with CREATE2.\n        bytes memory bytecode = type(PRBProxy).creationCode;\n        bytes32 salt = keccak256(abi.encode(owner));\n        assembly {\n            let endowment := 0\n            let bytecodeStart := add(bytecode, 0x20)\n\n    \n          \n            \n    \n\n          \n          Expand Down\n    \n    \n  \n            let bytecodeLength := mload(bytecode)\n            proxy := create2(endowment, bytecodeStart, bytecodeLength, salt)\n        }\n        // Transfer the ownership from this factory contract to the specified owner.\n        IPRBProxy(proxy)._transferOwnership(owner);\n        // Mark the proxy as deployed in the mapping.\n        isProxy[proxy] = true;\n        // Log the proxy via en event.\n        emit DeployProxy(msg.sender, owner, address(proxy));\n    }\n}",
        "after": "// SPDX-License-Identifier: WTFPL\npragma solidity >=0.8.4;\nimport \"./IPRBProxy.sol\";\nimport \"./IPRBProxyFactory.sol\";\nimport \"./PRBProxy.sol\";\n/// @title PRBProxyFactory\n/// @author Paul Razvan Berg\ncontract PRBProxyFactory is IPRBProxyFactory {\n    /// PUBLIC STORAGE ///\n    /// @inheritdoc IPRBProxyFactory\n    mapping(address => bool) public override isProxy;\n    /// PUBLIC NON-CONSTANT FUNCTIONS ///\n\n    /// @inheritdoc IPRBProxyFactory\n    function deploy(bytes32 salt) external override returns (address payable proxy) {\n        proxy = deployFor(msg.sender, salt);\n    }\n\n    /// @inheritdoc IPRBProxyFactory\n    function deployFor(address owner, bytes32 salt) public override returns (address payable proxy) {\n        // Load the proxy bytecode.\n        bytes memory bytecode = type(PRBProxy).creationCode;\n\n        // Prevent front running the salt by hashing the concatenation of msg.sender and the user-provided salt.\n        salt = keccak256(abi.encode(tx.origin, salt));\n\n        // Deploy the proxy with CREATE2.\n        assembly {\n            let endowment := 0\n            let bytecodeStart := add(bytecode, 0x20)\n\n    \n          \n            \n    \n\n          \n          Expand Down\n    \n    \n  \n            let bytecodeLength := mload(bytecode)\n            proxy := create2(endowment, bytecodeStart, bytecodeLength, salt)\n        }\n        // Transfer the ownership from this factory contract to the specified owner.\n        IPRBProxy(proxy)._transferOwnership(owner);\n        // Mark the proxy as deployed in the mapping.\n        isProxy[proxy] = true;\n        // Log the proxy via en event.\n        emit DeployProxy(msg.sender, owner, address(proxy));\n    }\n}"
    },
    {
        "tag": "arithmetic",
        "url": "https://github.com/muffinfi/muffin/commit/331f4239568e39cf42de38f99115c1a3898e9c74",
        "file": "contracts/libraries/math/PoolMath.sol",
        "before": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\nimport \"./Math.sol\";\nimport \"./FullMath.sol\";\nlibrary PoolMath {\n    using Math for uint256;\n    uint256 private constant Q72 = 0x1000000000000000000;\n    uint256 private constant Q184 = 0x10000000000000000000000000000000000000000000000;\n    // ----- sqrt price <> token amounts -----\n    /// @dev Calculate amount0 delta when price moves from sqrtP0 to sqrtP1.\n    /// i.e. Δx = L (√P0 - √P1) / (√P0 √P1)\n    ///\n    /// @dev Rounding rules:\n    /// if sqrtP0 > sqrtP1 (price goes down):   => amt0 is input    => round up\n    /// if sqrtP0 < sqrtP1 (price goes up):     => amt1 is output   => round down\n    function calcAmt0FromSqrtP(\n        uint128 sqrtP0,\n        uint128 sqrtP1,\n        uint128 liquidity\n    ) internal pure returns (int256 amt0) {\n        unchecked {\n            bool priceUp = sqrtP1 > sqrtP0;\n            if (priceUp) (sqrtP0, sqrtP1) = (sqrtP1, sqrtP0);\n            uint num = uint(liquidity) * (sqrtP0 - sqrtP1);\n            uint denom = uint(sqrtP0) * sqrtP1;\n            amt0 = Math.toInt256(\n                num < Q184\n                    ? (priceUp ? (num << 72) / denom : UnsafeMath.ceilDiv(num << 72, denom))\n                    : (priceUp ? FullMath.mulDiv(num, Q72, denom) : FullMath.mulDivRoundingUp(num, Q72, denom))\n            );\n            if (priceUp) amt0 *= -1;\n        }\n    }\n    /// @dev Calculate amount1 delta when price moves from sqrtP0 to sqrtP1.\n    /// i.e. Δy = L (√P0 - √P1)\n    ///\n    /// @dev Rounding rules:\n    /// if sqrtP0 > sqrtP1 (price goes down):   => amt1 is output   => round down\n    /// if sqrtP0 < sqrtP1 (price goes up):     => amt1 is input    => round up\n    function calcAmt1FromSqrtP(\n        uint128 sqrtP0,\n        uint128 sqrtP1,\n        uint128 liquidity\n    ) internal pure returns (int256 amt1) {\n        unchecked {\n            bool priceDown = sqrtP1 < sqrtP0;\n            if (priceDown) (sqrtP0, sqrtP1) = (sqrtP1, sqrtP0);\n            uint num = uint(liquidity) * (sqrtP1 - sqrtP0);\n            amt1 = (priceDown ? num >> 72 : UnsafeMath.ceilDiv(num, Q72)).toInt256();\n            if (priceDown) amt1 *= -1;\n        }\n    }\n    /// @dev Calculate the new sqrt price after an amount0 delta.\n    /// i.e. √P1 = L √P0 / (L + Δx * √P0)   if no overflow\n    ///          = L / (L/√P0 + Δx)         otherwise\n    ///\n    /// @dev Rounding rules:\n    /// if amt0 in:     price goes down => sqrtP1 rounded up for less price change for less amt1 out\n    /// if amt0 out:    price goes up   => sqrtP1 rounded up for more price change for more amt1 in\n    /// therefore:      sqrtP1 always rounded up\n    function calcSqrtPFromAmt0(\n        uint128 sqrtP0,\n        uint128 liquidity,\n        int256 amt0\n    ) internal pure returns (uint128 sqrtP1) {\n        unchecked {\n            if (amt0 == 0) return sqrtP0;\n            uint absAmt0 = uint(amt0 < 0 ? -amt0 : amt0);\n            uint product = absAmt0 * sqrtP0;\n            uint liquidityX72 = uint(liquidity) << 72;\n            uint denom;\n            if (amt0 > 0) {\n                if ((product / absAmt0 == sqrtP0) && ((denom = liquidityX72 + product) >= liquidityX72)) {\n                    // if product and denom don't overflow:\n                    uint num = uint(liquidity) * sqrtP0;\n                    sqrtP1 = num < Q184\n                        ? uint128(UnsafeMath.ceilDiv(num << 72, denom)) // denom > 0\n                        : uint128(FullMath.mulDivRoundingUp(num, Q72, denom));\n                } else {\n                    // if either one overflows:\n                    sqrtP1 = uint128(UnsafeMath.ceilDiv(liquidityX72, (liquidityX72 / sqrtP0).add(absAmt0))); // absAmt0 > 0\n                }\n            } else {\n                // ensure product doesn't overflow and denom doesn't underflow\n                require(product / absAmt0 == sqrtP0);\n                require((denom = liquidityX72 - product) <= liquidityX72);\n                require(denom != 0);\n                uint num = uint(liquidity) * sqrtP0;\n                sqrtP1 = num < Q184\n                    ? UnsafeMath.ceilDiv(num << 72, denom).toUint128()\n                    : FullMath.mulDivRoundingUp(num, Q72, denom).toUint128();\n            }\n        }\n    }\n    /// @dev Calculate the new sqrt price after an amount1 delta.\n    /// i.e. √P1 = √P0 + (Δy / L)\n    ///\n    /// @dev Rounding rules:\n    /// if amt1 in:     price goes up   => sqrtP1 rounded down for less price delta for less amt0 out\n    /// if amt1 out:    price goes down => sqrtP1 rounded down for more price delta for more amt0 in\n    /// therefore:      sqrtP1 always rounded down\n    function calcSqrtPFromAmt1(\n        uint128 sqrtP0,\n        uint128 liquidity,\n        int256 amt1\n    ) internal pure returns (uint128 sqrtP1) {\n        unchecked {\n            if (amt1 < 0) {\n                // price moves down\n                require(liquidity != 0);\n                uint absAmt1 = uint(-amt1);\n                uint absAmt1DivL = absAmt1 < Q184\n                    ? UnsafeMath.ceilDiv(absAmt1 * Q72, liquidity)\n                    : FullMath.mulDivRoundingUp(absAmt1, Q72, liquidity);\n                sqrtP1 = uint(sqrtP0).sub(absAmt1DivL).toUint128();\n            } else {\n                // price moves up\n                uint amt1DivL = uint(amt1) < Q184\n                    ? (uint(amt1) * Q72) / liquidity\n                    : FullMath.mulDiv(uint(amt1), Q72, liquidity);\n                sqrtP1 = uint(sqrtP0).add(amt1DivL).toUint128();\n            }\n        }\n    }\n    // ----- liquidity <> token amounts -----\n    /// @dev Calculate the amount{0,1} needed for the given liquidity change\n    function calcAmtsForLiquidity(\n        uint128 sqrtP,\n        uint128 sqrtPLower,\n        uint128 sqrtPUpper,\n        int96 liquidityDeltaD8\n    ) internal pure returns (uint256 amt0, uint256 amt1) {\n        // we assume {sqrtP, sqrtPLower, sqrtPUpper} ≠ 0 and sqrtPLower < sqrtPUpper\n        unchecked {\n            // find the sqrt price at which liquidity is add/removed\n            sqrtP = (sqrtP < sqrtPLower) ? sqrtPLower : (sqrtP > sqrtPUpper) ? sqrtPUpper : sqrtP;\n\n            // calc amt{0,1} for the change of liquidity\n            uint128 absL = uint128(uint96(liquidityDeltaD8 >= 0 ? liquidityDeltaD8 : -liquidityDeltaD8) << 8);\n            if (liquidityDeltaD8 >= 0) {\n                // round up\n                amt0 = uint(calcAmt0FromSqrtP(sqrtPUpper, sqrtP, absL));\n\n    \n          \n            \n    \n\n          \n          Expand Down\n    \n    \n  \n                amt1 = uint(calcAmt1FromSqrtP(sqrtPLower, sqrtP, absL));\n            } else {\n                // round down\n                amt0 = uint(-calcAmt0FromSqrtP(sqrtP, sqrtPUpper, absL));\n                amt1 = uint(-calcAmt1FromSqrtP(sqrtP, sqrtPLower, absL));\n            }\n        }\n    }\n    /// @dev Calculate the max liquidity received if adding given token amounts to the tier.\n    function calcLiquidityForAmts(\n        uint128 sqrtP,\n        uint128 sqrtPLower,\n        uint128 sqrtPUpper,\n        uint256 amt0,\n        uint256 amt1\n    ) internal pure returns (uint96 liquidityD8) {\n        // we assume {sqrtP, sqrtPLower, sqrtPUpper} ≠ 0 and sqrtPLower < sqrtPUpper\n        unchecked {\n            uint liquidity;\n            if (sqrtP <= sqrtPLower) {\n                // L = Δx (√P0 √P1) / (√P0 - √P1)\n                liquidity = FullMath.mulDiv(amt0, uint(sqrtPLower) * sqrtPUpper, (sqrtPUpper - sqrtPLower) * Q72);\n            } else if (sqrtP >= sqrtPUpper) {\n                // L = Δy / (√P0 - √P1)\n                liquidity = FullMath.mulDiv(amt1, Q72, sqrtPUpper - sqrtPLower);\n            } else {\n                uint liquidity0 = FullMath.mulDiv(amt0, uint(sqrtP) * sqrtPUpper, (sqrtPUpper - sqrtP) * Q72);\n                uint liquidity1 = FullMath.mulDiv(amt1, Q72, sqrtP - sqrtPLower);\n                liquidity = (liquidity0 < liquidity1 ? liquidity0 : liquidity1);\n            }\n            liquidityD8 = (liquidity >> 8).toUint96();\n        }\n    }\n}",
        "after": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\nimport \"./Math.sol\";\nimport \"./FullMath.sol\";\nlibrary PoolMath {\n    using Math for uint256;\n    uint256 private constant Q72 = 0x1000000000000000000;\n    uint256 private constant Q184 = 0x10000000000000000000000000000000000000000000000;\n    // ----- sqrt price <> token amounts -----\n    /// @dev Calculate amount0 delta when price moves from sqrtP0 to sqrtP1.\n    /// i.e. Δx = L (√P0 - √P1) / (√P0 √P1)\n    ///\n    /// @dev Rounding rules:\n    /// if sqrtP0 > sqrtP1 (price goes down):   => amt0 is input    => round up\n    /// if sqrtP0 < sqrtP1 (price goes up):     => amt1 is output   => round down\n    function calcAmt0FromSqrtP(\n        uint128 sqrtP0,\n        uint128 sqrtP1,\n        uint128 liquidity\n    ) internal pure returns (int256 amt0) {\n        unchecked {\n            bool priceUp = sqrtP1 > sqrtP0;\n            if (priceUp) (sqrtP0, sqrtP1) = (sqrtP1, sqrtP0);\n            uint num = uint(liquidity) * (sqrtP0 - sqrtP1);\n            uint denom = uint(sqrtP0) * sqrtP1;\n            amt0 = Math.toInt256(\n                num < Q184\n                    ? (priceUp ? (num << 72) / denom : UnsafeMath.ceilDiv(num << 72, denom))\n                    : (priceUp ? FullMath.mulDiv(num, Q72, denom) : FullMath.mulDivRoundingUp(num, Q72, denom))\n            );\n            if (priceUp) amt0 *= -1;\n        }\n    }\n    /// @dev Calculate amount1 delta when price moves from sqrtP0 to sqrtP1.\n    /// i.e. Δy = L (√P0 - √P1)\n    ///\n    /// @dev Rounding rules:\n    /// if sqrtP0 > sqrtP1 (price goes down):   => amt1 is output   => round down\n    /// if sqrtP0 < sqrtP1 (price goes up):     => amt1 is input    => round up\n    function calcAmt1FromSqrtP(\n        uint128 sqrtP0,\n        uint128 sqrtP1,\n        uint128 liquidity\n    ) internal pure returns (int256 amt1) {\n        unchecked {\n            bool priceDown = sqrtP1 < sqrtP0;\n            if (priceDown) (sqrtP0, sqrtP1) = (sqrtP1, sqrtP0);\n            uint num = uint(liquidity) * (sqrtP1 - sqrtP0);\n            amt1 = (priceDown ? num >> 72 : UnsafeMath.ceilDiv(num, Q72)).toInt256();\n            if (priceDown) amt1 *= -1;\n        }\n    }\n    /// @dev Calculate the new sqrt price after an amount0 delta.\n    /// i.e. √P1 = L √P0 / (L + Δx * √P0)   if no overflow\n    ///          = L / (L/√P0 + Δx)         otherwise\n    ///\n    /// @dev Rounding rules:\n    /// if amt0 in:     price goes down => sqrtP1 rounded up for less price change for less amt1 out\n    /// if amt0 out:    price goes up   => sqrtP1 rounded up for more price change for more amt1 in\n    /// therefore:      sqrtP1 always rounded up\n    function calcSqrtPFromAmt0(\n        uint128 sqrtP0,\n        uint128 liquidity,\n        int256 amt0\n    ) internal pure returns (uint128 sqrtP1) {\n        unchecked {\n            if (amt0 == 0) return sqrtP0;\n            uint absAmt0 = uint(amt0 < 0 ? -amt0 : amt0);\n            uint product = absAmt0 * sqrtP0;\n            uint liquidityX72 = uint(liquidity) << 72;\n            uint denom;\n            if (amt0 > 0) {\n                if ((product / absAmt0 == sqrtP0) && ((denom = liquidityX72 + product) >= liquidityX72)) {\n                    // if product and denom don't overflow:\n                    uint num = uint(liquidity) * sqrtP0;\n                    sqrtP1 = num < Q184\n                        ? uint128(UnsafeMath.ceilDiv(num << 72, denom)) // denom > 0\n                        : uint128(FullMath.mulDivRoundingUp(num, Q72, denom));\n                } else {\n                    // if either one overflows:\n                    sqrtP1 = uint128(UnsafeMath.ceilDiv(liquidityX72, (liquidityX72 / sqrtP0).add(absAmt0))); // absAmt0 > 0\n                }\n            } else {\n                // ensure product doesn't overflow and denom doesn't underflow\n                require(product / absAmt0 == sqrtP0);\n                require((denom = liquidityX72 - product) <= liquidityX72);\n                require(denom != 0);\n                uint num = uint(liquidity) * sqrtP0;\n                sqrtP1 = num < Q184\n                    ? UnsafeMath.ceilDiv(num << 72, denom).toUint128()\n                    : FullMath.mulDivRoundingUp(num, Q72, denom).toUint128();\n            }\n        }\n    }\n    /// @dev Calculate the new sqrt price after an amount1 delta.\n    /// i.e. √P1 = √P0 + (Δy / L)\n    ///\n    /// @dev Rounding rules:\n    /// if amt1 in:     price goes up   => sqrtP1 rounded down for less price delta for less amt0 out\n    /// if amt1 out:    price goes down => sqrtP1 rounded down for more price delta for more amt0 in\n    /// therefore:      sqrtP1 always rounded down\n    function calcSqrtPFromAmt1(\n        uint128 sqrtP0,\n        uint128 liquidity,\n        int256 amt1\n    ) internal pure returns (uint128 sqrtP1) {\n        unchecked {\n            if (amt1 < 0) {\n                // price moves down\n                require(liquidity != 0);\n                uint absAmt1 = uint(-amt1);\n                uint absAmt1DivL = absAmt1 < Q184\n                    ? UnsafeMath.ceilDiv(absAmt1 * Q72, liquidity)\n                    : FullMath.mulDivRoundingUp(absAmt1, Q72, liquidity);\n                sqrtP1 = uint(sqrtP0).sub(absAmt1DivL).toUint128();\n            } else {\n                // price moves up\n                uint amt1DivL = uint(amt1) < Q184\n                    ? (uint(amt1) * Q72) / liquidity\n                    : FullMath.mulDiv(uint(amt1), Q72, liquidity);\n                sqrtP1 = uint(sqrtP0).add(amt1DivL).toUint128();\n            }\n        }\n    }\n    // ----- liquidity <> token amounts -----\n    /// @dev Calculate the amount{0,1} needed for the given liquidity change\n    function calcAmtsForLiquidity(\n        uint128 sqrtP,\n        uint128 sqrtPLower,\n        uint128 sqrtPUpper,\n        int96 liquidityDeltaD8\n    ) internal pure returns (uint256 amt0, uint256 amt1) {\n        // we assume {sqrtP, sqrtPLower, sqrtPUpper} ≠ 0 and sqrtPLower < sqrtPUpper\n        unchecked {\n            // find the sqrt price at which liquidity is add/removed\n            sqrtP = (sqrtP < sqrtPLower) ? sqrtPLower : (sqrtP > sqrtPUpper) ? sqrtPUpper : sqrtP;\n\n            // calc amt{0,1} for the change of liquidity\n            uint128 absL = uint128(uint96(liquidityDeltaD8 >= 0 ? liquidityDeltaD8 : -liquidityDeltaD8)) << 8;\n            if (liquidityDeltaD8 >= 0) {\n                // round up\n                amt0 = uint(calcAmt0FromSqrtP(sqrtPUpper, sqrtP, absL));\n\n    \n          \n            \n    \n\n          \n          Expand Down\n    \n    \n  \n                amt1 = uint(calcAmt1FromSqrtP(sqrtPLower, sqrtP, absL));\n            } else {\n                // round down\n                amt0 = uint(-calcAmt0FromSqrtP(sqrtP, sqrtPUpper, absL));\n                amt1 = uint(-calcAmt1FromSqrtP(sqrtP, sqrtPLower, absL));\n            }\n        }\n    }\n    /// @dev Calculate the max liquidity received if adding given token amounts to the tier.\n    function calcLiquidityForAmts(\n        uint128 sqrtP,\n        uint128 sqrtPLower,\n        uint128 sqrtPUpper,\n        uint256 amt0,\n        uint256 amt1\n    ) internal pure returns (uint96 liquidityD8) {\n        // we assume {sqrtP, sqrtPLower, sqrtPUpper} ≠ 0 and sqrtPLower < sqrtPUpper\n        unchecked {\n            uint liquidity;\n            if (sqrtP <= sqrtPLower) {\n                // L = Δx (√P0 √P1) / (√P0 - √P1)\n                liquidity = FullMath.mulDiv(amt0, uint(sqrtPLower) * sqrtPUpper, (sqrtPUpper - sqrtPLower) * Q72);\n            } else if (sqrtP >= sqrtPUpper) {\n                // L = Δy / (√P0 - √P1)\n                liquidity = FullMath.mulDiv(amt1, Q72, sqrtPUpper - sqrtPLower);\n            } else {\n                uint liquidity0 = FullMath.mulDiv(amt0, uint(sqrtP) * sqrtPUpper, (sqrtPUpper - sqrtP) * Q72);\n                uint liquidity1 = FullMath.mulDiv(amt1, Q72, sqrtP - sqrtPLower);\n                liquidity = (liquidity0 < liquidity1 ? liquidity0 : liquidity1);\n            }\n            liquidityD8 = (liquidity >> 8).toUint96();\n        }\n    }\n}"
    },
    {
        "tag": "Unchecked Return Values For Low Level Calls",
        "url": "https://github.com/ubiquity/ubiquity-dollar/commit/3d97e7c68ce184b2a29ccfb6fb0a8100c38419c5",
        "file": "packages/contracts/src/dollar/Staking.sol",
        "before": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\nimport \"./core/UbiquityDollarToken.sol\";\nimport \"./core/UbiquityDollarManager.sol\";\nimport \"./interfaces/IERC1155Ubiquity.sol\";\nimport \"./interfaces/IMetaPool.sol\";\nimport \"./interfaces/IUbiquityFormulas.sol\";\nimport \"./interfaces/ISablier.sol\";\nimport \"./interfaces/IUbiquityChef.sol\";\nimport \"./interfaces/ITWAPOracleDollar3pool.sol\";\nimport \"./interfaces/IERC1155Ubiquity.sol\";\nimport \"./utils/CollectableDust.sol\";\nimport \"./StakingFormulas.sol\";\nimport \"./StakingShare.sol\";\ncontract Staking is CollectableDust, Pausable {\n    using SafeERC20 for IERC20;\n    bytes public data = \"\";\n    UbiquityDollarManager public manager;\n    uint256 public constant ONE = uint256(1 ether); // 3Crv has 18 decimals\n    uint256 public stakingDiscountMultiplier = uint256(1000000 gwei); // 0.001\n    uint256 public blockCountInAWeek = 45361;\n    uint256 public accLpRewardPerShare = 0;\n    uint256 public lpRewards;\n    uint256 public totalLpToMigrate;\n    address public stakingFormulasAddress;\n    address public migrator; // temporary address to handle migration\n    address[] private _toMigrateOriginals;\n    uint256[] private _toMigrateLpBalances;\n    uint256[] private _toMigrateWeeks;\n    // toMigrateId[address] > 0 when address is to migrate, or 0 in all other cases\n    mapping(address => uint256) public toMigrateId;\n    bool public migrating = false;\n    event PriceReset(\n        address _tokenWithdrawn,\n        uint256 _amountWithdrawn,\n        uint256 _amountTransferred\n    );\n    event Deposit(\n        address indexed _user,\n        uint256 indexed _id,\n        uint256 _lpAmount,\n        uint256 _stakingShareAmount,\n        uint256 _weeks,\n        uint256 _endBlock\n    );\n    event RemoveLiquidityFromStake(\n        address indexed _user,\n        uint256 indexed _id,\n        uint256 _lpAmount,\n        uint256 _lpAmountTransferred,\n        uint256 _lpRewards,\n        uint256 _stakingShareAmount\n    );\n    event AddLiquidityFromStake(\n        address indexed _user,\n        uint256 indexed _id,\n        uint256 _lpAmount,\n        uint256 _stakingShareAmount\n    );\n    event StakingDiscountMultiplierUpdated(uint256 _stakingDiscountMultiplier);\n    event BlockCountInAWeekUpdated(uint256 _blockCountInAWeek);\n    event Migrated(\n        address indexed _user,\n        uint256 indexed _id,\n        uint256 _lpsAmount,\n        uint256 _sharesAmount,\n        uint256 _weeks\n    );\n    modifier onlyStakingManager() {\n        require(\n            manager.hasRole(manager.STAKING_MANAGER_ROLE(), msg.sender),\n            \"not manager\"\n        );\n        _;\n    }\n    modifier onlyPauser() {\n        require(\n            manager.hasRole(manager.PAUSER_ROLE(), msg.sender), \"not pauser\"\n        );\n        _;\n    }\n    modifier onlyMigrator() {\n        require(msg.sender == migrator, \"not migrator\");\n        _;\n    }\n    modifier whenMigrating() {\n        require(migrating, \"not in migration\");\n        _;\n    }\n    constructor(\n        address _manager,\n        address _stakingFormulasAddress,\n        address[] memory _originals,\n        uint256[] memory _lpBalances,\n        uint256[] memory _weeks\n    ) CollectableDust() Pausable() {\n        manager = UbiquityDollarManager(_manager);\n        stakingFormulasAddress = _stakingFormulasAddress;\n        migrator = msg.sender;\n        uint256 lgt = _originals.length;\n        require(lgt > 0, \"address array empty\");\n        require(lgt == _lpBalances.length, \"balances array not same length\");\n        require(lgt == _weeks.length, \"weeks array not same length\");\n        _toMigrateOriginals = _originals;\n        _toMigrateLpBalances = _lpBalances;\n        _toMigrateWeeks = _weeks;\n        for (uint256 i = 0; i < lgt; ++i) {\n            toMigrateId[_originals[i]] = i + 1;\n            totalLpToMigrate += _lpBalances[i];\n        }\n    }\n    // solhint-disable-next-line no-empty-blocks\n    receive() external payable {}\n    /// @dev addUserToMigrate add a user to migrate from V1.\n    ///      IMPORTANT execute that function BEFORE sending the corresponding LP token\n    ///      otherwise they will have extra LP rewards\n    /// @param _original address of v1 user\n    /// @param _lpBalance LP Balance of v1 user\n    /// @param _weeks weeks lockup of v1 user\n    /// @notice user will then be able to migrate.\n    function addUserToMigrate(\n        address _original,\n        uint256 _lpBalance,\n        uint256 _weeks\n    ) external onlyMigrator {\n        _toMigrateOriginals.push(_original);\n        _toMigrateLpBalances.push(_lpBalance);\n        totalLpToMigrate += _lpBalance;\n        _toMigrateWeeks.push(_weeks);\n        toMigrateId[_original] = _toMigrateOriginals.length;\n    }\n    function setMigrator(address _migrator) external onlyMigrator {\n        migrator = _migrator;\n    }\n    function setMigrating(bool _migrating) external onlyMigrator {\n        migrating = _migrating;\n    }\n    /// @dev dollarPriceReset remove Ubiquity Dollar unilaterally from the curve LP share sitting inside\n    ///      the staking contract and send the Ubiquity Dollar received to the treasury.\n    ///      This will have the immediate effect of pushing the Ubiquity Dollar price HIGHER\n    /// @param amount of LP token to be removed for Ubiquity Dollar\n    /// @notice it will remove one coin only from the curve LP share sitting in the staking contract\n    function dollarPriceReset(uint256 amount) external onlyStakingManager {\n        IMetaPool metaPool = IMetaPool(manager.stableSwapMetaPoolAddress());\n        // remove one coin\n        uint256 coinWithdrawn = metaPool.remove_liquidity_one_coin(amount, 0, 0);\n        ITWAPOracleDollar3pool(manager.twapOracleAddress()).update();\n        uint256 toTransfer =\n            IERC20(manager.dollarTokenAddress()).balanceOf(address(this));\n        IERC20(manager.dollarTokenAddress()).transfer(\n            manager.treasuryAddress(), toTransfer\n        );\n        emit PriceReset(manager.dollarTokenAddress(), coinWithdrawn, toTransfer);\n\n    \n        \n          \n    \n\n        \n        Expand All\n    \n    @@ -192,7 +192,7 @@ contract Staking is CollectableDust, Pausable {\n  \n    }\n    /// @dev crvPriceReset remove 3CRV unilaterally from the curve LP share sitting inside\n    ///      the staking contract and send the 3CRV received to the treasury\n    ///      This will have the immediate effect of pushing the Ubiquity Dollar price LOWER\n    /// @param amount of LP token to be removed for 3CRV tokens\n    /// @notice it will remove one coin only from the curve LP share sitting in the staking contract\n    function crvPriceReset(uint256 amount) external onlyStakingManager {\n        IMetaPool metaPool = IMetaPool(manager.stableSwapMetaPoolAddress());\n        // remove one coin\n        uint256 coinWithdrawn = metaPool.remove_liquidity_one_coin(amount, 1, 0);\n        // update twap\n        ITWAPOracleDollar3pool(manager.twapOracleAddress()).update();\n        uint256 toTransfer =\n            IERC20(manager.curve3PoolTokenAddress()).balanceOf(address(this));\n        IERC20(manager.curve3PoolTokenAddress()).transfer(\n            manager.treasuryAddress(), toTransfer\n        );\n        emit PriceReset(\n\n    \n          \n            \n    \n\n          \n          Expand Down\n    \n    \n  \n            manager.curve3PoolTokenAddress(), coinWithdrawn, toTransfer\n            );\n    }\n    function setStakingFormulasAddress(address _stakingFormulasAddress)\n        external\n        onlyStakingManager\n    {\n        stakingFormulasAddress = _stakingFormulasAddress;\n    }\n    /// Collectable Dust\n    function addProtocolToken(address _token)\n        external\n        override\n        onlyStakingManager\n    {\n        _addProtocolToken(_token);\n    }\n    function removeProtocolToken(address _token)\n        external\n        override\n        onlyStakingManager\n    {\n        _removeProtocolToken(_token);\n    }\n    function sendDust(address _to, address _token, uint256 _amount)\n        external\n        override\n        onlyStakingManager\n    {\n        _sendDust(_to, _token, _amount);\n    }\n    function setStakingDiscountMultiplier(uint256 _stakingDiscountMultiplier)\n        external\n        onlyStakingManager\n    {\n        stakingDiscountMultiplier = _stakingDiscountMultiplier;\n        emit StakingDiscountMultiplierUpdated(_stakingDiscountMultiplier);\n    }\n    function setBlockCountInAWeek(uint256 _blockCountInAWeek)\n        external\n        onlyStakingManager\n    {\n        blockCountInAWeek = _blockCountInAWeek;\n        emit BlockCountInAWeekUpdated(_blockCountInAWeek);\n    }\n    /// @dev deposit UbiquityDollar-3CRV LP tokens for a duration to receive staking shares\n    /// @param _lpsAmount of LP token to send\n    /// @param _weeks during lp token will be held\n    /// @notice weeks act as a multiplier for the amount of staking shares to be received\n    function deposit(uint256 _lpsAmount, uint256 _weeks)\n        external\n        whenNotPaused\n        returns (uint256 _id)\n    {\n        require(\n            1 <= _weeks && _weeks <= 208,\n            \"Staking: duration must be between 1 and 208 weeks\"\n        );\n        ITWAPOracleDollar3pool(manager.twapOracleAddress()).update();\n        // update the accumulated lp rewards per shares\n        _updateLpPerShare();\n        // transfer lp token to the staking contract\n        IERC20(manager.stableSwapMetaPoolAddress()).safeTransferFrom(\n            msg.sender, address(this), _lpsAmount\n        );\n        // calculate the amount of share based on the amount of lp deposited and the duration\n        uint256 _sharesAmount = IUbiquityFormulas(manager.formulasAddress())\n            .durationMultiply(_lpsAmount, _weeks, stakingDiscountMultiplier);\n        // calculate end locking period block number\n        uint256 _endBlock = block.number + _weeks * blockCountInAWeek;\n        _id = _mint(msg.sender, _lpsAmount, _sharesAmount, _endBlock);\n        // set masterchef for Governance rewards\n        IUbiquityChef(manager.masterChefAddress()).deposit(\n            msg.sender, _sharesAmount, _id\n        );\n        emit Deposit(\n            msg.sender, _id, _lpsAmount, _sharesAmount, _weeks, _endBlock\n            );\n    }\n    /// @dev Add an amount of UbiquityDollar-3CRV LP tokens\n    /// @param _amount of LP token to deposit\n    /// @param _id staking shares id\n    /// @param _weeks during lp token will be held\n    /// @notice staking shares are ERC1155 (aka NFT) because they have an expiration date\n    function addLiquidity(uint256 _amount, uint256 _id, uint256 _weeks)\n        external\n        whenNotPaused\n    {\n        (uint256[2] memory bs, StakingShare.Stake memory stake) =\n            _checkForLiquidity(_id);\n        // calculate pending LP rewards\n        uint256 sharesToRemove = bs[0];\n        _updateLpPerShare();\n        uint256 pendingLpReward =\n            lpRewardForShares(sharesToRemove, stake.lpRewardDebt);\n        // add an extra step to be able to decrease rewards if locking end is near\n        pendingLpReward = StakingFormulas(this.stakingFormulasAddress())\n            .lpRewardsAddLiquidityNormalization(stake, bs, pendingLpReward);\n        // add these LP Rewards to the deposited amount of LP token\n        stake.lpAmount += pendingLpReward;\n        lpRewards -= pendingLpReward;\n        IERC20(manager.stableSwapMetaPoolAddress()).safeTransferFrom(\n            msg.sender, address(this), _amount\n        );\n        stake.lpAmount += _amount;\n        // redeem all shares\n        IUbiquityChef(manager.masterChefAddress()).withdraw(\n            msg.sender, sharesToRemove, _id\n        );\n        // calculate the amount of share based on the new amount of lp deposited and the duration\n        uint256 _sharesAmount = IUbiquityFormulas(manager.formulasAddress())\n            .durationMultiply(stake.lpAmount, _weeks, stakingDiscountMultiplier);\n        // deposit new shares\n        IUbiquityChef(manager.masterChefAddress()).deposit(\n            msg.sender, _sharesAmount, _id\n        );\n        // calculate end locking period block number\n        // 1 week = 45361 blocks = 2371753*7/366\n        // n = (block + duration * 45361)\n        stake.endBlock = block.number + _weeks * blockCountInAWeek;\n        // should be done after masterchef withdraw\n        _updateLpPerShare();\n        stake.lpRewardDebt = (\n            IUbiquityChef(manager.masterChefAddress()).getStakingShareInfo(_id)[0]\n                * accLpRewardPerShare\n        ) / 1e12;\n        StakingShare(manager.stakingShareAddress()).updateStake(\n            _id, stake.lpAmount, stake.lpRewardDebt, stake.endBlock\n        );\n        emit AddLiquidityFromStake(msg.sender, _id, stake.lpAmount, _sharesAmount);\n    }\n    /// @dev Remove an amount of UbiquityDollar-3CRV LP tokens\n    /// @param _amount of LP token deposited when _id was created to be withdrawn\n    /// @param _id staking shares id\n    /// @notice staking shares are ERC1155 (aka NFT) because they have an expiration date\n    function removeLiquidity(uint256 _amount, uint256 _id)\n        external\n        whenNotPaused\n    {\n        (uint256[2] memory bs, StakingShare.Stake memory stake) =\n            _checkForLiquidity(_id);\n        require(stake.lpAmount >= _amount, \"Staking: amount too big\");\n        // we should decrease the Governance token rewards proportionally to the LP removed\n        // sharesToRemove = (staking shares * _amount )  / stake.lpAmount ;\n        uint256 sharesToRemove = StakingFormulas(this.stakingFormulasAddress())\n            .sharesForLP(stake, bs, _amount);\n        //get all its pending LP Rewards\n        _updateLpPerShare();\n        uint256 pendingLpReward = lpRewardForShares(bs[0], stake.lpRewardDebt);\n        // update staking shares\n        // stake.shares = stake.shares - sharesToRemove;\n        // get masterchef for Governance token rewards To ensure correct computation\n        // it needs to be done BEFORE updating the bonding share\n        IUbiquityChef(manager.masterChefAddress()).withdraw(\n            msg.sender, sharesToRemove, _id\n        );\n        // redeem of the extra LP\n        // staking lp balance - StakingShare.totalLP\n        IERC20 metapool = IERC20(manager.stableSwapMetaPoolAddress());\n        // add an extra step to be able to decrease rewards if locking end is near\n        pendingLpReward = StakingFormulas(this.stakingFormulasAddress())\n            .lpRewardsRemoveLiquidityNormalization(stake, bs, pendingLpReward);\n        uint256 correctedAmount = StakingFormulas(this.stakingFormulasAddress())\n            .correctedAmountToWithdraw(\n            StakingShare(manager.stakingShareAddress()).totalLP(),\n            metapool.balanceOf(address(this)) - lpRewards,\n            _amount\n        );\n        lpRewards -= pendingLpReward;\n        stake.lpAmount -= _amount;\n        // stake.lpRewardDebt = (staking shares * accLpRewardPerShare) /  1e18;\n        // user.amount.mul(pool.accSushiPerShare).div(1e12);\n        // should be done after masterchef withdraw\n        stake.lpRewardDebt = (\n            IUbiquityChef(manager.masterChefAddress()).getStakingShareInfo(_id)[0]\n                * accLpRewardPerShare\n        ) / 1e12;\n        StakingShare(manager.stakingShareAddress()).updateStake(\n            _id, stake.lpAmount, stake.lpRewardDebt, stake.endBlock\n        );\n        // lastly redeem lp tokens\n        metapool.safeTransfer(msg.sender, correctedAmount + pendingLpReward);\n        emit RemoveLiquidityFromStake(\n            msg.sender,\n            _id,\n            _amount,\n            correctedAmount,\n            pendingLpReward,\n            sharesToRemove\n            );\n    }\n    // View function to see pending lpRewards on frontend.\n    function pendingLpRewards(uint256 _id) external view returns (uint256) {\n        StakingShare staking = StakingShare(manager.stakingShareAddress());\n        StakingShare.Stake memory stake = staking.getStake(_id);\n        uint256[2] memory bs =\n            IUbiquityChef(manager.masterChefAddress()).getStakingShareInfo(_id);\n        uint256 lpBalance =\n            IERC20(manager.stableSwapMetaPoolAddress()).balanceOf(address(this));\n        // the excess LP is the current balance minus the total deposited LP\n        if (lpBalance >= (staking.totalLP() + totalLpToMigrate)) {\n            uint256 currentLpRewards =\n                lpBalance - (staking.totalLP() + totalLpToMigrate);\n            uint256 curAccLpRewardPerShare = accLpRewardPerShare;\n            // if new rewards we should calculate the new curAccLpRewardPerShare\n            if (currentLpRewards > lpRewards) {\n                uint256 newLpRewards = currentLpRewards - lpRewards;\n                curAccLpRewardPerShare = accLpRewardPerShare\n                    + (\n                        (newLpRewards * 1e12)\n                            / IUbiquityChef(manager.masterChefAddress()).totalShares()\n                    );\n            }\n            // we multiply the shares amount by the accumulated lpRewards per share\n            // and remove the lp Reward Debt\n            return (bs[0] * (curAccLpRewardPerShare)) / (1e12)\n                - (stake.lpRewardDebt);\n        }\n        return 0;\n    }\n    function pause() public virtual onlyPauser {\n        _pause();\n    }\n    function unpause() public virtual onlyPauser {\n        _unpause();\n    }\n    /// @dev migrate let a user migrate from V1\n    /// @notice user will then be able to migrate\n    function migrate() public whenMigrating returns (uint256 _id) {\n        _id = toMigrateId[msg.sender];\n        require(_id > 0, \"not v1 address\");\n        _migrate(\n            _toMigrateOriginals[_id - 1],\n            _toMigrateLpBalances[_id - 1],\n            _toMigrateWeeks[_id - 1]\n        );\n    }\n    /// @dev return the amount of Lp token rewards an amount of shares entitled\n    /// @param amount of staking shares\n    /// @param lpRewardDebt lp rewards that has already been distributed\n    function lpRewardForShares(uint256 amount, uint256 lpRewardDebt)\n        public\n        view\n        returns (uint256 pendingLpReward)\n    {\n        if (accLpRewardPerShare > 0) {\n            pendingLpReward =\n                (amount * accLpRewardPerShare) / 1e12 - (lpRewardDebt);\n        }\n    }\n    function currentShareValue() public view returns (uint256 priceShare) {\n        uint256 totalShares =\n            IUbiquityChef(manager.masterChefAddress()).totalShares();\n        // priceShare = totalLP / totalShares\n        priceShare = IUbiquityFormulas(manager.formulasAddress()).bondPrice(\n            StakingShare(manager.stakingShareAddress()).totalLP(),\n            totalShares,\n            ONE\n        );\n    }\n    /// @dev migrate let a user migrate from V1\n    /// @notice user will then be able to migrate\n    function _migrate(address user, uint256 _lpsAmount, uint256 _weeks)\n        internal\n        returns (uint256 _id)\n    {\n        require(toMigrateId[user] > 0, \"not v1 address\");\n        require(_lpsAmount > 0, \"LP amount is zero\");\n        require(\n            1 <= _weeks && _weeks <= 208,\n            \"Duration must be between 1 and 208 weeks\"\n        );\n        // unregister address\n        toMigrateId[user] = 0;\n        // calculate the amount of share based on the amount of lp deposited and the duration\n        uint256 _sharesAmount = IUbiquityFormulas(manager.formulasAddress())\n            .durationMultiply(_lpsAmount, _weeks, stakingDiscountMultiplier);\n        // update the accumulated lp rewards per shares\n        _updateLpPerShare();\n        // calculate end locking period block number\n        uint256 endBlock = block.number + _weeks * blockCountInAWeek;\n        _id = _mint(user, _lpsAmount, _sharesAmount, endBlock);\n        // reduce the total LP to migrate after the minting\n        // to keep the _updateLpPerShare calculation consistent\n        totalLpToMigrate -= _lpsAmount;\n        // set masterchef for Governance token rewards\n        IUbiquityChef(manager.masterChefAddress()).deposit(\n            user, _sharesAmount, _id\n        );\n        emit Migrated(user, _id, _lpsAmount, _sharesAmount, _weeks);\n    }\n    /// @dev update the accumulated excess LP per share\n    function _updateLpPerShare() internal {\n        StakingShare stake = StakingShare(manager.stakingShareAddress());\n        uint256 lpBalance =\n            IERC20(manager.stableSwapMetaPoolAddress()).balanceOf(address(this));\n        // the excess LP is the current balance\n        // minus the total deposited LP + LP that needs to be migrated\n        uint256 totalShares =\n            IUbiquityChef(manager.masterChefAddress()).totalShares();\n        if (lpBalance >= (stake.totalLP() + totalLpToMigrate) && totalShares > 0)\n        {\n            uint256 currentLpRewards =\n                lpBalance - (stake.totalLP() + totalLpToMigrate);\n            // is there new LP rewards to be distributed ?\n            if (currentLpRewards > lpRewards) {\n                // we calculate the new accumulated LP rewards per share\n                accLpRewardPerShare = accLpRewardPerShare\n                    + (((currentLpRewards - lpRewards) * 1e12) / totalShares);\n                // update the bonding contract lpRewards\n                lpRewards = currentLpRewards;\n            }\n        }\n    }\n    function _mint(\n        address to,\n        uint256 lpAmount,\n        uint256 shares,\n        uint256 endBlock\n    ) internal returns (uint256) {\n        uint256 _currentShareValue = currentShareValue();\n        require(\n            _currentShareValue != 0, \"Staking: share value should not be null\"\n        );\n        // set the lp rewards debts so that this staking share only get lp rewards from this day\n        uint256 lpRewardDebt = (shares * accLpRewardPerShare) / 1e12;\n        return StakingShare(manager.stakingShareAddress()).mint(\n            to, lpAmount, lpRewardDebt, endBlock\n        );\n    }\n    function _checkForLiquidity(uint256 _id)\n        internal\n        returns (uint256[2] memory bs, StakingShare.Stake memory stake)\n    {\n        require(\n            IERC1155Ubiquity(manager.stakingShareAddress()).balanceOf(\n                msg.sender, _id\n            ) == 1,\n            \"Staking: caller is not owner\"\n        );\n        StakingShare staking = StakingShare(manager.stakingShareAddress());\n        stake = staking.getStake(_id);\n        require(\n            block.number > stake.endBlock,\n            \"Staking: Redeem not allowed before staking time\"\n        );\n        ITWAPOracleDollar3pool(manager.twapOracleAddress()).update();\n        bs = IUbiquityChef(manager.masterChefAddress()).getStakingShareInfo(_id);\n    }\n}",
        "after": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\nimport \"./core/UbiquityDollarToken.sol\";\nimport \"./core/UbiquityDollarManager.sol\";\nimport \"./interfaces/IERC1155Ubiquity.sol\";\nimport \"./interfaces/IMetaPool.sol\";\nimport \"./interfaces/IUbiquityFormulas.sol\";\nimport \"./interfaces/ISablier.sol\";\nimport \"./interfaces/IUbiquityChef.sol\";\nimport \"./interfaces/ITWAPOracleDollar3pool.sol\";\nimport \"./interfaces/IERC1155Ubiquity.sol\";\nimport \"./utils/CollectableDust.sol\";\nimport \"./StakingFormulas.sol\";\nimport \"./StakingShare.sol\";\ncontract Staking is CollectableDust, Pausable {\n    using SafeERC20 for IERC20;\n    bytes public data = \"\";\n    UbiquityDollarManager public manager;\n    uint256 public constant ONE = uint256(1 ether); // 3Crv has 18 decimals\n    uint256 public stakingDiscountMultiplier = uint256(1000000 gwei); // 0.001\n    uint256 public blockCountInAWeek = 45361;\n    uint256 public accLpRewardPerShare = 0;\n    uint256 public lpRewards;\n    uint256 public totalLpToMigrate;\n    address public stakingFormulasAddress;\n    address public migrator; // temporary address to handle migration\n    address[] private _toMigrateOriginals;\n    uint256[] private _toMigrateLpBalances;\n    uint256[] private _toMigrateWeeks;\n    // toMigrateId[address] > 0 when address is to migrate, or 0 in all other cases\n    mapping(address => uint256) public toMigrateId;\n    bool public migrating = false;\n    event PriceReset(\n        address _tokenWithdrawn,\n        uint256 _amountWithdrawn,\n        uint256 _amountTransferred\n    );\n    event Deposit(\n        address indexed _user,\n        uint256 indexed _id,\n        uint256 _lpAmount,\n        uint256 _stakingShareAmount,\n        uint256 _weeks,\n        uint256 _endBlock\n    );\n    event RemoveLiquidityFromStake(\n        address indexed _user,\n        uint256 indexed _id,\n        uint256 _lpAmount,\n        uint256 _lpAmountTransferred,\n        uint256 _lpRewards,\n        uint256 _stakingShareAmount\n    );\n    event AddLiquidityFromStake(\n        address indexed _user,\n        uint256 indexed _id,\n        uint256 _lpAmount,\n        uint256 _stakingShareAmount\n    );\n    event StakingDiscountMultiplierUpdated(uint256 _stakingDiscountMultiplier);\n    event BlockCountInAWeekUpdated(uint256 _blockCountInAWeek);\n    event Migrated(\n        address indexed _user,\n        uint256 indexed _id,\n        uint256 _lpsAmount,\n        uint256 _sharesAmount,\n        uint256 _weeks\n    );\n    modifier onlyStakingManager() {\n        require(\n            manager.hasRole(manager.STAKING_MANAGER_ROLE(), msg.sender),\n            \"not manager\"\n        );\n        _;\n    }\n    modifier onlyPauser() {\n        require(\n            manager.hasRole(manager.PAUSER_ROLE(), msg.sender), \"not pauser\"\n        );\n        _;\n    }\n    modifier onlyMigrator() {\n        require(msg.sender == migrator, \"not migrator\");\n        _;\n    }\n    modifier whenMigrating() {\n        require(migrating, \"not in migration\");\n        _;\n    }\n    constructor(\n        address _manager,\n        address _stakingFormulasAddress,\n        address[] memory _originals,\n        uint256[] memory _lpBalances,\n        uint256[] memory _weeks\n    ) CollectableDust() Pausable() {\n        manager = UbiquityDollarManager(_manager);\n        stakingFormulasAddress = _stakingFormulasAddress;\n        migrator = msg.sender;\n        uint256 lgt = _originals.length;\n        require(lgt > 0, \"address array empty\");\n        require(lgt == _lpBalances.length, \"balances array not same length\");\n        require(lgt == _weeks.length, \"weeks array not same length\");\n        _toMigrateOriginals = _originals;\n        _toMigrateLpBalances = _lpBalances;\n        _toMigrateWeeks = _weeks;\n        for (uint256 i = 0; i < lgt; ++i) {\n            toMigrateId[_originals[i]] = i + 1;\n            totalLpToMigrate += _lpBalances[i];\n        }\n    }\n    // solhint-disable-next-line no-empty-blocks\n    receive() external payable {}\n    /// @dev addUserToMigrate add a user to migrate from V1.\n    ///      IMPORTANT execute that function BEFORE sending the corresponding LP token\n    ///      otherwise they will have extra LP rewards\n    /// @param _original address of v1 user\n    /// @param _lpBalance LP Balance of v1 user\n    /// @param _weeks weeks lockup of v1 user\n    /// @notice user will then be able to migrate.\n    function addUserToMigrate(\n        address _original,\n        uint256 _lpBalance,\n        uint256 _weeks\n    ) external onlyMigrator {\n        _toMigrateOriginals.push(_original);\n        _toMigrateLpBalances.push(_lpBalance);\n        totalLpToMigrate += _lpBalance;\n        _toMigrateWeeks.push(_weeks);\n        toMigrateId[_original] = _toMigrateOriginals.length;\n    }\n    function setMigrator(address _migrator) external onlyMigrator {\n        migrator = _migrator;\n    }\n    function setMigrating(bool _migrating) external onlyMigrator {\n        migrating = _migrating;\n    }\n    /// @dev dollarPriceReset remove Ubiquity Dollar unilaterally from the curve LP share sitting inside\n    ///      the staking contract and send the Ubiquity Dollar received to the treasury.\n    ///      This will have the immediate effect of pushing the Ubiquity Dollar price HIGHER\n    /// @param amount of LP token to be removed for Ubiquity Dollar\n    /// @notice it will remove one coin only from the curve LP share sitting in the staking contract\n    function dollarPriceReset(uint256 amount) external onlyStakingManager {\n        IMetaPool metaPool = IMetaPool(manager.stableSwapMetaPoolAddress());\n        // remove one coin\n        uint256 coinWithdrawn = metaPool.remove_liquidity_one_coin(amount, 0, 0);\n        ITWAPOracleDollar3pool(manager.twapOracleAddress()).update();\n        uint256 toTransfer =\n            IERC20(manager.dollarTokenAddress()).balanceOf(address(this));\n        IERC20(manager.dollarTokenAddress()).safeTransfer(\n            manager.treasuryAddress(), toTransfer\n        );\n        emit PriceReset(manager.dollarTokenAddress(), coinWithdrawn, toTransfer);\n\n    \n        \n          \n    \n\n        \n        Expand All\n    \n    @@ -192,7 +192,7 @@ contract Staking is CollectableDust, Pausable {\n  \n    }\n    /// @dev crvPriceReset remove 3CRV unilaterally from the curve LP share sitting inside\n    ///      the staking contract and send the 3CRV received to the treasury\n    ///      This will have the immediate effect of pushing the Ubiquity Dollar price LOWER\n    /// @param amount of LP token to be removed for 3CRV tokens\n    /// @notice it will remove one coin only from the curve LP share sitting in the staking contract\n    function crvPriceReset(uint256 amount) external onlyStakingManager {\n        IMetaPool metaPool = IMetaPool(manager.stableSwapMetaPoolAddress());\n        // remove one coin\n        uint256 coinWithdrawn = metaPool.remove_liquidity_one_coin(amount, 1, 0);\n        // update twap\n        ITWAPOracleDollar3pool(manager.twapOracleAddress()).update();\n        uint256 toTransfer =\n            IERC20(manager.curve3PoolTokenAddress()).balanceOf(address(this));\n        IERC20(manager.curve3PoolTokenAddress()).safeTransfer(\n            manager.treasuryAddress(), toTransfer\n        );\n        emit PriceReset(\n\n    \n          \n            \n    \n\n          \n          Expand Down\n    \n    \n  \n            manager.curve3PoolTokenAddress(), coinWithdrawn, toTransfer\n            );\n    }\n    function setStakingFormulasAddress(address _stakingFormulasAddress)\n        external\n        onlyStakingManager\n    {\n        stakingFormulasAddress = _stakingFormulasAddress;\n    }\n    /// Collectable Dust\n    function addProtocolToken(address _token)\n        external\n        override\n        onlyStakingManager\n    {\n        _addProtocolToken(_token);\n    }\n    function removeProtocolToken(address _token)\n        external\n        override\n        onlyStakingManager\n    {\n        _removeProtocolToken(_token);\n    }\n    function sendDust(address _to, address _token, uint256 _amount)\n        external\n        override\n        onlyStakingManager\n    {\n        _sendDust(_to, _token, _amount);\n    }\n    function setStakingDiscountMultiplier(uint256 _stakingDiscountMultiplier)\n        external\n        onlyStakingManager\n    {\n        stakingDiscountMultiplier = _stakingDiscountMultiplier;\n        emit StakingDiscountMultiplierUpdated(_stakingDiscountMultiplier);\n    }\n    function setBlockCountInAWeek(uint256 _blockCountInAWeek)\n        external\n        onlyStakingManager\n    {\n        blockCountInAWeek = _blockCountInAWeek;\n        emit BlockCountInAWeekUpdated(_blockCountInAWeek);\n    }\n    /// @dev deposit UbiquityDollar-3CRV LP tokens for a duration to receive staking shares\n    /// @param _lpsAmount of LP token to send\n    /// @param _weeks during lp token will be held\n    /// @notice weeks act as a multiplier for the amount of staking shares to be received\n    function deposit(uint256 _lpsAmount, uint256 _weeks)\n        external\n        whenNotPaused\n        returns (uint256 _id)\n    {\n        require(\n            1 <= _weeks && _weeks <= 208,\n            \"Staking: duration must be between 1 and 208 weeks\"\n        );\n        ITWAPOracleDollar3pool(manager.twapOracleAddress()).update();\n        // update the accumulated lp rewards per shares\n        _updateLpPerShare();\n        // transfer lp token to the staking contract\n        IERC20(manager.stableSwapMetaPoolAddress()).safeTransferFrom(\n            msg.sender, address(this), _lpsAmount\n        );\n        // calculate the amount of share based on the amount of lp deposited and the duration\n        uint256 _sharesAmount = IUbiquityFormulas(manager.formulasAddress())\n            .durationMultiply(_lpsAmount, _weeks, stakingDiscountMultiplier);\n        // calculate end locking period block number\n        uint256 _endBlock = block.number + _weeks * blockCountInAWeek;\n        _id = _mint(msg.sender, _lpsAmount, _sharesAmount, _endBlock);\n        // set masterchef for Governance rewards\n        IUbiquityChef(manager.masterChefAddress()).deposit(\n            msg.sender, _sharesAmount, _id\n        );\n        emit Deposit(\n            msg.sender, _id, _lpsAmount, _sharesAmount, _weeks, _endBlock\n            );\n    }\n    /// @dev Add an amount of UbiquityDollar-3CRV LP tokens\n    /// @param _amount of LP token to deposit\n    /// @param _id staking shares id\n    /// @param _weeks during lp token will be held\n    /// @notice staking shares are ERC1155 (aka NFT) because they have an expiration date\n    function addLiquidity(uint256 _amount, uint256 _id, uint256 _weeks)\n        external\n        whenNotPaused\n    {\n        (uint256[2] memory bs, StakingShare.Stake memory stake) =\n            _checkForLiquidity(_id);\n        // calculate pending LP rewards\n        uint256 sharesToRemove = bs[0];\n        _updateLpPerShare();\n        uint256 pendingLpReward =\n            lpRewardForShares(sharesToRemove, stake.lpRewardDebt);\n        // add an extra step to be able to decrease rewards if locking end is near\n        pendingLpReward = StakingFormulas(this.stakingFormulasAddress())\n            .lpRewardsAddLiquidityNormalization(stake, bs, pendingLpReward);\n        // add these LP Rewards to the deposited amount of LP token\n        stake.lpAmount += pendingLpReward;\n        lpRewards -= pendingLpReward;\n        IERC20(manager.stableSwapMetaPoolAddress()).safeTransferFrom(\n            msg.sender, address(this), _amount\n        );\n        stake.lpAmount += _amount;\n        // redeem all shares\n        IUbiquityChef(manager.masterChefAddress()).withdraw(\n            msg.sender, sharesToRemove, _id\n        );\n        // calculate the amount of share based on the new amount of lp deposited and the duration\n        uint256 _sharesAmount = IUbiquityFormulas(manager.formulasAddress())\n            .durationMultiply(stake.lpAmount, _weeks, stakingDiscountMultiplier);\n        // deposit new shares\n        IUbiquityChef(manager.masterChefAddress()).deposit(\n            msg.sender, _sharesAmount, _id\n        );\n        // calculate end locking period block number\n        // 1 week = 45361 blocks = 2371753*7/366\n        // n = (block + duration * 45361)\n        stake.endBlock = block.number + _weeks * blockCountInAWeek;\n        // should be done after masterchef withdraw\n        _updateLpPerShare();\n        stake.lpRewardDebt = (\n            IUbiquityChef(manager.masterChefAddress()).getStakingShareInfo(_id)[0]\n                * accLpRewardPerShare\n        ) / 1e12;\n        StakingShare(manager.stakingShareAddress()).updateStake(\n            _id, stake.lpAmount, stake.lpRewardDebt, stake.endBlock\n        );\n        emit AddLiquidityFromStake(msg.sender, _id, stake.lpAmount, _sharesAmount);\n    }\n    /// @dev Remove an amount of UbiquityDollar-3CRV LP tokens\n    /// @param _amount of LP token deposited when _id was created to be withdrawn\n    /// @param _id staking shares id\n    /// @notice staking shares are ERC1155 (aka NFT) because they have an expiration date\n    function removeLiquidity(uint256 _amount, uint256 _id)\n        external\n        whenNotPaused\n    {\n        (uint256[2] memory bs, StakingShare.Stake memory stake) =\n            _checkForLiquidity(_id);\n        require(stake.lpAmount >= _amount, \"Staking: amount too big\");\n        // we should decrease the Governance token rewards proportionally to the LP removed\n        // sharesToRemove = (staking shares * _amount )  / stake.lpAmount ;\n        uint256 sharesToRemove = StakingFormulas(this.stakingFormulasAddress())\n            .sharesForLP(stake, bs, _amount);\n        //get all its pending LP Rewards\n        _updateLpPerShare();\n        uint256 pendingLpReward = lpRewardForShares(bs[0], stake.lpRewardDebt);\n        // update staking shares\n        // stake.shares = stake.shares - sharesToRemove;\n        // get masterchef for Governance token rewards To ensure correct computation\n        // it needs to be done BEFORE updating the bonding share\n        IUbiquityChef(manager.masterChefAddress()).withdraw(\n            msg.sender, sharesToRemove, _id\n        );\n        // redeem of the extra LP\n        // staking lp balance - StakingShare.totalLP\n        IERC20 metapool = IERC20(manager.stableSwapMetaPoolAddress());\n        // add an extra step to be able to decrease rewards if locking end is near\n        pendingLpReward = StakingFormulas(this.stakingFormulasAddress())\n            .lpRewardsRemoveLiquidityNormalization(stake, bs, pendingLpReward);\n        uint256 correctedAmount = StakingFormulas(this.stakingFormulasAddress())\n            .correctedAmountToWithdraw(\n            StakingShare(manager.stakingShareAddress()).totalLP(),\n            metapool.balanceOf(address(this)) - lpRewards,\n            _amount\n        );\n        lpRewards -= pendingLpReward;\n        stake.lpAmount -= _amount;\n        // stake.lpRewardDebt = (staking shares * accLpRewardPerShare) /  1e18;\n        // user.amount.mul(pool.accSushiPerShare).div(1e12);\n        // should be done after masterchef withdraw\n        stake.lpRewardDebt = (\n            IUbiquityChef(manager.masterChefAddress()).getStakingShareInfo(_id)[0]\n                * accLpRewardPerShare\n        ) / 1e12;\n        StakingShare(manager.stakingShareAddress()).updateStake(\n            _id, stake.lpAmount, stake.lpRewardDebt, stake.endBlock\n        );\n        // lastly redeem lp tokens\n        metapool.safeTransfer(msg.sender, correctedAmount + pendingLpReward);\n        emit RemoveLiquidityFromStake(\n            msg.sender,\n            _id,\n            _amount,\n            correctedAmount,\n            pendingLpReward,\n            sharesToRemove\n            );\n    }\n    // View function to see pending lpRewards on frontend.\n    function pendingLpRewards(uint256 _id) external view returns (uint256) {\n        StakingShare staking = StakingShare(manager.stakingShareAddress());\n        StakingShare.Stake memory stake = staking.getStake(_id);\n        uint256[2] memory bs =\n            IUbiquityChef(manager.masterChefAddress()).getStakingShareInfo(_id);\n        uint256 lpBalance =\n            IERC20(manager.stableSwapMetaPoolAddress()).balanceOf(address(this));\n        // the excess LP is the current balance minus the total deposited LP\n        if (lpBalance >= (staking.totalLP() + totalLpToMigrate)) {\n            uint256 currentLpRewards =\n                lpBalance - (staking.totalLP() + totalLpToMigrate);\n            uint256 curAccLpRewardPerShare = accLpRewardPerShare;\n            // if new rewards we should calculate the new curAccLpRewardPerShare\n            if (currentLpRewards > lpRewards) {\n                uint256 newLpRewards = currentLpRewards - lpRewards;\n                curAccLpRewardPerShare = accLpRewardPerShare\n                    + (\n                        (newLpRewards * 1e12)\n                            / IUbiquityChef(manager.masterChefAddress()).totalShares()\n                    );\n            }\n            // we multiply the shares amount by the accumulated lpRewards per share\n            // and remove the lp Reward Debt\n            return (bs[0] * (curAccLpRewardPerShare)) / (1e12)\n                - (stake.lpRewardDebt);\n        }\n        return 0;\n    }\n    function pause() public virtual onlyPauser {\n        _pause();\n    }\n    function unpause() public virtual onlyPauser {\n        _unpause();\n    }\n    /// @dev migrate let a user migrate from V1\n    /// @notice user will then be able to migrate\n    function migrate() public whenMigrating returns (uint256 _id) {\n        _id = toMigrateId[msg.sender];\n        require(_id > 0, \"not v1 address\");\n        _migrate(\n            _toMigrateOriginals[_id - 1],\n            _toMigrateLpBalances[_id - 1],\n            _toMigrateWeeks[_id - 1]\n        );\n    }\n    /// @dev return the amount of Lp token rewards an amount of shares entitled\n    /// @param amount of staking shares\n    /// @param lpRewardDebt lp rewards that has already been distributed\n    function lpRewardForShares(uint256 amount, uint256 lpRewardDebt)\n        public\n        view\n        returns (uint256 pendingLpReward)\n    {\n        if (accLpRewardPerShare > 0) {\n            pendingLpReward =\n                (amount * accLpRewardPerShare) / 1e12 - (lpRewardDebt);\n        }\n    }\n    function currentShareValue() public view returns (uint256 priceShare) {\n        uint256 totalShares =\n            IUbiquityChef(manager.masterChefAddress()).totalShares();\n        // priceShare = totalLP / totalShares\n        priceShare = IUbiquityFormulas(manager.formulasAddress()).bondPrice(\n            StakingShare(manager.stakingShareAddress()).totalLP(),\n            totalShares,\n            ONE\n        );\n    }\n    /// @dev migrate let a user migrate from V1\n    /// @notice user will then be able to migrate\n    function _migrate(address user, uint256 _lpsAmount, uint256 _weeks)\n        internal\n        returns (uint256 _id)\n    {\n        require(toMigrateId[user] > 0, \"not v1 address\");\n        require(_lpsAmount > 0, \"LP amount is zero\");\n        require(\n            1 <= _weeks && _weeks <= 208,\n            \"Duration must be between 1 and 208 weeks\"\n        );\n        // unregister address\n        toMigrateId[user] = 0;\n        // calculate the amount of share based on the amount of lp deposited and the duration\n        uint256 _sharesAmount = IUbiquityFormulas(manager.formulasAddress())\n            .durationMultiply(_lpsAmount, _weeks, stakingDiscountMultiplier);\n        // update the accumulated lp rewards per shares\n        _updateLpPerShare();\n        // calculate end locking period block number\n        uint256 endBlock = block.number + _weeks * blockCountInAWeek;\n        _id = _mint(user, _lpsAmount, _sharesAmount, endBlock);\n        // reduce the total LP to migrate after the minting\n        // to keep the _updateLpPerShare calculation consistent\n        totalLpToMigrate -= _lpsAmount;\n        // set masterchef for Governance token rewards\n        IUbiquityChef(manager.masterChefAddress()).deposit(\n            user, _sharesAmount, _id\n        );\n        emit Migrated(user, _id, _lpsAmount, _sharesAmount, _weeks);\n    }\n    /// @dev update the accumulated excess LP per share\n    function _updateLpPerShare() internal {\n        StakingShare stake = StakingShare(manager.stakingShareAddress());\n        uint256 lpBalance =\n            IERC20(manager.stableSwapMetaPoolAddress()).balanceOf(address(this));\n        // the excess LP is the current balance\n        // minus the total deposited LP + LP that needs to be migrated\n        uint256 totalShares =\n            IUbiquityChef(manager.masterChefAddress()).totalShares();\n        if (lpBalance >= (stake.totalLP() + totalLpToMigrate) && totalShares > 0)\n        {\n            uint256 currentLpRewards =\n                lpBalance - (stake.totalLP() + totalLpToMigrate);\n            // is there new LP rewards to be distributed ?\n            if (currentLpRewards > lpRewards) {\n                // we calculate the new accumulated LP rewards per share\n                accLpRewardPerShare = accLpRewardPerShare\n                    + (((currentLpRewards - lpRewards) * 1e12) / totalShares);\n                // update the bonding contract lpRewards\n                lpRewards = currentLpRewards;\n            }\n        }\n    }\n    function _mint(\n        address to,\n        uint256 lpAmount,\n        uint256 shares,\n        uint256 endBlock\n    ) internal returns (uint256) {\n        uint256 _currentShareValue = currentShareValue();\n        require(\n            _currentShareValue != 0, \"Staking: share value should not be null\"\n        );\n        // set the lp rewards debts so that this staking share only get lp rewards from this day\n        uint256 lpRewardDebt = (shares * accLpRewardPerShare) / 1e12;\n        return StakingShare(manager.stakingShareAddress()).mint(\n            to, lpAmount, lpRewardDebt, endBlock\n        );\n    }\n    function _checkForLiquidity(uint256 _id)\n        internal\n        returns (uint256[2] memory bs, StakingShare.Stake memory stake)\n    {\n        require(\n            IERC1155Ubiquity(manager.stakingShareAddress()).balanceOf(\n                msg.sender, _id\n            ) == 1,\n            \"Staking: caller is not owner\"\n        );\n        StakingShare staking = StakingShare(manager.stakingShareAddress());\n        stake = staking.getStake(_id);\n        require(\n            block.number > stake.endBlock,\n            \"Staking: Redeem not allowed before staking time\"\n        );\n        ITWAPOracleDollar3pool(manager.twapOracleAddress()).update();\n        bs = IUbiquityChef(manager.masterChefAddress()).getStakingShareInfo(_id);\n    }\n}"
    },
    {
        "tag": "Unchecked Return Values For Low Level Calls",
        "url": "https://github.com/ubiquity/ubiquity-dollar/commit/70e52801adb84103448c3b0ed25315eaeed53988",
        "file": "packages/contracts/src/dollar/Staking.sol",
        "before": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\nimport \"./core/UbiquityDollarToken.sol\";\nimport \"./core/UbiquityDollarManager.sol\";\nimport \"./interfaces/IERC1155Ubiquity.sol\";\nimport \"./interfaces/IMetaPool.sol\";\nimport \"./interfaces/IUbiquityFormulas.sol\";\nimport \"./interfaces/ISablier.sol\";\nimport \"./interfaces/IUbiquityChef.sol\";\nimport \"./interfaces/ITWAPOracleDollar3pool.sol\";\nimport \"./interfaces/IERC1155Ubiquity.sol\";\nimport \"./utils/CollectableDust.sol\";\nimport \"./StakingFormulas.sol\";\nimport \"./StakingShare.sol\";\ncontract Staking is CollectableDust, Pausable {\n    using SafeERC20 for IERC20;\n    bytes public data = \"\";\n    UbiquityDollarManager public manager;\n    uint256 public constant ONE = uint256(1 ether); // 3Crv has 18 decimals\n    uint256 public stakingDiscountMultiplier = uint256(1000000 gwei); // 0.001\n    uint256 public blockCountInAWeek = 45361;\n    uint256 public accLpRewardPerShare = 0;\n    uint256 public lpRewards;\n    uint256 public totalLpToMigrate;\n    address public stakingFormulasAddress;\n    address public migrator; // temporary address to handle migration\n    address[] private _toMigrateOriginals;\n    uint256[] private _toMigrateLpBalances;\n    uint256[] private _toMigrateWeeks;\n    // toMigrateId[address] > 0 when address is to migrate, or 0 in all other cases\n    mapping(address => uint256) public toMigrateId;\n    bool public migrating = false;\n    event PriceReset(\n        address _tokenWithdrawn,\n        uint256 _amountWithdrawn,\n        uint256 _amountTransferred\n    );\n    event Deposit(\n        address indexed _user,\n        uint256 indexed _id,\n        uint256 _lpAmount,\n        uint256 _stakingShareAmount,\n        uint256 _weeks,\n        uint256 _endBlock\n    );\n    event RemoveLiquidityFromStake(\n        address indexed _user,\n        uint256 indexed _id,\n        uint256 _lpAmount,\n        uint256 _lpAmountTransferred,\n        uint256 _lpRewards,\n        uint256 _stakingShareAmount\n    );\n    event AddLiquidityFromStake(\n        address indexed _user,\n        uint256 indexed _id,\n        uint256 _lpAmount,\n        uint256 _stakingShareAmount\n    );\n    event StakingDiscountMultiplierUpdated(uint256 _stakingDiscountMultiplier);\n    event BlockCountInAWeekUpdated(uint256 _blockCountInAWeek);\n    event Migrated(\n        address indexed _user,\n        uint256 indexed _id,\n        uint256 _lpsAmount,\n        uint256 _sharesAmount,\n        uint256 _weeks\n    );\n    modifier onlyStakingManager() {\n        require(\n            manager.hasRole(manager.STAKING_MANAGER_ROLE(), msg.sender),\n            \"not manager\"\n        );\n        _;\n    }\n    modifier onlyPauser() {\n        require(\n            manager.hasRole(manager.PAUSER_ROLE(), msg.sender), \"not pauser\"\n        );\n        _;\n    }\n    modifier onlyMigrator() {\n        require(msg.sender == migrator, \"not migrator\");\n        _;\n    }\n    modifier whenMigrating() {\n        require(migrating, \"not in migration\");\n        _;\n    }\n    constructor(\n        address _manager,\n        address _stakingFormulasAddress,\n        address[] memory _originals,\n        uint256[] memory _lpBalances,\n        uint256[] memory _weeks\n    ) CollectableDust() Pausable() {\n        manager = UbiquityDollarManager(_manager);\n        stakingFormulasAddress = _stakingFormulasAddress;\n        migrator = msg.sender;\n        uint256 lgt = _originals.length;\n        require(lgt > 0, \"address array empty\");\n        require(lgt == _lpBalances.length, \"balances array not same length\");\n        require(lgt == _weeks.length, \"weeks array not same length\");\n        _toMigrateOriginals = _originals;\n        _toMigrateLpBalances = _lpBalances;\n        _toMigrateWeeks = _weeks;\n        for (uint256 i = 0; i < lgt; ++i) {\n            toMigrateId[_originals[i]] = i + 1;\n            totalLpToMigrate += _lpBalances[i];\n        }\n    }\n    // solhint-disable-next-line no-empty-blocks\n    receive() external payable {}\n    /// @dev addUserToMigrate add a user to migrate from V1.\n    ///      IMPORTANT execute that function BEFORE sending the corresponding LP token\n    ///      otherwise they will have extra LP rewards\n    /// @param _original address of v1 user\n    /// @param _lpBalance LP Balance of v1 user\n    /// @param _weeks weeks lockup of v1 user\n    /// @notice user will then be able to migrate.\n    function addUserToMigrate(\n        address _original,\n        uint256 _lpBalance,\n        uint256 _weeks\n    ) external onlyMigrator {\n        _toMigrateOriginals.push(_original);\n        _toMigrateLpBalances.push(_lpBalance);\n        totalLpToMigrate += _lpBalance;\n        _toMigrateWeeks.push(_weeks);\n        toMigrateId[_original] = _toMigrateOriginals.length;\n    }\n    function setMigrator(address _migrator) external onlyMigrator {\n        migrator = _migrator;\n    }\n    function setMigrating(bool _migrating) external onlyMigrator {\n        migrating = _migrating;\n    }\n    /// @dev dollarPriceReset remove Ubiquity Dollar unilaterally from the curve LP share sitting inside\n    ///      the staking contract and send the Ubiquity Dollar received to the treasury.\n    ///      This will have the immediate effect of pushing the Ubiquity Dollar price HIGHER\n    /// @param amount of LP token to be removed for Ubiquity Dollar\n    /// @notice it will remove one coin only from the curve LP share sitting in the staking contract\n    function dollarPriceReset(uint256 amount) external onlyStakingManager {\n        IMetaPool metaPool = IMetaPool(manager.stableSwapMetaPoolAddress());\n        // remove one coin\n        uint256 coinWithdrawn = metaPool.remove_liquidity_one_coin(amount, 0, 0);\n        ITWAPOracleDollar3pool(manager.twapOracleAddress()).update();\n        uint256 toTransfer =\n            IERC20(manager.dollarTokenAddress()).balanceOf(address(this));\n        IERC20(manager.dollarTokenAddress()).transfer(\n            manager.treasuryAddress(), toTransfer\n        );\n        emit PriceReset(manager.dollarTokenAddress(), coinWithdrawn, toTransfer);\n\n    \n        \n          \n    \n\n        \n        Expand All\n    \n    @@ -192,7 +192,7 @@ contract Staking is CollectableDust, Pausable {\n  \n    }\n    /// @dev crvPriceReset remove 3CRV unilaterally from the curve LP share sitting inside\n    ///      the staking contract and send the 3CRV received to the treasury\n    ///      This will have the immediate effect of pushing the Ubiquity Dollar price LOWER\n    /// @param amount of LP token to be removed for 3CRV tokens\n    /// @notice it will remove one coin only from the curve LP share sitting in the staking contract\n    function crvPriceReset(uint256 amount) external onlyStakingManager {\n        IMetaPool metaPool = IMetaPool(manager.stableSwapMetaPoolAddress());\n        // remove one coin\n        uint256 coinWithdrawn = metaPool.remove_liquidity_one_coin(amount, 1, 0);\n        // update twap\n        ITWAPOracleDollar3pool(manager.twapOracleAddress()).update();\n        uint256 toTransfer =\n            IERC20(manager.curve3PoolTokenAddress()).balanceOf(address(this));\n        IERC20(manager.curve3PoolTokenAddress()).transfer(\n            manager.treasuryAddress(), toTransfer\n        );\n        emit PriceReset(\n\n    \n          \n            \n    \n\n          \n          Expand Down\n    \n    \n  \n            manager.curve3PoolTokenAddress(), coinWithdrawn, toTransfer\n            );\n    }\n    function setStakingFormulasAddress(address _stakingFormulasAddress)\n        external\n        onlyStakingManager\n    {\n        stakingFormulasAddress = _stakingFormulasAddress;\n    }\n    /// Collectable Dust\n    function addProtocolToken(address _token)\n        external\n        override\n        onlyStakingManager\n    {\n        _addProtocolToken(_token);\n    }\n    function removeProtocolToken(address _token)\n        external\n        override\n        onlyStakingManager\n    {\n        _removeProtocolToken(_token);\n    }\n    function sendDust(address _to, address _token, uint256 _amount)\n        external\n        override\n        onlyStakingManager\n    {\n        _sendDust(_to, _token, _amount);\n    }\n    function setStakingDiscountMultiplier(uint256 _stakingDiscountMultiplier)\n        external\n        onlyStakingManager\n    {\n        stakingDiscountMultiplier = _stakingDiscountMultiplier;\n        emit StakingDiscountMultiplierUpdated(_stakingDiscountMultiplier);\n    }\n    function setBlockCountInAWeek(uint256 _blockCountInAWeek)\n        external\n        onlyStakingManager\n    {\n        blockCountInAWeek = _blockCountInAWeek;\n        emit BlockCountInAWeekUpdated(_blockCountInAWeek);\n    }\n    /// @dev deposit UbiquityDollar-3CRV LP tokens for a duration to receive staking shares\n    /// @param _lpsAmount of LP token to send\n    /// @param _weeks during lp token will be held\n    /// @notice weeks act as a multiplier for the amount of staking shares to be received\n    function deposit(uint256 _lpsAmount, uint256 _weeks)\n        external\n        whenNotPaused\n        returns (uint256 _id)\n    {\n        require(\n            1 <= _weeks && _weeks <= 208,\n            \"Staking: duration must be between 1 and 208 weeks\"\n        );\n        ITWAPOracleDollar3pool(manager.twapOracleAddress()).update();\n        // update the accumulated lp rewards per shares\n        _updateLpPerShare();\n        // transfer lp token to the staking contract\n        IERC20(manager.stableSwapMetaPoolAddress()).safeTransferFrom(\n            msg.sender, address(this), _lpsAmount\n        );\n        // calculate the amount of share based on the amount of lp deposited and the duration\n        uint256 _sharesAmount = IUbiquityFormulas(manager.formulasAddress())\n            .durationMultiply(_lpsAmount, _weeks, stakingDiscountMultiplier);\n        // calculate end locking period block number\n        uint256 _endBlock = block.number + _weeks * blockCountInAWeek;\n        _id = _mint(msg.sender, _lpsAmount, _sharesAmount, _endBlock);\n        // set masterchef for Governance rewards\n        IUbiquityChef(manager.masterChefAddress()).deposit(\n            msg.sender, _sharesAmount, _id\n        );\n        emit Deposit(\n            msg.sender, _id, _lpsAmount, _sharesAmount, _weeks, _endBlock\n            );\n    }\n    /// @dev Add an amount of UbiquityDollar-3CRV LP tokens\n    /// @param _amount of LP token to deposit\n    /// @param _id staking shares id\n    /// @param _weeks during lp token will be held\n    /// @notice staking shares are ERC1155 (aka NFT) because they have an expiration date\n    function addLiquidity(uint256 _amount, uint256 _id, uint256 _weeks)\n        external\n        whenNotPaused\n    {\n        (uint256[2] memory bs, StakingShare.Stake memory stake) =\n            _checkForLiquidity(_id);\n        // calculate pending LP rewards\n        uint256 sharesToRemove = bs[0];\n        _updateLpPerShare();\n        uint256 pendingLpReward =\n            lpRewardForShares(sharesToRemove, stake.lpRewardDebt);\n        // add an extra step to be able to decrease rewards if locking end is near\n        pendingLpReward = StakingFormulas(this.stakingFormulasAddress())\n            .lpRewardsAddLiquidityNormalization(stake, bs, pendingLpReward);\n        // add these LP Rewards to the deposited amount of LP token\n        stake.lpAmount += pendingLpReward;\n        lpRewards -= pendingLpReward;\n        IERC20(manager.stableSwapMetaPoolAddress()).safeTransferFrom(\n            msg.sender, address(this), _amount\n        );\n        stake.lpAmount += _amount;\n        // redeem all shares\n        IUbiquityChef(manager.masterChefAddress()).withdraw(\n            msg.sender, sharesToRemove, _id\n        );\n        // calculate the amount of share based on the new amount of lp deposited and the duration\n        uint256 _sharesAmount = IUbiquityFormulas(manager.formulasAddress())\n            .durationMultiply(stake.lpAmount, _weeks, stakingDiscountMultiplier);\n        // deposit new shares\n        IUbiquityChef(manager.masterChefAddress()).deposit(\n            msg.sender, _sharesAmount, _id\n        );\n        // calculate end locking period block number\n        // 1 week = 45361 blocks = 2371753*7/366\n        // n = (block + duration * 45361)\n        stake.endBlock = block.number + _weeks * blockCountInAWeek;\n        // should be done after masterchef withdraw\n        _updateLpPerShare();\n        stake.lpRewardDebt = (\n            IUbiquityChef(manager.masterChefAddress()).getStakingShareInfo(_id)[0]\n                * accLpRewardPerShare\n        ) / 1e12;\n        StakingShare(manager.stakingShareAddress()).updateStake(\n            _id, stake.lpAmount, stake.lpRewardDebt, stake.endBlock\n        );\n        emit AddLiquidityFromStake(msg.sender, _id, stake.lpAmount, _sharesAmount);\n    }\n    /// @dev Remove an amount of UbiquityDollar-3CRV LP tokens\n    /// @param _amount of LP token deposited when _id was created to be withdrawn\n    /// @param _id staking shares id\n    /// @notice staking shares are ERC1155 (aka NFT) because they have an expiration date\n    function removeLiquidity(uint256 _amount, uint256 _id)\n        external\n        whenNotPaused\n    {\n        (uint256[2] memory bs, StakingShare.Stake memory stake) =\n            _checkForLiquidity(_id);\n        require(stake.lpAmount >= _amount, \"Staking: amount too big\");\n        // we should decrease the Governance token rewards proportionally to the LP removed\n        // sharesToRemove = (staking shares * _amount )  / stake.lpAmount ;\n        uint256 sharesToRemove = StakingFormulas(this.stakingFormulasAddress())\n            .sharesForLP(stake, bs, _amount);\n        //get all its pending LP Rewards\n        _updateLpPerShare();\n        uint256 pendingLpReward = lpRewardForShares(bs[0], stake.lpRewardDebt);\n        // update staking shares\n        // stake.shares = stake.shares - sharesToRemove;\n        // get masterchef for Governance token rewards To ensure correct computation\n        // it needs to be done BEFORE updating the bonding share\n        IUbiquityChef(manager.masterChefAddress()).withdraw(\n            msg.sender, sharesToRemove, _id\n        );\n        // redeem of the extra LP\n        // staking lp balance - StakingShare.totalLP\n        IERC20 metapool = IERC20(manager.stableSwapMetaPoolAddress());\n        // add an extra step to be able to decrease rewards if locking end is near\n        pendingLpReward = StakingFormulas(this.stakingFormulasAddress())\n            .lpRewardsRemoveLiquidityNormalization(stake, bs, pendingLpReward);\n        uint256 correctedAmount = StakingFormulas(this.stakingFormulasAddress())\n            .correctedAmountToWithdraw(\n            StakingShare(manager.stakingShareAddress()).totalLP(),\n            metapool.balanceOf(address(this)) - lpRewards,\n            _amount\n        );\n        lpRewards -= pendingLpReward;\n        stake.lpAmount -= _amount;\n        // stake.lpRewardDebt = (staking shares * accLpRewardPerShare) /  1e18;\n        // user.amount.mul(pool.accSushiPerShare).div(1e12);\n        // should be done after masterchef withdraw\n        stake.lpRewardDebt = (\n            IUbiquityChef(manager.masterChefAddress()).getStakingShareInfo(_id)[0]\n                * accLpRewardPerShare\n        ) / 1e12;\n        StakingShare(manager.stakingShareAddress()).updateStake(\n            _id, stake.lpAmount, stake.lpRewardDebt, stake.endBlock\n        );\n        // lastly redeem lp tokens\n        metapool.safeTransfer(msg.sender, correctedAmount + pendingLpReward);\n        emit RemoveLiquidityFromStake(\n            msg.sender,\n            _id,\n            _amount,\n            correctedAmount,\n            pendingLpReward,\n            sharesToRemove\n            );\n    }\n    // View function to see pending lpRewards on frontend.\n    function pendingLpRewards(uint256 _id) external view returns (uint256) {\n        StakingShare staking = StakingShare(manager.stakingShareAddress());\n        StakingShare.Stake memory stake = staking.getStake(_id);\n        uint256[2] memory bs =\n            IUbiquityChef(manager.masterChefAddress()).getStakingShareInfo(_id);\n        uint256 lpBalance =\n            IERC20(manager.stableSwapMetaPoolAddress()).balanceOf(address(this));\n        // the excess LP is the current balance minus the total deposited LP\n        if (lpBalance >= (staking.totalLP() + totalLpToMigrate)) {\n            uint256 currentLpRewards =\n                lpBalance - (staking.totalLP() + totalLpToMigrate);\n            uint256 curAccLpRewardPerShare = accLpRewardPerShare;\n            // if new rewards we should calculate the new curAccLpRewardPerShare\n            if (currentLpRewards > lpRewards) {\n                uint256 newLpRewards = currentLpRewards - lpRewards;\n                curAccLpRewardPerShare = accLpRewardPerShare\n                    + (\n                        (newLpRewards * 1e12)\n                            / IUbiquityChef(manager.masterChefAddress()).totalShares()\n                    );\n            }\n            // we multiply the shares amount by the accumulated lpRewards per share\n            // and remove the lp Reward Debt\n            return (bs[0] * (curAccLpRewardPerShare)) / (1e12)\n                - (stake.lpRewardDebt);\n        }\n        return 0;\n    }\n    function pause() public virtual onlyPauser {\n        _pause();\n    }\n    function unpause() public virtual onlyPauser {\n        _unpause();\n    }\n    /// @dev migrate let a user migrate from V1\n    /// @notice user will then be able to migrate\n    function migrate() public whenMigrating returns (uint256 _id) {\n        _id = toMigrateId[msg.sender];\n        require(_id > 0, \"not v1 address\");\n        _migrate(\n            _toMigrateOriginals[_id - 1],\n            _toMigrateLpBalances[_id - 1],\n            _toMigrateWeeks[_id - 1]\n        );\n    }\n    /// @dev return the amount of Lp token rewards an amount of shares entitled\n    /// @param amount of staking shares\n    /// @param lpRewardDebt lp rewards that has already been distributed\n    function lpRewardForShares(uint256 amount, uint256 lpRewardDebt)\n        public\n        view\n        returns (uint256 pendingLpReward)\n    {\n        if (accLpRewardPerShare > 0) {\n            pendingLpReward =\n                (amount * accLpRewardPerShare) / 1e12 - (lpRewardDebt);\n        }\n    }\n    function currentShareValue() public view returns (uint256 priceShare) {\n        uint256 totalShares =\n            IUbiquityChef(manager.masterChefAddress()).totalShares();\n        // priceShare = totalLP / totalShares\n        priceShare = IUbiquityFormulas(manager.formulasAddress()).bondPrice(\n            StakingShare(manager.stakingShareAddress()).totalLP(),\n            totalShares,\n            ONE\n        );\n    }\n    /// @dev migrate let a user migrate from V1\n    /// @notice user will then be able to migrate\n    function _migrate(address user, uint256 _lpsAmount, uint256 _weeks)\n        internal\n        returns (uint256 _id)\n    {\n        require(toMigrateId[user] > 0, \"not v1 address\");\n        require(_lpsAmount > 0, \"LP amount is zero\");\n        require(\n            1 <= _weeks && _weeks <= 208,\n            \"Duration must be between 1 and 208 weeks\"\n        );\n        // unregister address\n        toMigrateId[user] = 0;\n        // calculate the amount of share based on the amount of lp deposited and the duration\n        uint256 _sharesAmount = IUbiquityFormulas(manager.formulasAddress())\n            .durationMultiply(_lpsAmount, _weeks, stakingDiscountMultiplier);\n        // update the accumulated lp rewards per shares\n        _updateLpPerShare();\n        // calculate end locking period block number\n        uint256 endBlock = block.number + _weeks * blockCountInAWeek;\n        _id = _mint(user, _lpsAmount, _sharesAmount, endBlock);\n        // reduce the total LP to migrate after the minting\n        // to keep the _updateLpPerShare calculation consistent\n        totalLpToMigrate -= _lpsAmount;\n        // set masterchef for Governance token rewards\n        IUbiquityChef(manager.masterChefAddress()).deposit(\n            user, _sharesAmount, _id\n        );\n        emit Migrated(user, _id, _lpsAmount, _sharesAmount, _weeks);\n    }\n    /// @dev update the accumulated excess LP per share\n    function _updateLpPerShare() internal {\n        StakingShare stake = StakingShare(manager.stakingShareAddress());\n        uint256 lpBalance =\n            IERC20(manager.stableSwapMetaPoolAddress()).balanceOf(address(this));\n        // the excess LP is the current balance\n        // minus the total deposited LP + LP that needs to be migrated\n        uint256 totalShares =\n            IUbiquityChef(manager.masterChefAddress()).totalShares();\n        if (lpBalance >= (stake.totalLP() + totalLpToMigrate) && totalShares > 0)\n        {\n            uint256 currentLpRewards =\n                lpBalance - (stake.totalLP() + totalLpToMigrate);\n            // is there new LP rewards to be distributed ?\n            if (currentLpRewards > lpRewards) {\n                // we calculate the new accumulated LP rewards per share\n                accLpRewardPerShare = accLpRewardPerShare\n                    + (((currentLpRewards - lpRewards) * 1e12) / totalShares);\n                // update the bonding contract lpRewards\n                lpRewards = currentLpRewards;\n            }\n        }\n    }\n    function _mint(\n        address to,\n        uint256 lpAmount,\n        uint256 shares,\n        uint256 endBlock\n    ) internal returns (uint256) {\n        uint256 _currentShareValue = currentShareValue();\n        require(\n            _currentShareValue != 0, \"Staking: share value should not be null\"\n        );\n        // set the lp rewards debts so that this staking share only get lp rewards from this day\n        uint256 lpRewardDebt = (shares * accLpRewardPerShare) / 1e12;\n        return StakingShare(manager.stakingShareAddress()).mint(\n            to, lpAmount, lpRewardDebt, endBlock\n        );\n    }\n    function _checkForLiquidity(uint256 _id)\n        internal\n        returns (uint256[2] memory bs, StakingShare.Stake memory stake)\n    {\n        require(\n            IERC1155Ubiquity(manager.stakingShareAddress()).balanceOf(\n                msg.sender, _id\n            ) == 1,\n            \"Staking: caller is not owner\"\n        );\n        StakingShare staking = StakingShare(manager.stakingShareAddress());\n        stake = staking.getStake(_id);\n        require(\n            block.number > stake.endBlock,\n            \"Staking: Redeem not allowed before staking time\"\n        );\n        ITWAPOracleDollar3pool(manager.twapOracleAddress()).update();\n        bs = IUbiquityChef(manager.masterChefAddress()).getStakingShareInfo(_id);\n    }\n}",
        "after": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\nimport \"./core/UbiquityDollarToken.sol\";\nimport \"./core/UbiquityDollarManager.sol\";\nimport \"./interfaces/IERC1155Ubiquity.sol\";\nimport \"./interfaces/IMetaPool.sol\";\nimport \"./interfaces/IUbiquityFormulas.sol\";\nimport \"./interfaces/ISablier.sol\";\nimport \"./interfaces/IUbiquityChef.sol\";\nimport \"./interfaces/ITWAPOracleDollar3pool.sol\";\nimport \"./interfaces/IERC1155Ubiquity.sol\";\nimport \"./utils/CollectableDust.sol\";\nimport \"./StakingFormulas.sol\";\nimport \"./StakingShare.sol\";\ncontract Staking is CollectableDust, Pausable {\n    using SafeERC20 for IERC20;\n    bytes public data = \"\";\n    UbiquityDollarManager public manager;\n    uint256 public constant ONE = uint256(1 ether); // 3Crv has 18 decimals\n    uint256 public stakingDiscountMultiplier = uint256(1000000 gwei); // 0.001\n    uint256 public blockCountInAWeek = 45361;\n    uint256 public accLpRewardPerShare = 0;\n    uint256 public lpRewards;\n    uint256 public totalLpToMigrate;\n    address public stakingFormulasAddress;\n    address public migrator; // temporary address to handle migration\n    address[] private _toMigrateOriginals;\n    uint256[] private _toMigrateLpBalances;\n    uint256[] private _toMigrateWeeks;\n    // toMigrateId[address] > 0 when address is to migrate, or 0 in all other cases\n    mapping(address => uint256) public toMigrateId;\n    bool public migrating = false;\n    event PriceReset(\n        address _tokenWithdrawn,\n        uint256 _amountWithdrawn,\n        uint256 _amountTransferred\n    );\n    event Deposit(\n        address indexed _user,\n        uint256 indexed _id,\n        uint256 _lpAmount,\n        uint256 _stakingShareAmount,\n        uint256 _weeks,\n        uint256 _endBlock\n    );\n    event RemoveLiquidityFromStake(\n        address indexed _user,\n        uint256 indexed _id,\n        uint256 _lpAmount,\n        uint256 _lpAmountTransferred,\n        uint256 _lpRewards,\n        uint256 _stakingShareAmount\n    );\n    event AddLiquidityFromStake(\n        address indexed _user,\n        uint256 indexed _id,\n        uint256 _lpAmount,\n        uint256 _stakingShareAmount\n    );\n    event StakingDiscountMultiplierUpdated(uint256 _stakingDiscountMultiplier);\n    event BlockCountInAWeekUpdated(uint256 _blockCountInAWeek);\n    event Migrated(\n        address indexed _user,\n        uint256 indexed _id,\n        uint256 _lpsAmount,\n        uint256 _sharesAmount,\n        uint256 _weeks\n    );\n    modifier onlyStakingManager() {\n        require(\n            manager.hasRole(manager.STAKING_MANAGER_ROLE(), msg.sender),\n            \"not manager\"\n        );\n        _;\n    }\n    modifier onlyPauser() {\n        require(\n            manager.hasRole(manager.PAUSER_ROLE(), msg.sender), \"not pauser\"\n        );\n        _;\n    }\n    modifier onlyMigrator() {\n        require(msg.sender == migrator, \"not migrator\");\n        _;\n    }\n    modifier whenMigrating() {\n        require(migrating, \"not in migration\");\n        _;\n    }\n    constructor(\n        address _manager,\n        address _stakingFormulasAddress,\n        address[] memory _originals,\n        uint256[] memory _lpBalances,\n        uint256[] memory _weeks\n    ) CollectableDust() Pausable() {\n        manager = UbiquityDollarManager(_manager);\n        stakingFormulasAddress = _stakingFormulasAddress;\n        migrator = msg.sender;\n        uint256 lgt = _originals.length;\n        require(lgt > 0, \"address array empty\");\n        require(lgt == _lpBalances.length, \"balances array not same length\");\n        require(lgt == _weeks.length, \"weeks array not same length\");\n        _toMigrateOriginals = _originals;\n        _toMigrateLpBalances = _lpBalances;\n        _toMigrateWeeks = _weeks;\n        for (uint256 i = 0; i < lgt; ++i) {\n            toMigrateId[_originals[i]] = i + 1;\n            totalLpToMigrate += _lpBalances[i];\n        }\n    }\n    // solhint-disable-next-line no-empty-blocks\n    receive() external payable {}\n    /// @dev addUserToMigrate add a user to migrate from V1.\n    ///      IMPORTANT execute that function BEFORE sending the corresponding LP token\n    ///      otherwise they will have extra LP rewards\n    /// @param _original address of v1 user\n    /// @param _lpBalance LP Balance of v1 user\n    /// @param _weeks weeks lockup of v1 user\n    /// @notice user will then be able to migrate.\n    function addUserToMigrate(\n        address _original,\n        uint256 _lpBalance,\n        uint256 _weeks\n    ) external onlyMigrator {\n        _toMigrateOriginals.push(_original);\n        _toMigrateLpBalances.push(_lpBalance);\n        totalLpToMigrate += _lpBalance;\n        _toMigrateWeeks.push(_weeks);\n        toMigrateId[_original] = _toMigrateOriginals.length;\n    }\n    function setMigrator(address _migrator) external onlyMigrator {\n        migrator = _migrator;\n    }\n    function setMigrating(bool _migrating) external onlyMigrator {\n        migrating = _migrating;\n    }\n    /// @dev dollarPriceReset remove Ubiquity Dollar unilaterally from the curve LP share sitting inside\n    ///      the staking contract and send the Ubiquity Dollar received to the treasury.\n    ///      This will have the immediate effect of pushing the Ubiquity Dollar price HIGHER\n    /// @param amount of LP token to be removed for Ubiquity Dollar\n    /// @notice it will remove one coin only from the curve LP share sitting in the staking contract\n    function dollarPriceReset(uint256 amount) external onlyStakingManager {\n        IMetaPool metaPool = IMetaPool(manager.stableSwapMetaPoolAddress());\n        // remove one coin\n        uint256 coinWithdrawn = metaPool.remove_liquidity_one_coin(amount, 0, 0);\n        ITWAPOracleDollar3pool(manager.twapOracleAddress()).update();\n        uint256 toTransfer =\n            IERC20(manager.dollarTokenAddress()).balanceOf(address(this));\n        IERC20(manager.dollarTokenAddress()).safeTransfer(\n            manager.treasuryAddress(), toTransfer\n        );\n        emit PriceReset(manager.dollarTokenAddress(), coinWithdrawn, toTransfer);\n\n    \n        \n          \n    \n\n        \n        Expand All\n    \n    @@ -192,7 +192,7 @@ contract Staking is CollectableDust, Pausable {\n  \n    }\n    /// @dev crvPriceReset remove 3CRV unilaterally from the curve LP share sitting inside\n    ///      the staking contract and send the 3CRV received to the treasury\n    ///      This will have the immediate effect of pushing the Ubiquity Dollar price LOWER\n    /// @param amount of LP token to be removed for 3CRV tokens\n    /// @notice it will remove one coin only from the curve LP share sitting in the staking contract\n    function crvPriceReset(uint256 amount) external onlyStakingManager {\n        IMetaPool metaPool = IMetaPool(manager.stableSwapMetaPoolAddress());\n        // remove one coin\n        uint256 coinWithdrawn = metaPool.remove_liquidity_one_coin(amount, 1, 0);\n        // update twap\n        ITWAPOracleDollar3pool(manager.twapOracleAddress()).update();\n        uint256 toTransfer =\n            IERC20(manager.curve3PoolTokenAddress()).balanceOf(address(this));\n        IERC20(manager.curve3PoolTokenAddress()).safeTransfer(\n            manager.treasuryAddress(), toTransfer\n        );\n        emit PriceReset(\n\n    \n          \n            \n    \n\n          \n          Expand Down\n    \n    \n  \n            manager.curve3PoolTokenAddress(), coinWithdrawn, toTransfer\n            );\n    }\n    function setStakingFormulasAddress(address _stakingFormulasAddress)\n        external\n        onlyStakingManager\n    {\n        stakingFormulasAddress = _stakingFormulasAddress;\n    }\n    /// Collectable Dust\n    function addProtocolToken(address _token)\n        external\n        override\n        onlyStakingManager\n    {\n        _addProtocolToken(_token);\n    }\n    function removeProtocolToken(address _token)\n        external\n        override\n        onlyStakingManager\n    {\n        _removeProtocolToken(_token);\n    }\n    function sendDust(address _to, address _token, uint256 _amount)\n        external\n        override\n        onlyStakingManager\n    {\n        _sendDust(_to, _token, _amount);\n    }\n    function setStakingDiscountMultiplier(uint256 _stakingDiscountMultiplier)\n        external\n        onlyStakingManager\n    {\n        stakingDiscountMultiplier = _stakingDiscountMultiplier;\n        emit StakingDiscountMultiplierUpdated(_stakingDiscountMultiplier);\n    }\n    function setBlockCountInAWeek(uint256 _blockCountInAWeek)\n        external\n        onlyStakingManager\n    {\n        blockCountInAWeek = _blockCountInAWeek;\n        emit BlockCountInAWeekUpdated(_blockCountInAWeek);\n    }\n    /// @dev deposit UbiquityDollar-3CRV LP tokens for a duration to receive staking shares\n    /// @param _lpsAmount of LP token to send\n    /// @param _weeks during lp token will be held\n    /// @notice weeks act as a multiplier for the amount of staking shares to be received\n    function deposit(uint256 _lpsAmount, uint256 _weeks)\n        external\n        whenNotPaused\n        returns (uint256 _id)\n    {\n        require(\n            1 <= _weeks && _weeks <= 208,\n            \"Staking: duration must be between 1 and 208 weeks\"\n        );\n        ITWAPOracleDollar3pool(manager.twapOracleAddress()).update();\n        // update the accumulated lp rewards per shares\n        _updateLpPerShare();\n        // transfer lp token to the staking contract\n        IERC20(manager.stableSwapMetaPoolAddress()).safeTransferFrom(\n            msg.sender, address(this), _lpsAmount\n        );\n        // calculate the amount of share based on the amount of lp deposited and the duration\n        uint256 _sharesAmount = IUbiquityFormulas(manager.formulasAddress())\n            .durationMultiply(_lpsAmount, _weeks, stakingDiscountMultiplier);\n        // calculate end locking period block number\n        uint256 _endBlock = block.number + _weeks * blockCountInAWeek;\n        _id = _mint(msg.sender, _lpsAmount, _sharesAmount, _endBlock);\n        // set masterchef for Governance rewards\n        IUbiquityChef(manager.masterChefAddress()).deposit(\n            msg.sender, _sharesAmount, _id\n        );\n        emit Deposit(\n            msg.sender, _id, _lpsAmount, _sharesAmount, _weeks, _endBlock\n            );\n    }\n    /// @dev Add an amount of UbiquityDollar-3CRV LP tokens\n    /// @param _amount of LP token to deposit\n    /// @param _id staking shares id\n    /// @param _weeks during lp token will be held\n    /// @notice staking shares are ERC1155 (aka NFT) because they have an expiration date\n    function addLiquidity(uint256 _amount, uint256 _id, uint256 _weeks)\n        external\n        whenNotPaused\n    {\n        (uint256[2] memory bs, StakingShare.Stake memory stake) =\n            _checkForLiquidity(_id);\n        // calculate pending LP rewards\n        uint256 sharesToRemove = bs[0];\n        _updateLpPerShare();\n        uint256 pendingLpReward =\n            lpRewardForShares(sharesToRemove, stake.lpRewardDebt);\n        // add an extra step to be able to decrease rewards if locking end is near\n        pendingLpReward = StakingFormulas(this.stakingFormulasAddress())\n            .lpRewardsAddLiquidityNormalization(stake, bs, pendingLpReward);\n        // add these LP Rewards to the deposited amount of LP token\n        stake.lpAmount += pendingLpReward;\n        lpRewards -= pendingLpReward;\n        IERC20(manager.stableSwapMetaPoolAddress()).safeTransferFrom(\n            msg.sender, address(this), _amount\n        );\n        stake.lpAmount += _amount;\n        // redeem all shares\n        IUbiquityChef(manager.masterChefAddress()).withdraw(\n            msg.sender, sharesToRemove, _id\n        );\n        // calculate the amount of share based on the new amount of lp deposited and the duration\n        uint256 _sharesAmount = IUbiquityFormulas(manager.formulasAddress())\n            .durationMultiply(stake.lpAmount, _weeks, stakingDiscountMultiplier);\n        // deposit new shares\n        IUbiquityChef(manager.masterChefAddress()).deposit(\n            msg.sender, _sharesAmount, _id\n        );\n        // calculate end locking period block number\n        // 1 week = 45361 blocks = 2371753*7/366\n        // n = (block + duration * 45361)\n        stake.endBlock = block.number + _weeks * blockCountInAWeek;\n        // should be done after masterchef withdraw\n        _updateLpPerShare();\n        stake.lpRewardDebt = (\n            IUbiquityChef(manager.masterChefAddress()).getStakingShareInfo(_id)[0]\n                * accLpRewardPerShare\n        ) / 1e12;\n        StakingShare(manager.stakingShareAddress()).updateStake(\n            _id, stake.lpAmount, stake.lpRewardDebt, stake.endBlock\n        );\n        emit AddLiquidityFromStake(msg.sender, _id, stake.lpAmount, _sharesAmount);\n    }\n    /// @dev Remove an amount of UbiquityDollar-3CRV LP tokens\n    /// @param _amount of LP token deposited when _id was created to be withdrawn\n    /// @param _id staking shares id\n    /// @notice staking shares are ERC1155 (aka NFT) because they have an expiration date\n    function removeLiquidity(uint256 _amount, uint256 _id)\n        external\n        whenNotPaused\n    {\n        (uint256[2] memory bs, StakingShare.Stake memory stake) =\n            _checkForLiquidity(_id);\n        require(stake.lpAmount >= _amount, \"Staking: amount too big\");\n        // we should decrease the Governance token rewards proportionally to the LP removed\n        // sharesToRemove = (staking shares * _amount )  / stake.lpAmount ;\n        uint256 sharesToRemove = StakingFormulas(this.stakingFormulasAddress())\n            .sharesForLP(stake, bs, _amount);\n        //get all its pending LP Rewards\n        _updateLpPerShare();\n        uint256 pendingLpReward = lpRewardForShares(bs[0], stake.lpRewardDebt);\n        // update staking shares\n        // stake.shares = stake.shares - sharesToRemove;\n        // get masterchef for Governance token rewards To ensure correct computation\n        // it needs to be done BEFORE updating the bonding share\n        IUbiquityChef(manager.masterChefAddress()).withdraw(\n            msg.sender, sharesToRemove, _id\n        );\n        // redeem of the extra LP\n        // staking lp balance - StakingShare.totalLP\n        IERC20 metapool = IERC20(manager.stableSwapMetaPoolAddress());\n        // add an extra step to be able to decrease rewards if locking end is near\n        pendingLpReward = StakingFormulas(this.stakingFormulasAddress())\n            .lpRewardsRemoveLiquidityNormalization(stake, bs, pendingLpReward);\n        uint256 correctedAmount = StakingFormulas(this.stakingFormulasAddress())\n            .correctedAmountToWithdraw(\n            StakingShare(manager.stakingShareAddress()).totalLP(),\n            metapool.balanceOf(address(this)) - lpRewards,\n            _amount\n        );\n        lpRewards -= pendingLpReward;\n        stake.lpAmount -= _amount;\n        // stake.lpRewardDebt = (staking shares * accLpRewardPerShare) /  1e18;\n        // user.amount.mul(pool.accSushiPerShare).div(1e12);\n        // should be done after masterchef withdraw\n        stake.lpRewardDebt = (\n            IUbiquityChef(manager.masterChefAddress()).getStakingShareInfo(_id)[0]\n                * accLpRewardPerShare\n        ) / 1e12;\n        StakingShare(manager.stakingShareAddress()).updateStake(\n            _id, stake.lpAmount, stake.lpRewardDebt, stake.endBlock\n        );\n        // lastly redeem lp tokens\n        metapool.safeTransfer(msg.sender, correctedAmount + pendingLpReward);\n        emit RemoveLiquidityFromStake(\n            msg.sender,\n            _id,\n            _amount,\n            correctedAmount,\n            pendingLpReward,\n            sharesToRemove\n            );\n    }\n    // View function to see pending lpRewards on frontend.\n    function pendingLpRewards(uint256 _id) external view returns (uint256) {\n        StakingShare staking = StakingShare(manager.stakingShareAddress());\n        StakingShare.Stake memory stake = staking.getStake(_id);\n        uint256[2] memory bs =\n            IUbiquityChef(manager.masterChefAddress()).getStakingShareInfo(_id);\n        uint256 lpBalance =\n            IERC20(manager.stableSwapMetaPoolAddress()).balanceOf(address(this));\n        // the excess LP is the current balance minus the total deposited LP\n        if (lpBalance >= (staking.totalLP() + totalLpToMigrate)) {\n            uint256 currentLpRewards =\n                lpBalance - (staking.totalLP() + totalLpToMigrate);\n            uint256 curAccLpRewardPerShare = accLpRewardPerShare;\n            // if new rewards we should calculate the new curAccLpRewardPerShare\n            if (currentLpRewards > lpRewards) {\n                uint256 newLpRewards = currentLpRewards - lpRewards;\n                curAccLpRewardPerShare = accLpRewardPerShare\n                    + (\n                        (newLpRewards * 1e12)\n                            / IUbiquityChef(manager.masterChefAddress()).totalShares()\n                    );\n            }\n            // we multiply the shares amount by the accumulated lpRewards per share\n            // and remove the lp Reward Debt\n            return (bs[0] * (curAccLpRewardPerShare)) / (1e12)\n                - (stake.lpRewardDebt);\n        }\n        return 0;\n    }\n    function pause() public virtual onlyPauser {\n        _pause();\n    }\n    function unpause() public virtual onlyPauser {\n        _unpause();\n    }\n    /// @dev migrate let a user migrate from V1\n    /// @notice user will then be able to migrate\n    function migrate() public whenMigrating returns (uint256 _id) {\n        _id = toMigrateId[msg.sender];\n        require(_id > 0, \"not v1 address\");\n        _migrate(\n            _toMigrateOriginals[_id - 1],\n            _toMigrateLpBalances[_id - 1],\n            _toMigrateWeeks[_id - 1]\n        );\n    }\n    /// @dev return the amount of Lp token rewards an amount of shares entitled\n    /// @param amount of staking shares\n    /// @param lpRewardDebt lp rewards that has already been distributed\n    function lpRewardForShares(uint256 amount, uint256 lpRewardDebt)\n        public\n        view\n        returns (uint256 pendingLpReward)\n    {\n        if (accLpRewardPerShare > 0) {\n            pendingLpReward =\n                (amount * accLpRewardPerShare) / 1e12 - (lpRewardDebt);\n        }\n    }\n    function currentShareValue() public view returns (uint256 priceShare) {\n        uint256 totalShares =\n            IUbiquityChef(manager.masterChefAddress()).totalShares();\n        // priceShare = totalLP / totalShares\n        priceShare = IUbiquityFormulas(manager.formulasAddress()).bondPrice(\n            StakingShare(manager.stakingShareAddress()).totalLP(),\n            totalShares,\n            ONE\n        );\n    }\n    /// @dev migrate let a user migrate from V1\n    /// @notice user will then be able to migrate\n    function _migrate(address user, uint256 _lpsAmount, uint256 _weeks)\n        internal\n        returns (uint256 _id)\n    {\n        require(toMigrateId[user] > 0, \"not v1 address\");\n        require(_lpsAmount > 0, \"LP amount is zero\");\n        require(\n            1 <= _weeks && _weeks <= 208,\n            \"Duration must be between 1 and 208 weeks\"\n        );\n        // unregister address\n        toMigrateId[user] = 0;\n        // calculate the amount of share based on the amount of lp deposited and the duration\n        uint256 _sharesAmount = IUbiquityFormulas(manager.formulasAddress())\n            .durationMultiply(_lpsAmount, _weeks, stakingDiscountMultiplier);\n        // update the accumulated lp rewards per shares\n        _updateLpPerShare();\n        // calculate end locking period block number\n        uint256 endBlock = block.number + _weeks * blockCountInAWeek;\n        _id = _mint(user, _lpsAmount, _sharesAmount, endBlock);\n        // reduce the total LP to migrate after the minting\n        // to keep the _updateLpPerShare calculation consistent\n        totalLpToMigrate -= _lpsAmount;\n        // set masterchef for Governance token rewards\n        IUbiquityChef(manager.masterChefAddress()).deposit(\n            user, _sharesAmount, _id\n        );\n        emit Migrated(user, _id, _lpsAmount, _sharesAmount, _weeks);\n    }\n    /// @dev update the accumulated excess LP per share\n    function _updateLpPerShare() internal {\n        StakingShare stake = StakingShare(manager.stakingShareAddress());\n        uint256 lpBalance =\n            IERC20(manager.stableSwapMetaPoolAddress()).balanceOf(address(this));\n        // the excess LP is the current balance\n        // minus the total deposited LP + LP that needs to be migrated\n        uint256 totalShares =\n            IUbiquityChef(manager.masterChefAddress()).totalShares();\n        if (lpBalance >= (stake.totalLP() + totalLpToMigrate) && totalShares > 0)\n        {\n            uint256 currentLpRewards =\n                lpBalance - (stake.totalLP() + totalLpToMigrate);\n            // is there new LP rewards to be distributed ?\n            if (currentLpRewards > lpRewards) {\n                // we calculate the new accumulated LP rewards per share\n                accLpRewardPerShare = accLpRewardPerShare\n                    + (((currentLpRewards - lpRewards) * 1e12) / totalShares);\n                // update the bonding contract lpRewards\n                lpRewards = currentLpRewards;\n            }\n        }\n    }\n    function _mint(\n        address to,\n        uint256 lpAmount,\n        uint256 shares,\n        uint256 endBlock\n    ) internal returns (uint256) {\n        uint256 _currentShareValue = currentShareValue();\n        require(\n            _currentShareValue != 0, \"Staking: share value should not be null\"\n        );\n        // set the lp rewards debts so that this staking share only get lp rewards from this day\n        uint256 lpRewardDebt = (shares * accLpRewardPerShare) / 1e12;\n        return StakingShare(manager.stakingShareAddress()).mint(\n            to, lpAmount, lpRewardDebt, endBlock\n        );\n    }\n    function _checkForLiquidity(uint256 _id)\n        internal\n        returns (uint256[2] memory bs, StakingShare.Stake memory stake)\n    {\n        require(\n            IERC1155Ubiquity(manager.stakingShareAddress()).balanceOf(\n                msg.sender, _id\n            ) == 1,\n            \"Staking: caller is not owner\"\n        );\n        StakingShare staking = StakingShare(manager.stakingShareAddress());\n        stake = staking.getStake(_id);\n        require(\n            block.number > stake.endBlock,\n            \"Staking: Redeem not allowed before staking time\"\n        );\n        ITWAPOracleDollar3pool(manager.twapOracleAddress()).update();\n        bs = IUbiquityChef(manager.masterChefAddress()).getStakingShareInfo(_id);\n    }\n}"
    },
    {
        "tag": "Unchecked Return Values For Low Level Calls",
        "url": "https://github.com/ubiquity/ubiquity-dollar/commit/e71aa79d31e064a5315ea8e27df57a67be4ee111",
        "file": "packages/contracts/src/dollar/Staking.sol\n",
        "before": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\nimport \"./core/UbiquityDollarToken.sol\";\nimport \"./core/UbiquityDollarManager.sol\";\nimport \"./interfaces/IERC1155Ubiquity.sol\";\nimport \"./interfaces/IMetaPool.sol\";\nimport \"./interfaces/IUbiquityFormulas.sol\";\nimport \"./interfaces/ISablier.sol\";\nimport \"./interfaces/IUbiquityChef.sol\";\nimport \"./interfaces/ITWAPOracleDollar3pool.sol\";\nimport \"./interfaces/IERC1155Ubiquity.sol\";\nimport \"./utils/CollectableDust.sol\";\nimport \"./StakingFormulas.sol\";\nimport \"./StakingShare.sol\";\ncontract Staking is CollectableDust, Pausable {\n    using SafeERC20 for IERC20;\n    bytes public data = \"\";\n    UbiquityDollarManager public manager;\n    uint256 public constant ONE = uint256(1 ether); // 3Crv has 18 decimals\n    uint256 public stakingDiscountMultiplier = uint256(1000000 gwei); // 0.001\n    uint256 public blockCountInAWeek = 45361;\n    uint256 public accLpRewardPerShare = 0;\n    uint256 public lpRewards;\n    uint256 public totalLpToMigrate;\n    address public stakingFormulasAddress;\n    address public migrator; // temporary address to handle migration\n    address[] private _toMigrateOriginals;\n    uint256[] private _toMigrateLpBalances;\n    uint256[] private _toMigrateWeeks;\n    // toMigrateId[address] > 0 when address is to migrate, or 0 in all other cases\n    mapping(address => uint256) public toMigrateId;\n    bool public migrating = false;\n    event PriceReset(\n        address _tokenWithdrawn,\n        uint256 _amountWithdrawn,\n        uint256 _amountTransferred\n    );\n    event Deposit(\n        address indexed _user,\n        uint256 indexed _id,\n        uint256 _lpAmount,\n        uint256 _stakingShareAmount,\n        uint256 _weeks,\n        uint256 _endBlock\n    );\n    event RemoveLiquidityFromStake(\n        address indexed _user,\n        uint256 indexed _id,\n        uint256 _lpAmount,\n        uint256 _lpAmountTransferred,\n        uint256 _lpRewards,\n        uint256 _stakingShareAmount\n    );\n    event AddLiquidityFromStake(\n        address indexed _user,\n        uint256 indexed _id,\n        uint256 _lpAmount,\n        uint256 _stakingShareAmount\n    );\n    event StakingDiscountMultiplierUpdated(uint256 _stakingDiscountMultiplier);\n    event BlockCountInAWeekUpdated(uint256 _blockCountInAWeek);\n    event Migrated(\n        address indexed _user,\n        uint256 indexed _id,\n        uint256 _lpsAmount,\n        uint256 _sharesAmount,\n        uint256 _weeks\n    );\n    modifier onlyStakingManager() {\n        require(\n            manager.hasRole(manager.STAKING_MANAGER_ROLE(), msg.sender),\n            \"not manager\"\n        );\n        _;\n    }\n    modifier onlyPauser() {\n        require(\n            manager.hasRole(manager.PAUSER_ROLE(), msg.sender), \"not pauser\"\n        );\n        _;\n    }\n    modifier onlyMigrator() {\n        require(msg.sender == migrator, \"not migrator\");\n        _;\n    }\n    modifier whenMigrating() {\n        require(migrating, \"not in migration\");\n        _;\n    }\n    constructor(\n        address _manager,\n        address _stakingFormulasAddress,\n        address[] memory _originals,\n        uint256[] memory _lpBalances,\n        uint256[] memory _weeks\n    ) CollectableDust() Pausable() {\n        manager = UbiquityDollarManager(_manager);\n        stakingFormulasAddress = _stakingFormulasAddress;\n        migrator = msg.sender;\n        uint256 lgt = _originals.length;\n        require(lgt > 0, \"address array empty\");\n        require(lgt == _lpBalances.length, \"balances array not same length\");\n        require(lgt == _weeks.length, \"weeks array not same length\");\n        _toMigrateOriginals = _originals;\n        _toMigrateLpBalances = _lpBalances;\n        _toMigrateWeeks = _weeks;\n        for (uint256 i = 0; i < lgt; ++i) {\n            toMigrateId[_originals[i]] = i + 1;\n            totalLpToMigrate += _lpBalances[i];\n        }\n    }\n    // solhint-disable-next-line no-empty-blocks\n    receive() external payable {}\n    /// @dev addUserToMigrate add a user to migrate from V1.\n    ///      IMPORTANT execute that function BEFORE sending the corresponding LP token\n    ///      otherwise they will have extra LP rewards\n    /// @param _original address of v1 user\n    /// @param _lpBalance LP Balance of v1 user\n    /// @param _weeks weeks lockup of v1 user\n    /// @notice user will then be able to migrate.\n    function addUserToMigrate(\n        address _original,\n        uint256 _lpBalance,\n        uint256 _weeks\n    ) external onlyMigrator {\n        _toMigrateOriginals.push(_original);\n        _toMigrateLpBalances.push(_lpBalance);\n        totalLpToMigrate += _lpBalance;\n        _toMigrateWeeks.push(_weeks);\n        toMigrateId[_original] = _toMigrateOriginals.length;\n    }\n    function setMigrator(address _migrator) external onlyMigrator {\n        migrator = _migrator;\n    }\n    function setMigrating(bool _migrating) external onlyMigrator {\n        migrating = _migrating;\n    }\n    /// @dev dollarPriceReset remove Ubiquity Dollar unilaterally from the curve LP share sitting inside\n    ///      the staking contract and send the Ubiquity Dollar received to the treasury.\n    ///      This will have the immediate effect of pushing the Ubiquity Dollar price HIGHER\n    /// @param amount of LP token to be removed for Ubiquity Dollar\n    /// @notice it will remove one coin only from the curve LP share sitting in the staking contract\n    function dollarPriceReset(uint256 amount) external onlyStakingManager {\n        IMetaPool metaPool = IMetaPool(manager.stableSwapMetaPoolAddress());\n        // remove one coin\n        uint256 coinWithdrawn = metaPool.remove_liquidity_one_coin(amount, 0, 0);\n        ITWAPOracleDollar3pool(manager.twapOracleAddress()).update();\n        uint256 toTransfer =\n            IERC20(manager.dollarTokenAddress()).balanceOf(address(this));\n        IERC20(manager.dollarTokenAddress()).transfer(\n            manager.treasuryAddress(), toTransfer\n        );\n        emit PriceReset(manager.dollarTokenAddress(), coinWithdrawn, toTransfer);\n\n    \n        \n          \n    \n\n        \n        Expand All\n    \n    @@ -192,7 +192,7 @@ contract Staking is CollectableDust, Pausable {\n  \n    }\n    /// @dev crvPriceReset remove 3CRV unilaterally from the curve LP share sitting inside\n    ///      the staking contract and send the 3CRV received to the treasury\n    ///      This will have the immediate effect of pushing the Ubiquity Dollar price LOWER\n    /// @param amount of LP token to be removed for 3CRV tokens\n    /// @notice it will remove one coin only from the curve LP share sitting in the staking contract\n    function crvPriceReset(uint256 amount) external onlyStakingManager {\n        IMetaPool metaPool = IMetaPool(manager.stableSwapMetaPoolAddress());\n        // remove one coin\n        uint256 coinWithdrawn = metaPool.remove_liquidity_one_coin(amount, 1, 0);\n        // update twap\n        ITWAPOracleDollar3pool(manager.twapOracleAddress()).update();\n        uint256 toTransfer =\n            IERC20(manager.curve3PoolTokenAddress()).balanceOf(address(this));\n        IERC20(manager.curve3PoolTokenAddress()).transfer(\n            manager.treasuryAddress(), toTransfer\n        );\n        emit PriceReset(\n\n    \n          \n            \n    \n\n          \n          Expand Down\n    \n    \n  \n            manager.curve3PoolTokenAddress(), coinWithdrawn, toTransfer\n            );\n    }\n    function setStakingFormulasAddress(address _stakingFormulasAddress)\n        external\n        onlyStakingManager\n    {\n        stakingFormulasAddress = _stakingFormulasAddress;\n    }\n    /// Collectable Dust\n    function addProtocolToken(address _token)\n        external\n        override\n        onlyStakingManager\n    {\n        _addProtocolToken(_token);\n    }\n    function removeProtocolToken(address _token)\n        external\n        override\n        onlyStakingManager\n    {\n        _removeProtocolToken(_token);\n    }\n    function sendDust(address _to, address _token, uint256 _amount)\n        external\n        override\n        onlyStakingManager\n    {\n        _sendDust(_to, _token, _amount);\n    }\n    function setStakingDiscountMultiplier(uint256 _stakingDiscountMultiplier)\n        external\n        onlyStakingManager\n    {\n        stakingDiscountMultiplier = _stakingDiscountMultiplier;\n        emit StakingDiscountMultiplierUpdated(_stakingDiscountMultiplier);\n    }\n    function setBlockCountInAWeek(uint256 _blockCountInAWeek)\n        external\n        onlyStakingManager\n    {\n        blockCountInAWeek = _blockCountInAWeek;\n        emit BlockCountInAWeekUpdated(_blockCountInAWeek);\n    }\n    /// @dev deposit UbiquityDollar-3CRV LP tokens for a duration to receive staking shares\n    /// @param _lpsAmount of LP token to send\n    /// @param _weeks during lp token will be held\n    /// @notice weeks act as a multiplier for the amount of staking shares to be received\n    function deposit(uint256 _lpsAmount, uint256 _weeks)\n        external\n        whenNotPaused\n        returns (uint256 _id)\n    {\n        require(\n            1 <= _weeks && _weeks <= 208,\n            \"Staking: duration must be between 1 and 208 weeks\"\n        );\n        ITWAPOracleDollar3pool(manager.twapOracleAddress()).update();\n        // update the accumulated lp rewards per shares\n        _updateLpPerShare();\n        // transfer lp token to the staking contract\n        IERC20(manager.stableSwapMetaPoolAddress()).safeTransferFrom(\n            msg.sender, address(this), _lpsAmount\n        );\n        // calculate the amount of share based on the amount of lp deposited and the duration\n        uint256 _sharesAmount = IUbiquityFormulas(manager.formulasAddress())\n            .durationMultiply(_lpsAmount, _weeks, stakingDiscountMultiplier);\n        // calculate end locking period block number\n        uint256 _endBlock = block.number + _weeks * blockCountInAWeek;\n        _id = _mint(msg.sender, _lpsAmount, _sharesAmount, _endBlock);\n        // set masterchef for Governance rewards\n        IUbiquityChef(manager.masterChefAddress()).deposit(\n            msg.sender, _sharesAmount, _id\n        );\n        emit Deposit(\n            msg.sender, _id, _lpsAmount, _sharesAmount, _weeks, _endBlock\n            );\n    }\n    /// @dev Add an amount of UbiquityDollar-3CRV LP tokens\n    /// @param _amount of LP token to deposit\n    /// @param _id staking shares id\n    /// @param _weeks during lp token will be held\n    /// @notice staking shares are ERC1155 (aka NFT) because they have an expiration date\n    function addLiquidity(uint256 _amount, uint256 _id, uint256 _weeks)\n        external\n        whenNotPaused\n    {\n        (uint256[2] memory bs, StakingShare.Stake memory stake) =\n            _checkForLiquidity(_id);\n        // calculate pending LP rewards\n        uint256 sharesToRemove = bs[0];\n        _updateLpPerShare();\n        uint256 pendingLpReward =\n            lpRewardForShares(sharesToRemove, stake.lpRewardDebt);\n        // add an extra step to be able to decrease rewards if locking end is near\n        pendingLpReward = StakingFormulas(this.stakingFormulasAddress())\n            .lpRewardsAddLiquidityNormalization(stake, bs, pendingLpReward);\n        // add these LP Rewards to the deposited amount of LP token\n        stake.lpAmount += pendingLpReward;\n        lpRewards -= pendingLpReward;\n        IERC20(manager.stableSwapMetaPoolAddress()).safeTransferFrom(\n            msg.sender, address(this), _amount\n        );\n        stake.lpAmount += _amount;\n        // redeem all shares\n        IUbiquityChef(manager.masterChefAddress()).withdraw(\n            msg.sender, sharesToRemove, _id\n        );\n        // calculate the amount of share based on the new amount of lp deposited and the duration\n        uint256 _sharesAmount = IUbiquityFormulas(manager.formulasAddress())\n            .durationMultiply(stake.lpAmount, _weeks, stakingDiscountMultiplier);\n        // deposit new shares\n        IUbiquityChef(manager.masterChefAddress()).deposit(\n            msg.sender, _sharesAmount, _id\n        );\n        // calculate end locking period block number\n        // 1 week = 45361 blocks = 2371753*7/366\n        // n = (block + duration * 45361)\n        stake.endBlock = block.number + _weeks * blockCountInAWeek;\n        // should be done after masterchef withdraw\n        _updateLpPerShare();\n        stake.lpRewardDebt = (\n            IUbiquityChef(manager.masterChefAddress()).getStakingShareInfo(_id)[0]\n                * accLpRewardPerShare\n        ) / 1e12;\n        StakingShare(manager.stakingShareAddress()).updateStake(\n            _id, stake.lpAmount, stake.lpRewardDebt, stake.endBlock\n        );\n        emit AddLiquidityFromStake(\n            msg.sender, _id, stake.lpAmount, _sharesAmount\n            );\n    }\n    /// @dev Remove an amount of UbiquityDollar-3CRV LP tokens\n    /// @param _amount of LP token deposited when _id was created to be withdrawn\n    /// @param _id staking shares id\n    /// @notice staking shares are ERC1155 (aka NFT) because they have an expiration date\n    function removeLiquidity(uint256 _amount, uint256 _id)\n        external\n        whenNotPaused\n    {\n        (uint256[2] memory bs, StakingShare.Stake memory stake) =\n            _checkForLiquidity(_id);\n        require(stake.lpAmount >= _amount, \"Staking: amount too big\");\n        // we should decrease the Governance token rewards proportionally to the LP removed\n        // sharesToRemove = (staking shares * _amount )  / stake.lpAmount ;\n        uint256 sharesToRemove = StakingFormulas(this.stakingFormulasAddress())\n            .sharesForLP(stake, bs, _amount);\n        //get all its pending LP Rewards\n        _updateLpPerShare();\n        uint256 pendingLpReward = lpRewardForShares(bs[0], stake.lpRewardDebt);\n        // update staking shares\n        // stake.shares = stake.shares - sharesToRemove;\n        // get masterchef for Governance token rewards To ensure correct computation\n        // it needs to be done BEFORE updating the bonding share\n        IUbiquityChef(manager.masterChefAddress()).withdraw(\n            msg.sender, sharesToRemove, _id\n        );\n        // redeem of the extra LP\n        // staking lp balance - StakingShare.totalLP\n        IERC20 metapool = IERC20(manager.stableSwapMetaPoolAddress());\n        // add an extra step to be able to decrease rewards if locking end is near\n        pendingLpReward = StakingFormulas(this.stakingFormulasAddress())\n            .lpRewardsRemoveLiquidityNormalization(stake, bs, pendingLpReward);\n        uint256 correctedAmount = StakingFormulas(this.stakingFormulasAddress())\n            .correctedAmountToWithdraw(\n            StakingShare(manager.stakingShareAddress()).totalLP(),\n            metapool.balanceOf(address(this)) - lpRewards,\n            _amount\n        );\n        lpRewards -= pendingLpReward;\n        stake.lpAmount -= _amount;\n        // stake.lpRewardDebt = (staking shares * accLpRewardPerShare) /  1e18;\n        // user.amount.mul(pool.accSushiPerShare).div(1e12);\n        // should be done after masterchef withdraw\n        stake.lpRewardDebt = (\n            IUbiquityChef(manager.masterChefAddress()).getStakingShareInfo(_id)[0]\n                * accLpRewardPerShare\n        ) / 1e12;\n        StakingShare(manager.stakingShareAddress()).updateStake(\n            _id, stake.lpAmount, stake.lpRewardDebt, stake.endBlock\n        );\n        // lastly redeem lp tokens\n        metapool.safeTransfer(msg.sender, correctedAmount + pendingLpReward);\n        emit RemoveLiquidityFromStake(\n            msg.sender,\n            _id,\n            _amount,\n            correctedAmount,\n            pendingLpReward,\n            sharesToRemove\n            );\n    }\n    // View function to see pending lpRewards on frontend.\n    function pendingLpRewards(uint256 _id) external view returns (uint256) {\n        StakingShare staking = StakingShare(manager.stakingShareAddress());\n        StakingShare.Stake memory stake = staking.getStake(_id);\n        uint256[2] memory bs =\n            IUbiquityChef(manager.masterChefAddress()).getStakingShareInfo(_id);\n        uint256 lpBalance =\n            IERC20(manager.stableSwapMetaPoolAddress()).balanceOf(address(this));\n        // the excess LP is the current balance minus the total deposited LP\n        if (lpBalance >= (staking.totalLP() + totalLpToMigrate)) {\n            uint256 currentLpRewards =\n                lpBalance - (staking.totalLP() + totalLpToMigrate);\n            uint256 curAccLpRewardPerShare = accLpRewardPerShare;\n            // if new rewards we should calculate the new curAccLpRewardPerShare\n            if (currentLpRewards > lpRewards) {\n                uint256 newLpRewards = currentLpRewards - lpRewards;\n                curAccLpRewardPerShare = accLpRewardPerShare\n                    + (\n                        (newLpRewards * 1e12)\n                            / IUbiquityChef(manager.masterChefAddress()).totalShares()\n                    );\n            }\n            // we multiply the shares amount by the accumulated lpRewards per share\n            // and remove the lp Reward Debt\n            return (bs[0] * (curAccLpRewardPerShare)) / (1e12)\n                - (stake.lpRewardDebt);\n        }\n        return 0;\n    }\n    function pause() public virtual onlyPauser {\n        _pause();\n    }\n    function unpause() public virtual onlyPauser {\n        _unpause();\n    }\n    /// @dev migrate let a user migrate from V1\n    /// @notice user will then be able to migrate\n    function migrate() public whenMigrating returns (uint256 _id) {\n        _id = toMigrateId[msg.sender];\n        require(_id > 0, \"not v1 address\");\n        _migrate(\n            _toMigrateOriginals[_id - 1],\n            _toMigrateLpBalances[_id - 1],\n            _toMigrateWeeks[_id - 1]\n        );\n    }\n    /// @dev return the amount of Lp token rewards an amount of shares entitled\n    /// @param amount of staking shares\n    /// @param lpRewardDebt lp rewards that has already been distributed\n    function lpRewardForShares(uint256 amount, uint256 lpRewardDebt)\n        public\n        view\n        returns (uint256 pendingLpReward)\n    {\n        if (accLpRewardPerShare > 0) {\n            pendingLpReward =\n                (amount * accLpRewardPerShare) / 1e12 - (lpRewardDebt);\n        }\n    }\n    function currentShareValue() public view returns (uint256 priceShare) {\n        uint256 totalShares =\n            IUbiquityChef(manager.masterChefAddress()).totalShares();\n        // priceShare = totalLP / totalShares\n        priceShare = IUbiquityFormulas(manager.formulasAddress()).bondPrice(\n            StakingShare(manager.stakingShareAddress()).totalLP(),\n            totalShares,\n            ONE\n        );\n    }\n    /// @dev migrate let a user migrate from V1\n    /// @notice user will then be able to migrate\n    function _migrate(address user, uint256 _lpsAmount, uint256 _weeks)\n        internal\n        returns (uint256 _id)\n    {\n        require(toMigrateId[user] > 0, \"not v1 address\");\n        require(_lpsAmount > 0, \"LP amount is zero\");\n        require(\n            1 <= _weeks && _weeks <= 208,\n            \"Duration must be between 1 and 208 weeks\"\n        );\n        // unregister address\n        toMigrateId[user] = 0;\n        // calculate the amount of share based on the amount of lp deposited and the duration\n        uint256 _sharesAmount = IUbiquityFormulas(manager.formulasAddress())\n            .durationMultiply(_lpsAmount, _weeks, stakingDiscountMultiplier);\n        // update the accumulated lp rewards per shares\n        _updateLpPerShare();\n        // calculate end locking period block number\n        uint256 endBlock = block.number + _weeks * blockCountInAWeek;\n        _id = _mint(user, _lpsAmount, _sharesAmount, endBlock);\n        // reduce the total LP to migrate after the minting\n        // to keep the _updateLpPerShare calculation consistent\n        totalLpToMigrate -= _lpsAmount;\n        // set masterchef for Governance token rewards\n        IUbiquityChef(manager.masterChefAddress()).deposit(\n            user, _sharesAmount, _id\n        );\n        emit Migrated(user, _id, _lpsAmount, _sharesAmount, _weeks);\n    }\n    /// @dev update the accumulated excess LP per share\n    function _updateLpPerShare() internal {\n        StakingShare stake = StakingShare(manager.stakingShareAddress());\n        uint256 lpBalance =\n            IERC20(manager.stableSwapMetaPoolAddress()).balanceOf(address(this));\n        // the excess LP is the current balance\n        // minus the total deposited LP + LP that needs to be migrated\n        uint256 totalShares =\n            IUbiquityChef(manager.masterChefAddress()).totalShares();\n        if (\n            lpBalance >= (stake.totalLP() + totalLpToMigrate) && totalShares > 0\n        ) {\n            uint256 currentLpRewards =\n                lpBalance - (stake.totalLP() + totalLpToMigrate);\n            // is there new LP rewards to be distributed ?\n            if (currentLpRewards > lpRewards) {\n                // we calculate the new accumulated LP rewards per share\n                accLpRewardPerShare = accLpRewardPerShare\n                    + (((currentLpRewards - lpRewards) * 1e12) / totalShares);\n                // update the bonding contract lpRewards\n                lpRewards = currentLpRewards;\n            }\n        }\n    }\n    function _mint(\n        address to,\n        uint256 lpAmount,\n        uint256 shares,\n        uint256 endBlock\n    ) internal returns (uint256) {\n        uint256 _currentShareValue = currentShareValue();\n        require(\n            _currentShareValue != 0, \"Staking: share value should not be null\"\n        );\n        // set the lp rewards debts so that this staking share only get lp rewards from this day\n        uint256 lpRewardDebt = (shares * accLpRewardPerShare) / 1e12;\n        return StakingShare(manager.stakingShareAddress()).mint(\n            to, lpAmount, lpRewardDebt, endBlock\n        );\n    }\n    function _checkForLiquidity(uint256 _id)\n        internal\n        returns (uint256[2] memory bs, StakingShare.Stake memory stake)\n    {\n        require(\n            IERC1155Ubiquity(manager.stakingShareAddress()).balanceOf(\n                msg.sender, _id\n            ) == 1,\n            \"Staking: caller is not owner\"\n        );\n        StakingShare staking = StakingShare(manager.stakingShareAddress());\n        stake = staking.getStake(_id);\n        require(\n            block.number > stake.endBlock,\n            \"Staking: Redeem not allowed before staking time\"\n        );\n        ITWAPOracleDollar3pool(manager.twapOracleAddress()).update();\n        bs = IUbiquityChef(manager.masterChefAddress()).getStakingShareInfo(_id);\n    }\n}",
        "after": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\nimport \"./core/UbiquityDollarToken.sol\";\nimport \"./core/UbiquityDollarManager.sol\";\nimport \"./interfaces/IERC1155Ubiquity.sol\";\nimport \"./interfaces/IMetaPool.sol\";\nimport \"./interfaces/IUbiquityFormulas.sol\";\nimport \"./interfaces/ISablier.sol\";\nimport \"./interfaces/IUbiquityChef.sol\";\nimport \"./interfaces/ITWAPOracleDollar3pool.sol\";\nimport \"./interfaces/IERC1155Ubiquity.sol\";\nimport \"./utils/CollectableDust.sol\";\nimport \"./StakingFormulas.sol\";\nimport \"./StakingShare.sol\";\ncontract Staking is CollectableDust, Pausable {\n    using SafeERC20 for IERC20;\n    bytes public data = \"\";\n    UbiquityDollarManager public manager;\n    uint256 public constant ONE = uint256(1 ether); // 3Crv has 18 decimals\n    uint256 public stakingDiscountMultiplier = uint256(1000000 gwei); // 0.001\n    uint256 public blockCountInAWeek = 45361;\n    uint256 public accLpRewardPerShare = 0;\n    uint256 public lpRewards;\n    uint256 public totalLpToMigrate;\n    address public stakingFormulasAddress;\n    address public migrator; // temporary address to handle migration\n    address[] private _toMigrateOriginals;\n    uint256[] private _toMigrateLpBalances;\n    uint256[] private _toMigrateWeeks;\n    // toMigrateId[address] > 0 when address is to migrate, or 0 in all other cases\n    mapping(address => uint256) public toMigrateId;\n    bool public migrating = false;\n    event PriceReset(\n        address _tokenWithdrawn,\n        uint256 _amountWithdrawn,\n        uint256 _amountTransferred\n    );\n    event Deposit(\n        address indexed _user,\n        uint256 indexed _id,\n        uint256 _lpAmount,\n        uint256 _stakingShareAmount,\n        uint256 _weeks,\n        uint256 _endBlock\n    );\n    event RemoveLiquidityFromStake(\n        address indexed _user,\n        uint256 indexed _id,\n        uint256 _lpAmount,\n        uint256 _lpAmountTransferred,\n        uint256 _lpRewards,\n        uint256 _stakingShareAmount\n    );\n    event AddLiquidityFromStake(\n        address indexed _user,\n        uint256 indexed _id,\n        uint256 _lpAmount,\n        uint256 _stakingShareAmount\n    );\n    event StakingDiscountMultiplierUpdated(uint256 _stakingDiscountMultiplier);\n    event BlockCountInAWeekUpdated(uint256 _blockCountInAWeek);\n    event Migrated(\n        address indexed _user,\n        uint256 indexed _id,\n        uint256 _lpsAmount,\n        uint256 _sharesAmount,\n        uint256 _weeks\n    );\n    modifier onlyStakingManager() {\n        require(\n            manager.hasRole(manager.STAKING_MANAGER_ROLE(), msg.sender),\n            \"not manager\"\n        );\n        _;\n    }\n    modifier onlyPauser() {\n        require(\n            manager.hasRole(manager.PAUSER_ROLE(), msg.sender), \"not pauser\"\n        );\n        _;\n    }\n    modifier onlyMigrator() {\n        require(msg.sender == migrator, \"not migrator\");\n        _;\n    }\n    modifier whenMigrating() {\n        require(migrating, \"not in migration\");\n        _;\n    }\n    constructor(\n        address _manager,\n        address _stakingFormulasAddress,\n        address[] memory _originals,\n        uint256[] memory _lpBalances,\n        uint256[] memory _weeks\n    ) CollectableDust() Pausable() {\n        manager = UbiquityDollarManager(_manager);\n        stakingFormulasAddress = _stakingFormulasAddress;\n        migrator = msg.sender;\n        uint256 lgt = _originals.length;\n        require(lgt > 0, \"address array empty\");\n        require(lgt == _lpBalances.length, \"balances array not same length\");\n        require(lgt == _weeks.length, \"weeks array not same length\");\n        _toMigrateOriginals = _originals;\n        _toMigrateLpBalances = _lpBalances;\n        _toMigrateWeeks = _weeks;\n        for (uint256 i = 0; i < lgt; ++i) {\n            toMigrateId[_originals[i]] = i + 1;\n            totalLpToMigrate += _lpBalances[i];\n        }\n    }\n    // solhint-disable-next-line no-empty-blocks\n    receive() external payable {}\n    /// @dev addUserToMigrate add a user to migrate from V1.\n    ///      IMPORTANT execute that function BEFORE sending the corresponding LP token\n    ///      otherwise they will have extra LP rewards\n    /// @param _original address of v1 user\n    /// @param _lpBalance LP Balance of v1 user\n    /// @param _weeks weeks lockup of v1 user\n    /// @notice user will then be able to migrate.\n    function addUserToMigrate(\n        address _original,\n        uint256 _lpBalance,\n        uint256 _weeks\n    ) external onlyMigrator {\n        _toMigrateOriginals.push(_original);\n        _toMigrateLpBalances.push(_lpBalance);\n        totalLpToMigrate += _lpBalance;\n        _toMigrateWeeks.push(_weeks);\n        toMigrateId[_original] = _toMigrateOriginals.length;\n    }\n    function setMigrator(address _migrator) external onlyMigrator {\n        migrator = _migrator;\n    }\n    function setMigrating(bool _migrating) external onlyMigrator {\n        migrating = _migrating;\n    }\n    /// @dev dollarPriceReset remove Ubiquity Dollar unilaterally from the curve LP share sitting inside\n    ///      the staking contract and send the Ubiquity Dollar received to the treasury.\n    ///      This will have the immediate effect of pushing the Ubiquity Dollar price HIGHER\n    /// @param amount of LP token to be removed for Ubiquity Dollar\n    /// @notice it will remove one coin only from the curve LP share sitting in the staking contract\n    function dollarPriceReset(uint256 amount) external onlyStakingManager {\n        IMetaPool metaPool = IMetaPool(manager.stableSwapMetaPoolAddress());\n        // remove one coin\n        uint256 coinWithdrawn = metaPool.remove_liquidity_one_coin(amount, 0, 0);\n        ITWAPOracleDollar3pool(manager.twapOracleAddress()).update();\n        uint256 toTransfer =\n            IERC20(manager.dollarTokenAddress()).balanceOf(address(this));\n        IERC20(manager.dollarTokenAddress()).safeTransfer(\n            manager.treasuryAddress(), toTransfer\n        );\n        emit PriceReset(manager.dollarTokenAddress(), coinWithdrawn, toTransfer);\n\n    \n        \n          \n    \n\n        \n        Expand All\n    \n    @@ -192,7 +192,7 @@ contract Staking is CollectableDust, Pausable {\n  \n    }\n    /// @dev crvPriceReset remove 3CRV unilaterally from the curve LP share sitting inside\n    ///      the staking contract and send the 3CRV received to the treasury\n    ///      This will have the immediate effect of pushing the Ubiquity Dollar price LOWER\n    /// @param amount of LP token to be removed for 3CRV tokens\n    /// @notice it will remove one coin only from the curve LP share sitting in the staking contract\n    function crvPriceReset(uint256 amount) external onlyStakingManager {\n        IMetaPool metaPool = IMetaPool(manager.stableSwapMetaPoolAddress());\n        // remove one coin\n        uint256 coinWithdrawn = metaPool.remove_liquidity_one_coin(amount, 1, 0);\n        // update twap\n        ITWAPOracleDollar3pool(manager.twapOracleAddress()).update();\n        uint256 toTransfer =\n            IERC20(manager.curve3PoolTokenAddress()).balanceOf(address(this));\n        IERC20(manager.curve3PoolTokenAddress()).safeTransfer(\n            manager.treasuryAddress(), toTransfer\n        );\n        emit PriceReset(\n\n    \n          \n            \n    \n\n          \n          Expand Down\n    \n    \n  \n            manager.curve3PoolTokenAddress(), coinWithdrawn, toTransfer\n            );\n    }\n    function setStakingFormulasAddress(address _stakingFormulasAddress)\n        external\n        onlyStakingManager\n    {\n        stakingFormulasAddress = _stakingFormulasAddress;\n    }\n    /// Collectable Dust\n    function addProtocolToken(address _token)\n        external\n        override\n        onlyStakingManager\n    {\n        _addProtocolToken(_token);\n    }\n    function removeProtocolToken(address _token)\n        external\n        override\n        onlyStakingManager\n    {\n        _removeProtocolToken(_token);\n    }\n    function sendDust(address _to, address _token, uint256 _amount)\n        external\n        override\n        onlyStakingManager\n    {\n        _sendDust(_to, _token, _amount);\n    }\n    function setStakingDiscountMultiplier(uint256 _stakingDiscountMultiplier)\n        external\n        onlyStakingManager\n    {\n        stakingDiscountMultiplier = _stakingDiscountMultiplier;\n        emit StakingDiscountMultiplierUpdated(_stakingDiscountMultiplier);\n    }\n    function setBlockCountInAWeek(uint256 _blockCountInAWeek)\n        external\n        onlyStakingManager\n    {\n        blockCountInAWeek = _blockCountInAWeek;\n        emit BlockCountInAWeekUpdated(_blockCountInAWeek);\n    }\n    /// @dev deposit UbiquityDollar-3CRV LP tokens for a duration to receive staking shares\n    /// @param _lpsAmount of LP token to send\n    /// @param _weeks during lp token will be held\n    /// @notice weeks act as a multiplier for the amount of staking shares to be received\n    function deposit(uint256 _lpsAmount, uint256 _weeks)\n        external\n        whenNotPaused\n        returns (uint256 _id)\n    {\n        require(\n            1 <= _weeks && _weeks <= 208,\n            \"Staking: duration must be between 1 and 208 weeks\"\n        );\n        ITWAPOracleDollar3pool(manager.twapOracleAddress()).update();\n        // update the accumulated lp rewards per shares\n        _updateLpPerShare();\n        // transfer lp token to the staking contract\n        IERC20(manager.stableSwapMetaPoolAddress()).safeTransferFrom(\n            msg.sender, address(this), _lpsAmount\n        );\n        // calculate the amount of share based on the amount of lp deposited and the duration\n        uint256 _sharesAmount = IUbiquityFormulas(manager.formulasAddress())\n            .durationMultiply(_lpsAmount, _weeks, stakingDiscountMultiplier);\n        // calculate end locking period block number\n        uint256 _endBlock = block.number + _weeks * blockCountInAWeek;\n        _id = _mint(msg.sender, _lpsAmount, _sharesAmount, _endBlock);\n        // set masterchef for Governance rewards\n        IUbiquityChef(manager.masterChefAddress()).deposit(\n            msg.sender, _sharesAmount, _id\n        );\n        emit Deposit(\n            msg.sender, _id, _lpsAmount, _sharesAmount, _weeks, _endBlock\n            );\n    }\n    /// @dev Add an amount of UbiquityDollar-3CRV LP tokens\n    /// @param _amount of LP token to deposit\n    /// @param _id staking shares id\n    /// @param _weeks during lp token will be held\n    /// @notice staking shares are ERC1155 (aka NFT) because they have an expiration date\n    function addLiquidity(uint256 _amount, uint256 _id, uint256 _weeks)\n        external\n        whenNotPaused\n    {\n        (uint256[2] memory bs, StakingShare.Stake memory stake) =\n            _checkForLiquidity(_id);\n        // calculate pending LP rewards\n        uint256 sharesToRemove = bs[0];\n        _updateLpPerShare();\n        uint256 pendingLpReward =\n            lpRewardForShares(sharesToRemove, stake.lpRewardDebt);\n        // add an extra step to be able to decrease rewards if locking end is near\n        pendingLpReward = StakingFormulas(this.stakingFormulasAddress())\n            .lpRewardsAddLiquidityNormalization(stake, bs, pendingLpReward);\n        // add these LP Rewards to the deposited amount of LP token\n        stake.lpAmount += pendingLpReward;\n        lpRewards -= pendingLpReward;\n        IERC20(manager.stableSwapMetaPoolAddress()).safeTransferFrom(\n            msg.sender, address(this), _amount\n        );\n        stake.lpAmount += _amount;\n        // redeem all shares\n        IUbiquityChef(manager.masterChefAddress()).withdraw(\n            msg.sender, sharesToRemove, _id\n        );\n        // calculate the amount of share based on the new amount of lp deposited and the duration\n        uint256 _sharesAmount = IUbiquityFormulas(manager.formulasAddress())\n            .durationMultiply(stake.lpAmount, _weeks, stakingDiscountMultiplier);\n        // deposit new shares\n        IUbiquityChef(manager.masterChefAddress()).deposit(\n            msg.sender, _sharesAmount, _id\n        );\n        // calculate end locking period block number\n        // 1 week = 45361 blocks = 2371753*7/366\n        // n = (block + duration * 45361)\n        stake.endBlock = block.number + _weeks * blockCountInAWeek;\n        // should be done after masterchef withdraw\n        _updateLpPerShare();\n        stake.lpRewardDebt = (\n            IUbiquityChef(manager.masterChefAddress()).getStakingShareInfo(_id)[0]\n                * accLpRewardPerShare\n        ) / 1e12;\n        StakingShare(manager.stakingShareAddress()).updateStake(\n            _id, stake.lpAmount, stake.lpRewardDebt, stake.endBlock\n        );\n        emit AddLiquidityFromStake(\n            msg.sender, _id, stake.lpAmount, _sharesAmount\n            );\n    }\n    /// @dev Remove an amount of UbiquityDollar-3CRV LP tokens\n    /// @param _amount of LP token deposited when _id was created to be withdrawn\n    /// @param _id staking shares id\n    /// @notice staking shares are ERC1155 (aka NFT) because they have an expiration date\n    function removeLiquidity(uint256 _amount, uint256 _id)\n        external\n        whenNotPaused\n    {\n        (uint256[2] memory bs, StakingShare.Stake memory stake) =\n            _checkForLiquidity(_id);\n        require(stake.lpAmount >= _amount, \"Staking: amount too big\");\n        // we should decrease the Governance token rewards proportionally to the LP removed\n        // sharesToRemove = (staking shares * _amount )  / stake.lpAmount ;\n        uint256 sharesToRemove = StakingFormulas(this.stakingFormulasAddress())\n            .sharesForLP(stake, bs, _amount);\n        //get all its pending LP Rewards\n        _updateLpPerShare();\n        uint256 pendingLpReward = lpRewardForShares(bs[0], stake.lpRewardDebt);\n        // update staking shares\n        // stake.shares = stake.shares - sharesToRemove;\n        // get masterchef for Governance token rewards To ensure correct computation\n        // it needs to be done BEFORE updating the bonding share\n        IUbiquityChef(manager.masterChefAddress()).withdraw(\n            msg.sender, sharesToRemove, _id\n        );\n        // redeem of the extra LP\n        // staking lp balance - StakingShare.totalLP\n        IERC20 metapool = IERC20(manager.stableSwapMetaPoolAddress());\n        // add an extra step to be able to decrease rewards if locking end is near\n        pendingLpReward = StakingFormulas(this.stakingFormulasAddress())\n            .lpRewardsRemoveLiquidityNormalization(stake, bs, pendingLpReward);\n        uint256 correctedAmount = StakingFormulas(this.stakingFormulasAddress())\n            .correctedAmountToWithdraw(\n            StakingShare(manager.stakingShareAddress()).totalLP(),\n            metapool.balanceOf(address(this)) - lpRewards,\n            _amount\n        );\n        lpRewards -= pendingLpReward;\n        stake.lpAmount -= _amount;\n        // stake.lpRewardDebt = (staking shares * accLpRewardPerShare) /  1e18;\n        // user.amount.mul(pool.accSushiPerShare).div(1e12);\n        // should be done after masterchef withdraw\n        stake.lpRewardDebt = (\n            IUbiquityChef(manager.masterChefAddress()).getStakingShareInfo(_id)[0]\n                * accLpRewardPerShare\n        ) / 1e12;\n        StakingShare(manager.stakingShareAddress()).updateStake(\n            _id, stake.lpAmount, stake.lpRewardDebt, stake.endBlock\n        );\n        // lastly redeem lp tokens\n        metapool.safeTransfer(msg.sender, correctedAmount + pendingLpReward);\n        emit RemoveLiquidityFromStake(\n            msg.sender,\n            _id,\n            _amount,\n            correctedAmount,\n            pendingLpReward,\n            sharesToRemove\n            );\n    }\n    // View function to see pending lpRewards on frontend.\n    function pendingLpRewards(uint256 _id) external view returns (uint256) {\n        StakingShare staking = StakingShare(manager.stakingShareAddress());\n        StakingShare.Stake memory stake = staking.getStake(_id);\n        uint256[2] memory bs =\n            IUbiquityChef(manager.masterChefAddress()).getStakingShareInfo(_id);\n        uint256 lpBalance =\n            IERC20(manager.stableSwapMetaPoolAddress()).balanceOf(address(this));\n        // the excess LP is the current balance minus the total deposited LP\n        if (lpBalance >= (staking.totalLP() + totalLpToMigrate)) {\n            uint256 currentLpRewards =\n                lpBalance - (staking.totalLP() + totalLpToMigrate);\n            uint256 curAccLpRewardPerShare = accLpRewardPerShare;\n            // if new rewards we should calculate the new curAccLpRewardPerShare\n            if (currentLpRewards > lpRewards) {\n                uint256 newLpRewards = currentLpRewards - lpRewards;\n                curAccLpRewardPerShare = accLpRewardPerShare\n                    + (\n                        (newLpRewards * 1e12)\n                            / IUbiquityChef(manager.masterChefAddress()).totalShares()\n                    );\n            }\n            // we multiply the shares amount by the accumulated lpRewards per share\n            // and remove the lp Reward Debt\n            return (bs[0] * (curAccLpRewardPerShare)) / (1e12)\n                - (stake.lpRewardDebt);\n        }\n        return 0;\n    }\n    function pause() public virtual onlyPauser {\n        _pause();\n    }\n    function unpause() public virtual onlyPauser {\n        _unpause();\n    }\n    /// @dev migrate let a user migrate from V1\n    /// @notice user will then be able to migrate\n    function migrate() public whenMigrating returns (uint256 _id) {\n        _id = toMigrateId[msg.sender];\n        require(_id > 0, \"not v1 address\");\n        _migrate(\n            _toMigrateOriginals[_id - 1],\n            _toMigrateLpBalances[_id - 1],\n            _toMigrateWeeks[_id - 1]\n        );\n    }\n    /// @dev return the amount of Lp token rewards an amount of shares entitled\n    /// @param amount of staking shares\n    /// @param lpRewardDebt lp rewards that has already been distributed\n    function lpRewardForShares(uint256 amount, uint256 lpRewardDebt)\n        public\n        view\n        returns (uint256 pendingLpReward)\n    {\n        if (accLpRewardPerShare > 0) {\n            pendingLpReward =\n                (amount * accLpRewardPerShare) / 1e12 - (lpRewardDebt);\n        }\n    }\n    function currentShareValue() public view returns (uint256 priceShare) {\n        uint256 totalShares =\n            IUbiquityChef(manager.masterChefAddress()).totalShares();\n        // priceShare = totalLP / totalShares\n        priceShare = IUbiquityFormulas(manager.formulasAddress()).bondPrice(\n            StakingShare(manager.stakingShareAddress()).totalLP(),\n            totalShares,\n            ONE\n        );\n    }\n    /// @dev migrate let a user migrate from V1\n    /// @notice user will then be able to migrate\n    function _migrate(address user, uint256 _lpsAmount, uint256 _weeks)\n        internal\n        returns (uint256 _id)\n    {\n        require(toMigrateId[user] > 0, \"not v1 address\");\n        require(_lpsAmount > 0, \"LP amount is zero\");\n        require(\n            1 <= _weeks && _weeks <= 208,\n            \"Duration must be between 1 and 208 weeks\"\n        );\n        // unregister address\n        toMigrateId[user] = 0;\n        // calculate the amount of share based on the amount of lp deposited and the duration\n        uint256 _sharesAmount = IUbiquityFormulas(manager.formulasAddress())\n            .durationMultiply(_lpsAmount, _weeks, stakingDiscountMultiplier);\n        // update the accumulated lp rewards per shares\n        _updateLpPerShare();\n        // calculate end locking period block number\n        uint256 endBlock = block.number + _weeks * blockCountInAWeek;\n        _id = _mint(user, _lpsAmount, _sharesAmount, endBlock);\n        // reduce the total LP to migrate after the minting\n        // to keep the _updateLpPerShare calculation consistent\n        totalLpToMigrate -= _lpsAmount;\n        // set masterchef for Governance token rewards\n        IUbiquityChef(manager.masterChefAddress()).deposit(\n            user, _sharesAmount, _id\n        );\n        emit Migrated(user, _id, _lpsAmount, _sharesAmount, _weeks);\n    }\n    /// @dev update the accumulated excess LP per share\n    function _updateLpPerShare() internal {\n        StakingShare stake = StakingShare(manager.stakingShareAddress());\n        uint256 lpBalance =\n            IERC20(manager.stableSwapMetaPoolAddress()).balanceOf(address(this));\n        // the excess LP is the current balance\n        // minus the total deposited LP + LP that needs to be migrated\n        uint256 totalShares =\n            IUbiquityChef(manager.masterChefAddress()).totalShares();\n        if (\n            lpBalance >= (stake.totalLP() + totalLpToMigrate) && totalShares > 0\n        ) {\n            uint256 currentLpRewards =\n                lpBalance - (stake.totalLP() + totalLpToMigrate);\n            // is there new LP rewards to be distributed ?\n            if (currentLpRewards > lpRewards) {\n                // we calculate the new accumulated LP rewards per share\n                accLpRewardPerShare = accLpRewardPerShare\n                    + (((currentLpRewards - lpRewards) * 1e12) / totalShares);\n                // update the bonding contract lpRewards\n                lpRewards = currentLpRewards;\n            }\n        }\n    }\n    function _mint(\n        address to,\n        uint256 lpAmount,\n        uint256 shares,\n        uint256 endBlock\n    ) internal returns (uint256) {\n        uint256 _currentShareValue = currentShareValue();\n        require(\n            _currentShareValue != 0, \"Staking: share value should not be null\"\n        );\n        // set the lp rewards debts so that this staking share only get lp rewards from this day\n        uint256 lpRewardDebt = (shares * accLpRewardPerShare) / 1e12;\n        return StakingShare(manager.stakingShareAddress()).mint(\n            to, lpAmount, lpRewardDebt, endBlock\n        );\n    }\n    function _checkForLiquidity(uint256 _id)\n        internal\n        returns (uint256[2] memory bs, StakingShare.Stake memory stake)\n    {\n        require(\n            IERC1155Ubiquity(manager.stakingShareAddress()).balanceOf(\n                msg.sender, _id\n            ) == 1,\n            \"Staking: caller is not owner\"\n        );\n        StakingShare staking = StakingShare(manager.stakingShareAddress());\n        stake = staking.getStake(_id);\n        require(\n            block.number > stake.endBlock,\n            \"Staking: Redeem not allowed before staking time\"\n        );\n        ITWAPOracleDollar3pool(manager.twapOracleAddress()).update();\n        bs = IUbiquityChef(manager.masterChefAddress()).getStakingShareInfo(_id);\n    }\n}"
    },
    {
        "tag": "bad randomness",
        "url": "https://github.com/artgobblers/art-gobblers/commit/ab35c045468bfa3b74e0ccb2307358f6dd74cbe6",
        "file": "src/ArtGobblers.sol",
        "before": "// SPDX-License-Identifier: Unlicense\npragma solidity >=0.8.0;\nimport {FixedPointMathLib} from \"solmate/utils/FixedPointMathLib.sol\";\nimport {ERC1155, ERC1155TokenReceiver} from \"solmate/tokens/ERC1155.sol\";\nimport {VRFConsumerBase} from \"chainlink/v0.8/VRFConsumerBase.sol\";\nimport {VRGDA} from \"./utils/VRGDA.sol\";\nimport {LibString} from \"./utils/LibString.sol\";\nimport {LogisticVRGDA} from \"./utils/LogisticVRGDA.sol\";\nimport {MerkleProofLib} from \"./utils/MerkleProofLib.sol\";\nimport {GobblersERC1155B} from \"./utils/GobblersERC1155B.sol\";\nimport {Goop} from \"./Goop.sol\";\n/// @title Art Gobblers NFT\n/// @notice Art Gobblers scan the cosmos in search of art producing life.\ncontract ArtGobblers is GobblersERC1155B, LogisticVRGDA, VRFConsumerBase, ERC1155TokenReceiver {\n    using LibString for uint256;\n    using FixedPointMathLib for uint256;\n    /*//////////////////////////////////////////////////////////////\n                                ADDRESSES\n    //////////////////////////////////////////////////////////////*/\n    Goop public immutable goop;\n    address public immutable team;\n    /*//////////////////////////////////////////////////////////////\n                            SUPPLY CONSTANTS\n    //////////////////////////////////////////////////////////////*/\n    /// @notice Maximum number of mintable gobblers.\n    uint256 public constant MAX_SUPPLY = 10000;\n    /// @notice Maximum amount of gobblers mintable via mintlist.\n    uint256 public constant MINTLIST_SUPPLY = 2000;\n    /// @notice Maximum amount of mintable leader gobblers.\n    uint256 public constant LEADER_SUPPLY = 10;\n    /// @notice Maximum amount of gobblers that will go to the team.\n    uint256 public constant TEAM_SUPPLY = 799;\n    /// @notice Maximum amount of gobblers that can be minted via VRGDA.\n    uint256 public constant MAX_MINTABLE = MAX_SUPPLY - MINTLIST_SUPPLY - LEADER_SUPPLY - TEAM_SUPPLY;\n    /*//////////////////////////////////////////////////////////////\n                                  URIS\n    //////////////////////////////////////////////////////////////*/\n    /// @notice Base URI for minted gobblers.\n    string public BASE_URI;\n    /// @notice URI for gobblers that have yet to be revealed.\n    string public UNREVEALED_URI;\n    /*//////////////////////////////////////////////////////////////\n                              VRF CONSTANTS\n    //////////////////////////////////////////////////////////////*/\n    bytes32 internal immutable chainlinkKeyHash;\n    uint256 internal immutable chainlinkFee;\n    /*//////////////////////////////////////////////////////////////\n                             MINTLIST STATE\n    //////////////////////////////////////////////////////////////*/\n    /// @notice Merkle root of mint mintlist.\n    bytes32 public immutable merkleRoot;\n    /// @notice Mapping to keep track of which addresses have claimed from mintlist.\n    mapping(address => bool) public hasClaimedMintlistGobbler;\n    /*//////////////////////////////////////////////////////////////\n                            VRGDA INPUT STATE\n    //////////////////////////////////////////////////////////////*/\n    /// @notice Timestamp for the start of minting.\n    uint256 public immutable mintStart;\n    /// @notice Number of gobblers minted from goop.\n    uint128 public numMintedFromGoop;\n    /*//////////////////////////////////////////////////////////////\n                         STANDARD GOBBLER STATE\n    //////////////////////////////////////////////////////////////*/\n    /// @notice Id of the most recently minted non leader gobbler.\n    /// @dev Will be 0 if no non leader gobblers have been minted yet.\n    uint128 public currentNonLeaderId;\n    /// @notice The number of gobblers minted to the team.\n    uint256 public numMintedForTeam;\n    /*//////////////////////////////////////////////////////////////\n                      LEADER GOBBLER AUCTION STATE\n    //////////////////////////////////////////////////////////////*/\n    /// @notice The last LEADER_SUPPLY ids are reserved for leader gobblers.\n    uint256 internal constant FIRST_LEADER_GOBBLER_ID = MAX_SUPPLY - LEADER_SUPPLY + 1;\n    /// @notice Struct holding data required for leader gobbler auctions.\n    struct LeaderGobblerAuctionData {\n        // Start price of current leader gobbler auction.\n        uint120 startPrice;\n        // Start timestamp of current leader gobbler auction.\n        uint120 startTimestamp;\n        // Id of the current leader gobbler being\n        // auctioned. 16 bits has a max value of\n        // ~60k which is within our limits here.\n        uint16 gobblerId;\n    }\n    /// @notice Data about the current leader gobbler auction.\n    LeaderGobblerAuctionData public leaderGobblerAuctionData;\n    /*//////////////////////////////////////////////////////////////\n                          GOBBLER REVEAL STATE\n    //////////////////////////////////////////////////////////////*/\n    /// @notice Struct holding data required for gobbler reveals.\n    struct GobblerRevealsData {\n        // Last random seed obtained from VRF.\n        uint64 randomSeed;\n        // Next reveal cannot happen before this timestamp.\n        uint64 nextRevealTimestamp;\n        // Id of latest gobbler which has been revealed so far.\n        uint56 lastRevealedId;\n        // Remaining gobblers to be assigned from the current seed.\n        uint56 toBeAssigned;\n        // Whether we are waiting to receive a seed from Chainlink.\n        bool waitingForSeed;\n    }\n    /// @notice Data about the current state of gobbler reveals.\n    GobblerRevealsData public gobblerRevealsData;\n    /*//////////////////////////////////////////////////////////////\n                             EMISSION STATE\n    //////////////////////////////////////////////////////////////*/\n    /// @notice Struct data info required for goop emission reward calculations.\n    struct EmissionData {\n        // The sum of the multiples of all gobblers the user holds.\n        uint64 emissionMultiple;\n        // Balance at time of last deposit or withdrawal.\n        uint128 lastBalance;\n        // Timestamp of last deposit or withdrawal.\n        uint64 lastTimestamp;\n    }\n    /// @notice Maps user addresses to their emission data.\n    mapping(address => EmissionData) public getEmissionDataForUser;\n    /*//////////////////////////////////////////////////////////////\n                            ART FEEDING STATE\n    //////////////////////////////////////////////////////////////*/\n    /// @notice Mapping from NFT contracts to their ids to gobbler ids they were fed to.\n    mapping(address => mapping(uint256 => uint256)) public getGobblerFromFedArt;\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n    event GoopAdded(address indexed user, uint256 goopAdded);\n    event GoopRemoved(address indexed user, uint256 goopAdded);\n    event GobblerClaimed(address indexed user, uint256 indexed gobblerId);\n    event GobblerPurchased(address indexed user, uint256 indexed gobblerId, uint256 price);\n    event GobblerMintedForTeam(address indexed user, uint256 indexed gobblerId);\n    event LeaderGobblerMinted(address indexed user, uint256 indexed gobblerId, uint256[] burnedGobblerIds);\n    event RandomnessRequested(address indexed user, uint256 toBeAssigned);\n    event RandomnessFulfilled(uint256 randomness);\n    event GobblersRevealed(address indexed user, uint256 numGobblers, uint256 lastRevealedId);\n    event ArtFeedToGobbler(address indexed user, uint256 indexed gobblerId, address indexed nft, uint256 id);\n    /*//////////////////////////////////////////////////////////////\n                                 ERRORS\n    //////////////////////////////////////////////////////////////*/\n    error Unauthorized();\n    error NoRemainingLeaderGobblers();\n    error CannotBurnLeader(uint256 gobblerId);\n    error AlreadyEaten(uint256 gobblerId, address nft, uint256 id);\n    error PriceExceededMax(uint256 currentPrice, uint256 maxPrice);\n    error IncorrectGobblerAmount(uint256 provided, uint256 needed);\n    /*//////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n    constructor(\n        // Mint config:\n        bytes32 _merkleRoot,\n        uint256 _mintStart,\n        // Addresses:\n        Goop _goop,\n        address _team,\n        // Chainlink:\n        address _vrfCoordinator,\n        address _linkToken,\n        bytes32 _chainlinkKeyHash,\n        uint256 _chainlinkFee,\n        // URIs:\n        string memory _baseUri,\n        string memory _unrevealedUri\n    )\n        VRFConsumerBase(_vrfCoordinator, _linkToken)\n        VRGDA(\n            6.9e18, // Initial price.\n            0.31e18 // Per period price decrease.\n        )\n        LogisticVRGDA(\n            // Max mintable gobblers.\n            int256(MAX_MINTABLE * 1e18),\n            0.014e18 // Time scale.\n        )\n    {\n        mintStart = _mintStart;\n        merkleRoot = _merkleRoot;\n        goop = _goop;\n        team = _team;\n        chainlinkKeyHash = _chainlinkKeyHash;\n        chainlinkFee = _chainlinkFee;\n        BASE_URI = _baseUri;\n        UNREVEALED_URI = _unrevealedUri;\n        // Starting price for leader gobblers is 100 gobblers.\n        leaderGobblerAuctionData.startPrice = 100;\n        // First leader gobbler auction starts 30 days after the mint starts.\n        leaderGobblerAuctionData.startTimestamp = uint120(_mintStart + 30 days);\n        // Current leader id starts at beginning of leader id space.\n        leaderGobblerAuctionData.gobblerId = uint16(FIRST_LEADER_GOBBLER_ID);\n        // Reveal for initial mint must wait 24 hours\n        gobblerRevealsData.nextRevealTimestamp = uint64(_mintStart + 1 days);\n    }\n    /*//////////////////////////////////////////////////////////////\n                          MINTLIST CLAIM LOGIC\n    //////////////////////////////////////////////////////////////*/\n    /// @notice Claim from mintlist, using a merkle proof.\n    /// @param proof Merkle proof to verify the sender is mintlisted.\n    /// @return gobblerId The id of the gobbler that was claimed.\n    function claimGobbler(bytes32[] calldata proof) external returns (uint256 gobblerId) {\n        // If minting has not yet begun or the user has already claimed, revert.\n        if (mintStart > block.timestamp || hasClaimedMintlistGobbler[msg.sender]) revert Unauthorized();\n        // If the user's proof is invalid, revert.\n        if (!MerkleProofLib.verify(proof, merkleRoot, keccak256(abi.encodePacked(msg.sender)))) revert Unauthorized();\n        hasClaimedMintlistGobbler[msg.sender] = true; // Before mint to prevent reentrancy.\n        unchecked {\n            emit GobblerClaimed(msg.sender, gobblerId = ++currentNonLeaderId);\n            _mint(msg.sender, gobblerId, \"\");\n        }\n    }\n    /*//////////////////////////////////////////////////////////////\n                              MINTING LOGIC\n    //////////////////////////////////////////////////////////////*/\n    /// @notice Mint a gobbler with goop, burning the cost.\n    /// @param maxPrice Maximum price to pay to mint the gobbler.\n    /// @return gobblerId The id of the gobbler that was minted.\n    function mintFromGoop(uint256 maxPrice) external returns (uint256 gobblerId) {\n        // No need to check mint cap, gobblerPrice()\n        // will revert due to overflow if we reach it.\n        // It will also revert prior to the mint start.\n        uint256 currentPrice = gobblerPrice();\n        // If the current price is above the user's specified max, revert.\n        if (currentPrice > maxPrice) revert PriceExceededMax(currentPrice, maxPrice);\n        goop.burnForGobblers(msg.sender, currentPrice);\n        unchecked {\n            ++numMintedFromGoop; // Before mint to prevent reentrancy.\n            emit GobblerPurchased(msg.sender, gobblerId = ++currentNonLeaderId, currentPrice);\n            _mint(msg.sender, gobblerId, \"\");\n        }\n    }\n    /// @notice Gobbler pricing in terms of goop.\n    /// @dev Will revert if called before minting starts\n    /// or after all gobblers have been minted via VRGDA.\n    function gobblerPrice() public view returns (uint256) {\n        // We need checked math here to cause overflow\n        // before minting has begun, preventing mints.\n        uint256 timeSinceStart = block.timestamp - mintStart;\n        return getPrice(timeSinceStart, numMintedFromGoop);\n    }\n    /*//////////////////////////////////////////////////////////////\n                           TEAM MINTING LOGIC\n    //////////////////////////////////////////////////////////////*/\n    /// @notice Mint a gobbler for the team.\n    /// @dev Team cannot never mint more than 10% of\n    /// the circulating supply of auctioned gobblers.\n    /// @return gobblerId The id of the gobbler that was minted.\n    function mintForTeam() external returns (uint256 gobblerId) {\n        unchecked {\n            // Can mint up to 10% of the current auctioned gobblers.\n            uint256 currentMintLimit = numMintedFromGoop / 10;\n            // Check that we wouldn't go over the limit after minting.\n            if (++numMintedForTeam > currentMintLimit) revert Unauthorized();\n            emit GobblerMintedForTeam(msg.sender, gobblerId = ++currentNonLeaderId);\n            _mint(address(team), gobblerId, \"\");\n        }\n    }\n    /*//////////////////////////////////////////////////////////////\n                      LEADER GOBBLER AUCTION LOGIC\n    //////////////////////////////////////////////////////////////*/\n    /// @notice Mint a leader gobbler by burning multiple standard gobblers.\n    /// @param gobblerIds The ids of the standard gobblers to burn.\n    /// @return gobblerId The id of the leader gobbler that was minted.\n    function mintLeaderGobbler(uint256[] calldata gobblerIds) external returns (uint256 gobblerId) {\n        gobblerId = leaderGobblerAuctionData.gobblerId; // Assign id.\n        // If the current id is greater than the max supply, there are no remaining leaders.\n        if (gobblerId > MAX_SUPPLY) revert NoRemainingLeaderGobblers();\n        // This will revert if the auction hasn't started yet, no need to check here as well.\n        uint256 cost = leaderGobblerPrice();\n        if (gobblerIds.length != cost) revert IncorrectGobblerAmount(gobblerIds.length, cost);\n        // Overflow in here should not occur, as most math is on emission multiples, which are inherently small.\n        unchecked {\n            uint256 burnedMultipleTotal; // The leader's emissionMultiple will be 2x the sum of the gobblers burned.\n            /*//////////////////////////////////////////////////////////////\n                                    BATCH BURN LOGIC\n            //////////////////////////////////////////////////////////////*/\n            // Generate an amounts array locally to use in the event below.\n            uint256[] memory amounts = new uint256[](gobblerIds.length);\n            uint256 id; // Storing outside the loop saves ~7 gas per iteration.\n            for (uint256 i = 0; i < gobblerIds.length; ++i) {\n                id = gobblerIds[i];\n                if (id >= FIRST_LEADER_GOBBLER_ID) revert CannotBurnLeader(id);\n                require(getGobblerData[id].owner == msg.sender, \"WRONG_FROM\");\n                burnedMultipleTotal += getGobblerData[id].emissionMultiple;\n                getGobblerData[id].owner = address(0);\n                amounts[i] = 1;\n            }\n            emit TransferBatch(msg.sender, msg.sender, address(0), gobblerIds, amounts);\n            /*//////////////////////////////////////////////////////////////\n                                  LEADER MINTING LOGIC\n            //////////////////////////////////////////////////////////////*/\n            // The shift right by 1 is equivalent to multiplication by 2, used to make\n            // the leader's emissionMultiple 2x the sum of the multiples of the gobblers burned.\n            // Must be done before minting as the transfer hook will update the user's emissionMultiple.\n            getGobblerData[gobblerId].emissionMultiple = uint48(burnedMultipleTotal << 1);\n            // Update the user's emission data in one big batch. We add burnedMultipleTotal to their\n            // emission multiple (not burnedMultipleTotal * 2) to account for the standard gobblers that\n            // were burned and hence should have their multiples subtracted from the user's total multiple.\n            getEmissionDataForUser[msg.sender].lastBalance = uint128(goopBalance(msg.sender));\n            getEmissionDataForUser[msg.sender].lastTimestamp = uint64(block.timestamp);\n            getEmissionDataForUser[msg.sender].emissionMultiple += uint64(burnedMultipleTotal);\n            // Start a new auction, 30 days after the previous start, and update the current leader id.\n            // The new start price is max of 100 and cost * 2. Shift left by 1 is like multiplication by 2.\n            leaderGobblerAuctionData.gobblerId = uint16(gobblerId) + 1;\n            leaderGobblerAuctionData.startTimestamp += 30 days;\n            leaderGobblerAuctionData.startPrice = uint120(cost < 50 ? 100 : cost << 1);\n            // If gobblerIds has 1,000 elements this should cost around ~270,000 gas.\n            emit LeaderGobblerMinted(msg.sender, gobblerId, gobblerIds);\n            _mint(msg.sender, gobblerId, \"\");\n        }\n    }\n    /// @notice Calculate the leader gobbler price in terms of gobblers, according to linear decay function.\n    /// @dev Reverts due to underflow if the auction has not yet begun. This is intended behavior and helps save gas.\n    function leaderGobblerPrice() public view returns (uint256) {\n        // Cannot be unchecked, we want this to revert if the auction has not started yet.\n        uint256 daysSinceStart = (block.timestamp - leaderGobblerAuctionData.startTimestamp) / 1 days;\n        // If 30 or more days have passed, leader gobbler is free.\n        if (daysSinceStart >= 30) return 0;\n        unchecked {\n            // If we're less than 30 days into the auction, the price simply decays linearly until the 30th day.\n            return (leaderGobblerAuctionData.startPrice * (30 - daysSinceStart)) / 30;\n        }\n    }\n    /*//////////////////////////////////////////////////////////////\n                                VRF LOGIC\n    //////////////////////////////////////////////////////////////*/\n    /// @notice Get the random seed for revealing gobblers.\n    function getRandomSeed() external returns (bytes32) {\n        uint256 nextRevealTimestamp = gobblerRevealsData.nextRevealTimestamp;\n        // A new random seed cannot be requested before the next reveal timestamp.\n        if (block.timestamp < nextRevealTimestamp) revert Unauthorized();\n        // A random seed can only be requested when all gobblers from previous seed have been assigned.\n        // This prevents a user from requesting additional randomness in hopes of a more favorable outcome.\n        if (gobblerRevealsData.toBeAssigned != 0) revert Unauthorized();\n        // A new seed cannot be requested while we wait for a new seed.\n        if (gobblerRevealsData.waitingForSeed) revert Unauthorized();\n        unchecked {\n            // We want at most one batch of reveals every 24 hours.\n            gobblerRevealsData.nextRevealTimestamp = uint64(nextRevealTimestamp + 1 days);\n            // Fix number of gobblers to be revealed from seed.\n            gobblerRevealsData.toBeAssigned = uint56(currentNonLeaderId - gobblerRevealsData.lastRevealedId);\n            // Prevent revealing while we wait for the seed.\n            gobblerRevealsData.waitingForSeed = true;\n        }\n        emit RandomnessRequested(msg.sender, gobblerRevealsData.toBeAssigned);\n        // Will revert if we don't have enough LINK to afford the request.\n        return requestRandomness(chainlinkKeyHash, chainlinkFee);\n    }\n    /// @notice Callback from Chainlink VRF. Sets randomSeed.\n    function fulfillRandomness(bytes32, uint256 randomness) internal override {\n        // The unchecked cast to uint64 is equivalent to moduloing the randomness by 2**64.\n        gobblerRevealsData.randomSeed = uint64(randomness); // 64 bits of randomness is plenty.\n        gobblerRevealsData.waitingForSeed = false; // We have the seed now, open up reveals.\n        emit RandomnessFulfilled(randomness);\n    }\n    /*//////////////////////////////////////////////////////////////\n                          GOBBLER REVEAL LOGIC\n    //////////////////////////////////////////////////////////////*/\n    /// @notice Knuth shuffle to progressively reveal gobblers using entropy from random seed.\n    /// @param numGobblers The number of gobblers to reveal.\n    function revealGobblers(uint256 numGobblers) external {\n        uint256 currentRandomSeed = gobblerRevealsData.randomSeed;\n        uint256 currentLastRevealedId = gobblerRevealsData.lastRevealedId;\n        uint256 totalRemainingToBeAssigned = gobblerRevealsData.toBeAssigned;\n        // Can't reveal more gobblers than were available when seed was generated.\n        if (numGobblers > totalRemainingToBeAssigned) revert Unauthorized();\n        // Can't reveal if we're still waiting for a new seed.\n        if (gobblerRevealsData.waitingForSeed) revert Unauthorized();\n        emit GobblersRevealed(msg.sender, numGobblers, currentLastRevealedId);\n        // Implements a Knuth shuffle. If something in\n        // here can overflow we've got bigger problems.\n        unchecked {\n            for (uint256 i = 0; i < numGobblers; i++) {\n                /*//////////////////////////////////////////////////////////////\n                                      DETERMINE RANDOM SWAP\n                //////////////////////////////////////////////////////////////*/\n                // Number of ids that have not been revealed. Subtract 1\n                // because we don't want to include any leaders in the swap.\n                uint256 remainingIds = FIRST_LEADER_GOBBLER_ID - currentLastRevealedId - 1;\n                // Randomly pick distance for swap.\n                uint256 distance = currentRandomSeed % remainingIds;\n                // Current id is consecutive to last reveal.\n                uint256 currentId = ++currentLastRevealedId;\n                // Select swap id, adding distance to next reveal id.\n                uint256 swapId = currentId + distance;\n                /*//////////////////////////////////////////////////////////////\n                                       GET INDICES FOR IDS\n                //////////////////////////////////////////////////////////////*/\n                // Get the index of the swap id.\n                uint48 swapIndex = getGobblerData[swapId].idx == 0\n                    ? uint48(swapId) // Hasn't been shuffled before.\n                    : getGobblerData[swapId].idx; // Shuffled before.\n                // Get the owner of the current id.\n                address currentIdOwner = getGobblerData[currentId].owner;\n                // Get the index of the current id.\n                uint48 currentIndex = getGobblerData[currentId].idx == 0\n                    ? uint48(currentId) // Hasn't been shuffled before.\n                    : getGobblerData[currentId].idx; // Shuffled before.\n                /*//////////////////////////////////////////////////////////////\n                                  SWAP INDICES AND SET MULTIPLE\n                //////////////////////////////////////////////////////////////*/\n                // Determine the current id's new emission multiple.\n                uint256 newCurrentIdMultiple = 9; // For beyond 7963.\n                if (swapIndex <= 3054) newCurrentIdMultiple = 6;\n                else if (swapIndex <= 5672) newCurrentIdMultiple = 7;\n                else if (swapIndex <= 7963) newCurrentIdMultiple = 8;\n                // Swap the index and multiple of the current id.\n                getGobblerData[currentId].idx = swapIndex;\n                getGobblerData[currentId].emissionMultiple = uint48(newCurrentIdMultiple);\n                // Swap the index of the swap id.\n                getGobblerData[swapId].idx = currentIndex;\n                /*//////////////////////////////////////////////////////////////\n                                   UPDATE CURRENT ID MULTIPLE\n                //////////////////////////////////////////////////////////////*/\n                // Update the emission data for the owner of the current id.\n                getEmissionDataForUser[currentIdOwner].lastBalance = uint128(goopBalance(currentIdOwner));\n                getEmissionDataForUser[currentIdOwner].lastTimestamp = uint64(block.timestamp);\n                getEmissionDataForUser[currentIdOwner].emissionMultiple += uint64(newCurrentIdMultiple);\n\n                // Update the random seed to choose a new distance for the next iteration.\n                currentRandomSeed = uint256(keccak256(abi.encodePacked(currentRandomSeed)));\n            }\n\n            // Update relevant reveal state state all at once.\n\n    \n          \n            \n    \n\n          \n          Expand Down\n    \n    \n  \n            gobblerRevealsData.randomSeed = uint64(currentRandomSeed);\n            gobblerRevealsData.lastRevealedId = uint56(currentLastRevealedId);\n            gobblerRevealsData.toBeAssigned = uint56(totalRemainingToBeAssigned - numGobblers);\n        }\n    }\n    /*//////////////////////////////////////////////////////////////\n                                URI LOGIC\n    //////////////////////////////////////////////////////////////*/\n    /// @notice Returns a token's URI if it has been minted.\n    /// @param gobblerId The id of the token to get the URI for.\n    function uri(uint256 gobblerId) public view virtual override returns (string memory) {\n        // Between 0 and lastRevealed are revealed normal gobblers.\n        if (gobblerId <= gobblerRevealsData.lastRevealedId) {\n            // 0 is not a valid id:\n            if (gobblerId == 0) return \"\";\n            return string(abi.encodePacked(BASE_URI, uint256(getGobblerData[gobblerId].idx).toString()));\n        }\n        // Between lastRevealed + 1 and currentNonLeaderId are minted but not revealed.\n        if (gobblerId <= currentNonLeaderId) return UNREVEALED_URI;\n        // Between currentNonLeaderId and FIRST_LEADER_GOBBLER_ID are unminted.\n        if (gobblerId < FIRST_LEADER_GOBBLER_ID) return \"\";\n        // Between FIRST_LEADER_GOBBLER_ID and gobblerId are minted leaders.\n        if (gobblerId < leaderGobblerAuctionData.gobblerId)\n            return string(abi.encodePacked(BASE_URI, gobblerId.toString()));\n        return \"\"; // Unminted leaders and invalid token ids.\n    }\n    /*//////////////////////////////////////////////////////////////\n                            ART FEEDING LOGIC\n    //////////////////////////////////////////////////////////////*/\n    /// @notice Feed a gobbler a work of art.\n    /// @param gobblerId The gobbler to feed the page.\n    /// @param nft The contract of the work of art.\n    /// @param id The id of the work of art.\n    /// @dev NFTs should be ERC1155s, ideally ERC1155Bs.\n    function feedArt(\n        uint256 gobblerId,\n        address nft,\n        uint256 id\n    ) external {\n        // The caller must own the gobbler they're feeding.\n        if (getGobblerData[gobblerId].owner != msg.sender) revert Unauthorized();\n        // In case the NFT is not an 1155B, we prevent eating it twice.\n        if (getGobblerFromFedArt[nft][id] != 0) revert AlreadyEaten(gobblerId, nft, id);\n        // Map the NFT to the gobbler that ate it.\n        getGobblerFromFedArt[nft][id] = gobblerId;\n        emit ArtFeedToGobbler(msg.sender, gobblerId, nft, id);\n        // We're assuming this is an 1155B-like NFT, so we'll only transfer 1.\n        ERC1155(nft).safeTransferFrom(msg.sender, address(this), id, 1, \"\");\n    }\n    /*//////////////////////////////////////////////////////////////\n                             EMISSION LOGIC\n    //////////////////////////////////////////////////////////////*/\n    /// @notice Calculate a user's staked goop balance.\n    /// @param user The user to query balance for.\n    function goopBalance(address user) public view returns (uint256) {\n        // If a user's goop balance is greater than\n        // 2**256 - 1 we've got much bigger problems.\n        unchecked {\n            uint256 emissionMultiple = getEmissionDataForUser[user].emissionMultiple;\n            uint256 lastBalanceWad = getEmissionDataForUser[user].lastBalance;\n            // Stored with 18 decimals, such that if a day and a half elapsed this variable would equal 1.5e18.\n            uint256 daysElapsedWad = ((block.timestamp - getEmissionDataForUser[user].lastTimestamp) * 1e18) / 1 days;\n            uint256 daysElapsedSquaredWad = daysElapsedWad.mulWadDown(daysElapsedWad); // Need to use wad math here.\n            // prettier-ignore\n            return lastBalanceWad + // The last recorded balance.\n                \n            // Don't need to do wad multiplication since we're\n            // multiplying by a plain integer with no decimals.\n            // Shift right by 2 is equivalent to division by 4.\n            ((emissionMultiple * daysElapsedSquaredWad) >> 2) +\n            \n            daysElapsedWad.mulWadDown( // Terms are wads, so must mulWad.\n                // No wad multiplication for emissionMultiple * lastBalance\n                // because emissionMultiple is a plain integer with no decimals.\n                // We multiply the sqrt's radicand by 1e18 because it expects ints.\n                (emissionMultiple * lastBalanceWad * 1e18).sqrt()\n            );\n        }\n    }\n    /// @notice Add goop to your emission balance.\n    /// @param goopAmount The amount of goop to add.\n    function addGoop(uint256 goopAmount) external {\n        // Burn goop being added to gobbler.\n        goop.burnForGobblers(msg.sender, goopAmount);\n        unchecked {\n            // If a user has enough goop to overflow their balance we've got big problems.\n            getEmissionDataForUser[msg.sender].lastBalance = uint128(goopBalance(msg.sender) + goopAmount);\n            getEmissionDataForUser[msg.sender].lastTimestamp = uint64(block.timestamp);\n        }\n        emit GoopAdded(msg.sender, goopAmount);\n    }\n    /// @notice Remove goop from your emission balance.\n    /// @param goopAmount The amount of goop to remove.\n    function removeGoop(uint256 goopAmount) external {\n        // Will revert due to underflow if removed amount is larger than the user's current goop balance.\n        getEmissionDataForUser[msg.sender].lastBalance = uint128(goopBalance(msg.sender) - goopAmount);\n        getEmissionDataForUser[msg.sender].lastTimestamp = uint64(block.timestamp);\n        emit GoopRemoved(msg.sender, goopAmount);\n        goop.mintForGobblers(msg.sender, goopAmount);\n    }\n    /*//////////////////////////////////////////////////////////////\n                          CONVENIENCE FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n    /// @notice Convenience function to get emission emissionMultiple for a gobbler.\n    /// @param gobblerId The gobbler to get emissionMultiple for.\n    function getGobblerEmissionMultiple(uint256 gobblerId) external view returns (uint256) {\n        return getGobblerData[gobblerId].emissionMultiple;\n    }\n    /// @notice Convenience function to get emission emissionMultiple for a user.\n    /// @param user The user to get emissionMultiple for.\n    function getUserEmissionMultiple(address user) external view returns (uint256) {\n        return getEmissionDataForUser[user].emissionMultiple;\n    }\n    /*//////////////////////////////////////////////////////////////\n                             ERC1155B LOGIC\n    //////////////////////////////////////////////////////////////*/\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) public override {\n        require(ids.length == amounts.length, \"LENGTH_MISMATCH\");\n        require(msg.sender == from || isApprovedForAll[from][msg.sender], \"NOT_AUTHORIZED\");\n        // Storing these outside the loop saves ~15 gas per iteration.\n        uint256 id;\n        uint256 amount;\n        unchecked {\n            uint64 emissionsMultipleTotal; // Will use to set each user's multiple.\n            for (uint256 i = 0; i < ids.length; i++) {\n                id = ids[i];\n                amount = amounts[i];\n                // Can only transfer from the owner.\n                require(from == getGobblerData[id].owner, \"WRONG_FROM\");\n                // Can only transfer 1 with ERC1155B.\n                require(amount == 1, \"INVALID_AMOUNT\");\n                getGobblerData[id].owner = to;\n                emissionsMultipleTotal += getGobblerData[id].emissionMultiple;\n            }\n            // Decrease the from user's emissionMultiple by emissionsMultipleTotal.\n            getEmissionDataForUser[from].lastBalance = uint128(goopBalance(from));\n            getEmissionDataForUser[from].lastTimestamp = uint64(block.timestamp);\n            getEmissionDataForUser[from].emissionMultiple -= emissionsMultipleTotal;\n            // Increase the to user's emissionMultiple by emissionsMultipleTotal.\n            getEmissionDataForUser[to].lastBalance = uint128(goopBalance(to));\n            getEmissionDataForUser[to].lastTimestamp = uint64(block.timestamp);\n            getEmissionDataForUser[to].emissionMultiple += emissionsMultipleTotal;\n        }\n        emit TransferBatch(msg.sender, from, to, ids, amounts);\n        if (to.code.length != 0) {\n            require(\n                ERC1155TokenReceiver(to).onERC1155BatchReceived(msg.sender, from, ids, amounts, data) ==\n                    ERC1155TokenReceiver.onERC1155BatchReceived.selector,\n                \"UNSAFE_RECIPIENT\"\n            );\n        } else require(to != address(0), \"INVALID_RECIPIENT\");\n    }\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) public override {\n        require(msg.sender == from || isApprovedForAll[from][msg.sender], \"NOT_AUTHORIZED\");\n        require(from == getGobblerData[id].owner, \"WRONG_FROM\"); // Can only transfer from the owner.\n        // Can only transfer 1 with ERC1155B.\n        require(amount == 1, \"INVALID_AMOUNT\");\n        getGobblerData[id].owner = to;\n        unchecked {\n            // Get the transferred gobbler's emission multiple. Can be zero before reveal.\n            uint64 emissionMultiple = getGobblerData[id].emissionMultiple;\n            // Decrease the from user's emissionMultiple by the gobbler's emissionMultiple.\n            getEmissionDataForUser[from].lastBalance = uint128(goopBalance(from));\n            getEmissionDataForUser[from].lastTimestamp = uint64(block.timestamp);\n            getEmissionDataForUser[from].emissionMultiple -= emissionMultiple;\n            // Increase the to user's emissionMultiple by the gobbler's emissionMultiple.\n            getEmissionDataForUser[to].lastBalance = uint128(goopBalance(to));\n            getEmissionDataForUser[to].lastTimestamp = uint64(block.timestamp);\n            getEmissionDataForUser[to].emissionMultiple += emissionMultiple;\n        }\n        emit TransferSingle(msg.sender, from, to, id, amount);\n        if (to.code.length != 0) {\n            require(\n                ERC1155TokenReceiver(to).onERC1155Received(msg.sender, from, id, amount, data) ==\n                    ERC1155TokenReceiver.onERC1155Received.selector,\n                \"UNSAFE_RECIPIENT\"\n            );\n        } else require(to != address(0), \"INVALID_RECIPIENT\");\n    }\n}",
        "after": "// SPDX-License-Identifier: Unlicense\npragma solidity >=0.8.0;\nimport {FixedPointMathLib} from \"solmate/utils/FixedPointMathLib.sol\";\nimport {ERC1155, ERC1155TokenReceiver} from \"solmate/tokens/ERC1155.sol\";\nimport {VRFConsumerBase} from \"chainlink/v0.8/VRFConsumerBase.sol\";\nimport {VRGDA} from \"./utils/VRGDA.sol\";\nimport {LibString} from \"./utils/LibString.sol\";\nimport {LogisticVRGDA} from \"./utils/LogisticVRGDA.sol\";\nimport {MerkleProofLib} from \"./utils/MerkleProofLib.sol\";\nimport {GobblersERC1155B} from \"./utils/GobblersERC1155B.sol\";\nimport {Goop} from \"./Goop.sol\";\n/// @title Art Gobblers NFT\n/// @notice Art Gobblers scan the cosmos in search of art producing life.\ncontract ArtGobblers is GobblersERC1155B, LogisticVRGDA, VRFConsumerBase, ERC1155TokenReceiver {\n    using LibString for uint256;\n    using FixedPointMathLib for uint256;\n    /*//////////////////////////////////////////////////////////////\n                                ADDRESSES\n    //////////////////////////////////////////////////////////////*/\n    Goop public immutable goop;\n    address public immutable team;\n    /*//////////////////////////////////////////////////////////////\n                            SUPPLY CONSTANTS\n    //////////////////////////////////////////////////////////////*/\n    /// @notice Maximum number of mintable gobblers.\n    uint256 public constant MAX_SUPPLY = 10000;\n    /// @notice Maximum amount of gobblers mintable via mintlist.\n    uint256 public constant MINTLIST_SUPPLY = 2000;\n    /// @notice Maximum amount of mintable leader gobblers.\n    uint256 public constant LEADER_SUPPLY = 10;\n    /// @notice Maximum amount of gobblers that will go to the team.\n    uint256 public constant TEAM_SUPPLY = 799;\n    /// @notice Maximum amount of gobblers that can be minted via VRGDA.\n    uint256 public constant MAX_MINTABLE = MAX_SUPPLY - MINTLIST_SUPPLY - LEADER_SUPPLY - TEAM_SUPPLY;\n    /*//////////////////////////////////////////////////////////////\n                                  URIS\n    //////////////////////////////////////////////////////////////*/\n    /// @notice Base URI for minted gobblers.\n    string public BASE_URI;\n    /// @notice URI for gobblers that have yet to be revealed.\n    string public UNREVEALED_URI;\n    /*//////////////////////////////////////////////////////////////\n                              VRF CONSTANTS\n    //////////////////////////////////////////////////////////////*/\n    bytes32 internal immutable chainlinkKeyHash;\n    uint256 internal immutable chainlinkFee;\n    /*//////////////////////////////////////////////////////////////\n                             MINTLIST STATE\n    //////////////////////////////////////////////////////////////*/\n    /// @notice Merkle root of mint mintlist.\n    bytes32 public immutable merkleRoot;\n    /// @notice Mapping to keep track of which addresses have claimed from mintlist.\n    mapping(address => bool) public hasClaimedMintlistGobbler;\n    /*//////////////////////////////////////////////////////////////\n                            VRGDA INPUT STATE\n    //////////////////////////////////////////////////////////////*/\n    /// @notice Timestamp for the start of minting.\n    uint256 public immutable mintStart;\n    /// @notice Number of gobblers minted from goop.\n    uint128 public numMintedFromGoop;\n    /*//////////////////////////////////////////////////////////////\n                         STANDARD GOBBLER STATE\n    //////////////////////////////////////////////////////////////*/\n    /// @notice Id of the most recently minted non leader gobbler.\n    /// @dev Will be 0 if no non leader gobblers have been minted yet.\n    uint128 public currentNonLeaderId;\n    /// @notice The number of gobblers minted to the team.\n    uint256 public numMintedForTeam;\n    /*//////////////////////////////////////////////////////////////\n                      LEADER GOBBLER AUCTION STATE\n    //////////////////////////////////////////////////////////////*/\n    /// @notice The last LEADER_SUPPLY ids are reserved for leader gobblers.\n    uint256 internal constant FIRST_LEADER_GOBBLER_ID = MAX_SUPPLY - LEADER_SUPPLY + 1;\n    /// @notice Struct holding data required for leader gobbler auctions.\n    struct LeaderGobblerAuctionData {\n        // Start price of current leader gobbler auction.\n        uint120 startPrice;\n        // Start timestamp of current leader gobbler auction.\n        uint120 startTimestamp;\n        // Id of the current leader gobbler being\n        // auctioned. 16 bits has a max value of\n        // ~60k which is within our limits here.\n        uint16 gobblerId;\n    }\n    /// @notice Data about the current leader gobbler auction.\n    LeaderGobblerAuctionData public leaderGobblerAuctionData;\n    /*//////////////////////////////////////////////////////////////\n                          GOBBLER REVEAL STATE\n    //////////////////////////////////////////////////////////////*/\n    /// @notice Struct holding data required for gobbler reveals.\n    struct GobblerRevealsData {\n        // Last random seed obtained from VRF.\n        uint64 randomSeed;\n        // Next reveal cannot happen before this timestamp.\n        uint64 nextRevealTimestamp;\n        // Id of latest gobbler which has been revealed so far.\n        uint56 lastRevealedId;\n        // Remaining gobblers to be assigned from the current seed.\n        uint56 toBeAssigned;\n        // Whether we are waiting to receive a seed from Chainlink.\n        bool waitingForSeed;\n    }\n    /// @notice Data about the current state of gobbler reveals.\n    GobblerRevealsData public gobblerRevealsData;\n    /*//////////////////////////////////////////////////////////////\n                             EMISSION STATE\n    //////////////////////////////////////////////////////////////*/\n    /// @notice Struct data info required for goop emission reward calculations.\n    struct EmissionData {\n        // The sum of the multiples of all gobblers the user holds.\n        uint64 emissionMultiple;\n        // Balance at time of last deposit or withdrawal.\n        uint128 lastBalance;\n        // Timestamp of last deposit or withdrawal.\n        uint64 lastTimestamp;\n    }\n    /// @notice Maps user addresses to their emission data.\n    mapping(address => EmissionData) public getEmissionDataForUser;\n    /*//////////////////////////////////////////////////////////////\n                            ART FEEDING STATE\n    //////////////////////////////////////////////////////////////*/\n    /// @notice Mapping from NFT contracts to their ids to gobbler ids they were fed to.\n    mapping(address => mapping(uint256 => uint256)) public getGobblerFromFedArt;\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n    event GoopAdded(address indexed user, uint256 goopAdded);\n    event GoopRemoved(address indexed user, uint256 goopAdded);\n    event GobblerClaimed(address indexed user, uint256 indexed gobblerId);\n    event GobblerPurchased(address indexed user, uint256 indexed gobblerId, uint256 price);\n    event GobblerMintedForTeam(address indexed user, uint256 indexed gobblerId);\n    event LeaderGobblerMinted(address indexed user, uint256 indexed gobblerId, uint256[] burnedGobblerIds);\n    event RandomnessRequested(address indexed user, uint256 toBeAssigned);\n    event RandomnessFulfilled(uint256 randomness);\n    event GobblersRevealed(address indexed user, uint256 numGobblers, uint256 lastRevealedId);\n    event ArtFeedToGobbler(address indexed user, uint256 indexed gobblerId, address indexed nft, uint256 id);\n    /*//////////////////////////////////////////////////////////////\n                                 ERRORS\n    //////////////////////////////////////////////////////////////*/\n    error Unauthorized();\n    error NoRemainingLeaderGobblers();\n    error CannotBurnLeader(uint256 gobblerId);\n    error AlreadyEaten(uint256 gobblerId, address nft, uint256 id);\n    error PriceExceededMax(uint256 currentPrice, uint256 maxPrice);\n    error IncorrectGobblerAmount(uint256 provided, uint256 needed);\n    /*//////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n    constructor(\n        // Mint config:\n        bytes32 _merkleRoot,\n        uint256 _mintStart,\n        // Addresses:\n        Goop _goop,\n        address _team,\n        // Chainlink:\n        address _vrfCoordinator,\n        address _linkToken,\n        bytes32 _chainlinkKeyHash,\n        uint256 _chainlinkFee,\n        // URIs:\n        string memory _baseUri,\n        string memory _unrevealedUri\n    )\n        VRFConsumerBase(_vrfCoordinator, _linkToken)\n        VRGDA(\n            6.9e18, // Initial price.\n            0.31e18 // Per period price decrease.\n        )\n        LogisticVRGDA(\n            // Max mintable gobblers.\n            int256(MAX_MINTABLE * 1e18),\n            0.014e18 // Time scale.\n        )\n    {\n        mintStart = _mintStart;\n        merkleRoot = _merkleRoot;\n        goop = _goop;\n        team = _team;\n        chainlinkKeyHash = _chainlinkKeyHash;\n        chainlinkFee = _chainlinkFee;\n        BASE_URI = _baseUri;\n        UNREVEALED_URI = _unrevealedUri;\n        // Starting price for leader gobblers is 100 gobblers.\n        leaderGobblerAuctionData.startPrice = 100;\n        // First leader gobbler auction starts 30 days after the mint starts.\n        leaderGobblerAuctionData.startTimestamp = uint120(_mintStart + 30 days);\n        // Current leader id starts at beginning of leader id space.\n        leaderGobblerAuctionData.gobblerId = uint16(FIRST_LEADER_GOBBLER_ID);\n        // Reveal for initial mint must wait 24 hours\n        gobblerRevealsData.nextRevealTimestamp = uint64(_mintStart + 1 days);\n    }\n    /*//////////////////////////////////////////////////////////////\n                          MINTLIST CLAIM LOGIC\n    //////////////////////////////////////////////////////////////*/\n    /// @notice Claim from mintlist, using a merkle proof.\n    /// @param proof Merkle proof to verify the sender is mintlisted.\n    /// @return gobblerId The id of the gobbler that was claimed.\n    function claimGobbler(bytes32[] calldata proof) external returns (uint256 gobblerId) {\n        // If minting has not yet begun or the user has already claimed, revert.\n        if (mintStart > block.timestamp || hasClaimedMintlistGobbler[msg.sender]) revert Unauthorized();\n        // If the user's proof is invalid, revert.\n        if (!MerkleProofLib.verify(proof, merkleRoot, keccak256(abi.encodePacked(msg.sender)))) revert Unauthorized();\n        hasClaimedMintlistGobbler[msg.sender] = true; // Before mint to prevent reentrancy.\n        unchecked {\n            emit GobblerClaimed(msg.sender, gobblerId = ++currentNonLeaderId);\n            _mint(msg.sender, gobblerId, \"\");\n        }\n    }\n    /*//////////////////////////////////////////////////////////////\n                              MINTING LOGIC\n    //////////////////////////////////////////////////////////////*/\n    /// @notice Mint a gobbler with goop, burning the cost.\n    /// @param maxPrice Maximum price to pay to mint the gobbler.\n    /// @return gobblerId The id of the gobbler that was minted.\n    function mintFromGoop(uint256 maxPrice) external returns (uint256 gobblerId) {\n        // No need to check mint cap, gobblerPrice()\n        // will revert due to overflow if we reach it.\n        // It will also revert prior to the mint start.\n        uint256 currentPrice = gobblerPrice();\n        // If the current price is above the user's specified max, revert.\n        if (currentPrice > maxPrice) revert PriceExceededMax(currentPrice, maxPrice);\n        goop.burnForGobblers(msg.sender, currentPrice);\n        unchecked {\n            ++numMintedFromGoop; // Before mint to prevent reentrancy.\n            emit GobblerPurchased(msg.sender, gobblerId = ++currentNonLeaderId, currentPrice);\n            _mint(msg.sender, gobblerId, \"\");\n        }\n    }\n    /// @notice Gobbler pricing in terms of goop.\n    /// @dev Will revert if called before minting starts\n    /// or after all gobblers have been minted via VRGDA.\n    function gobblerPrice() public view returns (uint256) {\n        // We need checked math here to cause overflow\n        // before minting has begun, preventing mints.\n        uint256 timeSinceStart = block.timestamp - mintStart;\n        return getPrice(timeSinceStart, numMintedFromGoop);\n    }\n    /*//////////////////////////////////////////////////////////////\n                           TEAM MINTING LOGIC\n    //////////////////////////////////////////////////////////////*/\n    /// @notice Mint a gobbler for the team.\n    /// @dev Team cannot never mint more than 10% of\n    /// the circulating supply of auctioned gobblers.\n    /// @return gobblerId The id of the gobbler that was minted.\n    function mintForTeam() external returns (uint256 gobblerId) {\n        unchecked {\n            // Can mint up to 10% of the current auctioned gobblers.\n            uint256 currentMintLimit = numMintedFromGoop / 10;\n            // Check that we wouldn't go over the limit after minting.\n            if (++numMintedForTeam > currentMintLimit) revert Unauthorized();\n            emit GobblerMintedForTeam(msg.sender, gobblerId = ++currentNonLeaderId);\n            _mint(address(team), gobblerId, \"\");\n        }\n    }\n    /*//////////////////////////////////////////////////////////////\n                      LEADER GOBBLER AUCTION LOGIC\n    //////////////////////////////////////////////////////////////*/\n    /// @notice Mint a leader gobbler by burning multiple standard gobblers.\n    /// @param gobblerIds The ids of the standard gobblers to burn.\n    /// @return gobblerId The id of the leader gobbler that was minted.\n    function mintLeaderGobbler(uint256[] calldata gobblerIds) external returns (uint256 gobblerId) {\n        gobblerId = leaderGobblerAuctionData.gobblerId; // Assign id.\n        // If the current id is greater than the max supply, there are no remaining leaders.\n        if (gobblerId > MAX_SUPPLY) revert NoRemainingLeaderGobblers();\n        // This will revert if the auction hasn't started yet, no need to check here as well.\n        uint256 cost = leaderGobblerPrice();\n        if (gobblerIds.length != cost) revert IncorrectGobblerAmount(gobblerIds.length, cost);\n        // Overflow in here should not occur, as most math is on emission multiples, which are inherently small.\n        unchecked {\n            uint256 burnedMultipleTotal; // The leader's emissionMultiple will be 2x the sum of the gobblers burned.\n            /*//////////////////////////////////////////////////////////////\n                                    BATCH BURN LOGIC\n            //////////////////////////////////////////////////////////////*/\n            // Generate an amounts array locally to use in the event below.\n            uint256[] memory amounts = new uint256[](gobblerIds.length);\n            uint256 id; // Storing outside the loop saves ~7 gas per iteration.\n            for (uint256 i = 0; i < gobblerIds.length; ++i) {\n                id = gobblerIds[i];\n                if (id >= FIRST_LEADER_GOBBLER_ID) revert CannotBurnLeader(id);\n                require(getGobblerData[id].owner == msg.sender, \"WRONG_FROM\");\n                burnedMultipleTotal += getGobblerData[id].emissionMultiple;\n                getGobblerData[id].owner = address(0);\n                amounts[i] = 1;\n            }\n            emit TransferBatch(msg.sender, msg.sender, address(0), gobblerIds, amounts);\n            /*//////////////////////////////////////////////////////////////\n                                  LEADER MINTING LOGIC\n            //////////////////////////////////////////////////////////////*/\n            // The shift right by 1 is equivalent to multiplication by 2, used to make\n            // the leader's emissionMultiple 2x the sum of the multiples of the gobblers burned.\n            // Must be done before minting as the transfer hook will update the user's emissionMultiple.\n            getGobblerData[gobblerId].emissionMultiple = uint48(burnedMultipleTotal << 1);\n            // Update the user's emission data in one big batch. We add burnedMultipleTotal to their\n            // emission multiple (not burnedMultipleTotal * 2) to account for the standard gobblers that\n            // were burned and hence should have their multiples subtracted from the user's total multiple.\n            getEmissionDataForUser[msg.sender].lastBalance = uint128(goopBalance(msg.sender));\n            getEmissionDataForUser[msg.sender].lastTimestamp = uint64(block.timestamp);\n            getEmissionDataForUser[msg.sender].emissionMultiple += uint64(burnedMultipleTotal);\n            // Start a new auction, 30 days after the previous start, and update the current leader id.\n            // The new start price is max of 100 and cost * 2. Shift left by 1 is like multiplication by 2.\n            leaderGobblerAuctionData.gobblerId = uint16(gobblerId) + 1;\n            leaderGobblerAuctionData.startTimestamp += 30 days;\n            leaderGobblerAuctionData.startPrice = uint120(cost < 50 ? 100 : cost << 1);\n            // If gobblerIds has 1,000 elements this should cost around ~270,000 gas.\n            emit LeaderGobblerMinted(msg.sender, gobblerId, gobblerIds);\n            _mint(msg.sender, gobblerId, \"\");\n        }\n    }\n    /// @notice Calculate the leader gobbler price in terms of gobblers, according to linear decay function.\n    /// @dev Reverts due to underflow if the auction has not yet begun. This is intended behavior and helps save gas.\n    function leaderGobblerPrice() public view returns (uint256) {\n        // Cannot be unchecked, we want this to revert if the auction has not started yet.\n        uint256 daysSinceStart = (block.timestamp - leaderGobblerAuctionData.startTimestamp) / 1 days;\n        // If 30 or more days have passed, leader gobbler is free.\n        if (daysSinceStart >= 30) return 0;\n        unchecked {\n            // If we're less than 30 days into the auction, the price simply decays linearly until the 30th day.\n            return (leaderGobblerAuctionData.startPrice * (30 - daysSinceStart)) / 30;\n        }\n    }\n    /*//////////////////////////////////////////////////////////////\n                                VRF LOGIC\n    //////////////////////////////////////////////////////////////*/\n    /// @notice Get the random seed for revealing gobblers.\n    function getRandomSeed() external returns (bytes32) {\n        uint256 nextRevealTimestamp = gobblerRevealsData.nextRevealTimestamp;\n        // A new random seed cannot be requested before the next reveal timestamp.\n        if (block.timestamp < nextRevealTimestamp) revert Unauthorized();\n        // A random seed can only be requested when all gobblers from previous seed have been assigned.\n        // This prevents a user from requesting additional randomness in hopes of a more favorable outcome.\n        if (gobblerRevealsData.toBeAssigned != 0) revert Unauthorized();\n        // A new seed cannot be requested while we wait for a new seed.\n        if (gobblerRevealsData.waitingForSeed) revert Unauthorized();\n        unchecked {\n            // We want at most one batch of reveals every 24 hours.\n            gobblerRevealsData.nextRevealTimestamp = uint64(nextRevealTimestamp + 1 days);\n            // Fix number of gobblers to be revealed from seed.\n            gobblerRevealsData.toBeAssigned = uint56(currentNonLeaderId - gobblerRevealsData.lastRevealedId);\n            // Prevent revealing while we wait for the seed.\n            gobblerRevealsData.waitingForSeed = true;\n        }\n        emit RandomnessRequested(msg.sender, gobblerRevealsData.toBeAssigned);\n        // Will revert if we don't have enough LINK to afford the request.\n        return requestRandomness(chainlinkKeyHash, chainlinkFee);\n    }\n    /// @notice Callback from Chainlink VRF. Sets randomSeed.\n    function fulfillRandomness(bytes32, uint256 randomness) internal override {\n        // The unchecked cast to uint64 is equivalent to moduloing the randomness by 2**64.\n        gobblerRevealsData.randomSeed = uint64(randomness); // 64 bits of randomness is plenty.\n        gobblerRevealsData.waitingForSeed = false; // We have the seed now, open up reveals.\n        emit RandomnessFulfilled(randomness);\n    }\n    /*//////////////////////////////////////////////////////////////\n                          GOBBLER REVEAL LOGIC\n    //////////////////////////////////////////////////////////////*/\n    /// @notice Knuth shuffle to progressively reveal gobblers using entropy from random seed.\n    /// @param numGobblers The number of gobblers to reveal.\n    function revealGobblers(uint256 numGobblers) external {\n        uint256 currentRandomSeed = gobblerRevealsData.randomSeed;\n        uint256 currentLastRevealedId = gobblerRevealsData.lastRevealedId;\n        uint256 totalRemainingToBeAssigned = gobblerRevealsData.toBeAssigned;\n        // Can't reveal more gobblers than were available when seed was generated.\n        if (numGobblers > totalRemainingToBeAssigned) revert Unauthorized();\n        // Can't reveal if we're still waiting for a new seed.\n        if (gobblerRevealsData.waitingForSeed) revert Unauthorized();\n        emit GobblersRevealed(msg.sender, numGobblers, currentLastRevealedId);\n        // Implements a Knuth shuffle. If something in\n        // here can overflow we've got bigger problems.\n        unchecked {\n            for (uint256 i = 0; i < numGobblers; i++) {\n                /*//////////////////////////////////////////////////////////////\n                                      DETERMINE RANDOM SWAP\n                //////////////////////////////////////////////////////////////*/\n                // Number of ids that have not been revealed. Subtract 1\n                // because we don't want to include any leaders in the swap.\n                uint256 remainingIds = FIRST_LEADER_GOBBLER_ID - currentLastRevealedId - 1;\n                // Randomly pick distance for swap.\n                uint256 distance = currentRandomSeed % remainingIds;\n                // Current id is consecutive to last reveal.\n                uint256 currentId = ++currentLastRevealedId;\n                // Select swap id, adding distance to next reveal id.\n                uint256 swapId = currentId + distance;\n                /*//////////////////////////////////////////////////////////////\n                                       GET INDICES FOR IDS\n                //////////////////////////////////////////////////////////////*/\n                // Get the index of the swap id.\n                uint48 swapIndex = getGobblerData[swapId].idx == 0\n                    ? uint48(swapId) // Hasn't been shuffled before.\n                    : getGobblerData[swapId].idx; // Shuffled before.\n                // Get the owner of the current id.\n                address currentIdOwner = getGobblerData[currentId].owner;\n                // Get the index of the current id.\n                uint48 currentIndex = getGobblerData[currentId].idx == 0\n                    ? uint48(currentId) // Hasn't been shuffled before.\n                    : getGobblerData[currentId].idx; // Shuffled before.\n                /*//////////////////////////////////////////////////////////////\n                                  SWAP INDICES AND SET MULTIPLE\n                //////////////////////////////////////////////////////////////*/\n                // Determine the current id's new emission multiple.\n                uint256 newCurrentIdMultiple = 9; // For beyond 7963.\n                if (swapIndex <= 3054) newCurrentIdMultiple = 6;\n                else if (swapIndex <= 5672) newCurrentIdMultiple = 7;\n                else if (swapIndex <= 7963) newCurrentIdMultiple = 8;\n                // Swap the index and multiple of the current id.\n                getGobblerData[currentId].idx = swapIndex;\n                getGobblerData[currentId].emissionMultiple = uint48(newCurrentIdMultiple);\n                // Swap the index of the swap id.\n                getGobblerData[swapId].idx = currentIndex;\n                /*//////////////////////////////////////////////////////////////\n                                   UPDATE CURRENT ID MULTIPLE\n                //////////////////////////////////////////////////////////////*/\n                // Update the emission data for the owner of the current id.\n                getEmissionDataForUser[currentIdOwner].lastBalance = uint128(goopBalance(currentIdOwner));\n                getEmissionDataForUser[currentIdOwner].lastTimestamp = uint64(block.timestamp);\n                getEmissionDataForUser[currentIdOwner].emissionMultiple += uint64(newCurrentIdMultiple);\n\n                // Update the random seed to choose a new distance for the next iteration.\n                // It is critical that we cast to uint64 here, as otherwise the random seed\n                // set after calling revealGobblers(1) thrice would differ from the seed set\n                // after calling revealGobblers(3) a single time. This would enable an attacker\n                // to choose from a number of different seeds and use whichever is most favorable.\n                currentRandomSeed = uint64(uint256(keccak256(abi.encodePacked(currentRandomSeed))));\n            }\n\n            // Update relevant reveal state state all at once.\n\n    \n          \n            \n    \n\n          \n          Expand Down\n    \n    \n  \n            gobblerRevealsData.randomSeed = uint64(currentRandomSeed);\n            gobblerRevealsData.lastRevealedId = uint56(currentLastRevealedId);\n            gobblerRevealsData.toBeAssigned = uint56(totalRemainingToBeAssigned - numGobblers);\n        }\n    }\n    /*//////////////////////////////////////////////////////////////\n                                URI LOGIC\n    //////////////////////////////////////////////////////////////*/\n    /// @notice Returns a token's URI if it has been minted.\n    /// @param gobblerId The id of the token to get the URI for.\n    function uri(uint256 gobblerId) public view virtual override returns (string memory) {\n        // Between 0 and lastRevealed are revealed normal gobblers.\n        if (gobblerId <= gobblerRevealsData.lastRevealedId) {\n            // 0 is not a valid id:\n            if (gobblerId == 0) return \"\";\n            return string(abi.encodePacked(BASE_URI, uint256(getGobblerData[gobblerId].idx).toString()));\n        }\n        // Between lastRevealed + 1 and currentNonLeaderId are minted but not revealed.\n        if (gobblerId <= currentNonLeaderId) return UNREVEALED_URI;\n        // Between currentNonLeaderId and FIRST_LEADER_GOBBLER_ID are unminted.\n        if (gobblerId < FIRST_LEADER_GOBBLER_ID) return \"\";\n        // Between FIRST_LEADER_GOBBLER_ID and gobblerId are minted leaders.\n        if (gobblerId < leaderGobblerAuctionData.gobblerId)\n            return string(abi.encodePacked(BASE_URI, gobblerId.toString()));\n        return \"\"; // Unminted leaders and invalid token ids.\n    }\n    /*//////////////////////////////////////////////////////////////\n                            ART FEEDING LOGIC\n    //////////////////////////////////////////////////////////////*/\n    /// @notice Feed a gobbler a work of art.\n    /// @param gobblerId The gobbler to feed the page.\n    /// @param nft The contract of the work of art.\n    /// @param id The id of the work of art.\n    /// @dev NFTs should be ERC1155s, ideally ERC1155Bs.\n    function feedArt(\n        uint256 gobblerId,\n        address nft,\n        uint256 id\n    ) external {\n        // The caller must own the gobbler they're feeding.\n        if (getGobblerData[gobblerId].owner != msg.sender) revert Unauthorized();\n        // In case the NFT is not an 1155B, we prevent eating it twice.\n        if (getGobblerFromFedArt[nft][id] != 0) revert AlreadyEaten(gobblerId, nft, id);\n        // Map the NFT to the gobbler that ate it.\n        getGobblerFromFedArt[nft][id] = gobblerId;\n        emit ArtFeedToGobbler(msg.sender, gobblerId, nft, id);\n        // We're assuming this is an 1155B-like NFT, so we'll only transfer 1.\n        ERC1155(nft).safeTransferFrom(msg.sender, address(this), id, 1, \"\");\n    }\n    /*//////////////////////////////////////////////////////////////\n                             EMISSION LOGIC\n    //////////////////////////////////////////////////////////////*/\n    /// @notice Calculate a user's staked goop balance.\n    /// @param user The user to query balance for.\n    function goopBalance(address user) public view returns (uint256) {\n        // If a user's goop balance is greater than\n        // 2**256 - 1 we've got much bigger problems.\n        unchecked {\n            uint256 emissionMultiple = getEmissionDataForUser[user].emissionMultiple;\n            uint256 lastBalanceWad = getEmissionDataForUser[user].lastBalance;\n            // Stored with 18 decimals, such that if a day and a half elapsed this variable would equal 1.5e18.\n            uint256 daysElapsedWad = ((block.timestamp - getEmissionDataForUser[user].lastTimestamp) * 1e18) / 1 days;\n            uint256 daysElapsedSquaredWad = daysElapsedWad.mulWadDown(daysElapsedWad); // Need to use wad math here.\n            // prettier-ignore\n            return lastBalanceWad + // The last recorded balance.\n                \n            // Don't need to do wad multiplication since we're\n            // multiplying by a plain integer with no decimals.\n            // Shift right by 2 is equivalent to division by 4.\n            ((emissionMultiple * daysElapsedSquaredWad) >> 2) +\n            \n            daysElapsedWad.mulWadDown( // Terms are wads, so must mulWad.\n                // No wad multiplication for emissionMultiple * lastBalance\n                // because emissionMultiple is a plain integer with no decimals.\n                // We multiply the sqrt's radicand by 1e18 because it expects ints.\n                (emissionMultiple * lastBalanceWad * 1e18).sqrt()\n            );\n        }\n    }\n    /// @notice Add goop to your emission balance.\n    /// @param goopAmount The amount of goop to add.\n    function addGoop(uint256 goopAmount) external {\n        // Burn goop being added to gobbler.\n        goop.burnForGobblers(msg.sender, goopAmount);\n        unchecked {\n            // If a user has enough goop to overflow their balance we've got big problems.\n            getEmissionDataForUser[msg.sender].lastBalance = uint128(goopBalance(msg.sender) + goopAmount);\n            getEmissionDataForUser[msg.sender].lastTimestamp = uint64(block.timestamp);\n        }\n        emit GoopAdded(msg.sender, goopAmount);\n    }\n    /// @notice Remove goop from your emission balance.\n    /// @param goopAmount The amount of goop to remove.\n    function removeGoop(uint256 goopAmount) external {\n        // Will revert due to underflow if removed amount is larger than the user's current goop balance.\n        getEmissionDataForUser[msg.sender].lastBalance = uint128(goopBalance(msg.sender) - goopAmount);\n        getEmissionDataForUser[msg.sender].lastTimestamp = uint64(block.timestamp);\n        emit GoopRemoved(msg.sender, goopAmount);\n        goop.mintForGobblers(msg.sender, goopAmount);\n    }\n    /*//////////////////////////////////////////////////////////////\n                          CONVENIENCE FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n    /// @notice Convenience function to get emission emissionMultiple for a gobbler.\n    /// @param gobblerId The gobbler to get emissionMultiple for.\n    function getGobblerEmissionMultiple(uint256 gobblerId) external view returns (uint256) {\n        return getGobblerData[gobblerId].emissionMultiple;\n    }\n    /// @notice Convenience function to get emission emissionMultiple for a user.\n    /// @param user The user to get emissionMultiple for.\n    function getUserEmissionMultiple(address user) external view returns (uint256) {\n        return getEmissionDataForUser[user].emissionMultiple;\n    }\n    /*//////////////////////////////////////////////////////////////\n                             ERC1155B LOGIC\n    //////////////////////////////////////////////////////////////*/\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) public override {\n        require(ids.length == amounts.length, \"LENGTH_MISMATCH\");\n        require(msg.sender == from || isApprovedForAll[from][msg.sender], \"NOT_AUTHORIZED\");\n        // Storing these outside the loop saves ~15 gas per iteration.\n        uint256 id;\n        uint256 amount;\n        unchecked {\n            uint64 emissionsMultipleTotal; // Will use to set each user's multiple.\n            for (uint256 i = 0; i < ids.length; i++) {\n                id = ids[i];\n                amount = amounts[i];\n                // Can only transfer from the owner.\n                require(from == getGobblerData[id].owner, \"WRONG_FROM\");\n                // Can only transfer 1 with ERC1155B.\n                require(amount == 1, \"INVALID_AMOUNT\");\n                getGobblerData[id].owner = to;\n                emissionsMultipleTotal += getGobblerData[id].emissionMultiple;\n            }\n            // Decrease the from user's emissionMultiple by emissionsMultipleTotal.\n            getEmissionDataForUser[from].lastBalance = uint128(goopBalance(from));\n            getEmissionDataForUser[from].lastTimestamp = uint64(block.timestamp);\n            getEmissionDataForUser[from].emissionMultiple -= emissionsMultipleTotal;\n            // Increase the to user's emissionMultiple by emissionsMultipleTotal.\n            getEmissionDataForUser[to].lastBalance = uint128(goopBalance(to));\n            getEmissionDataForUser[to].lastTimestamp = uint64(block.timestamp);\n            getEmissionDataForUser[to].emissionMultiple += emissionsMultipleTotal;\n        }\n        emit TransferBatch(msg.sender, from, to, ids, amounts);\n        if (to.code.length != 0) {\n            require(\n                ERC1155TokenReceiver(to).onERC1155BatchReceived(msg.sender, from, ids, amounts, data) ==\n                    ERC1155TokenReceiver.onERC1155BatchReceived.selector,\n                \"UNSAFE_RECIPIENT\"\n            );\n        } else require(to != address(0), \"INVALID_RECIPIENT\");\n    }\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) public override {\n        require(msg.sender == from || isApprovedForAll[from][msg.sender], \"NOT_AUTHORIZED\");\n        require(from == getGobblerData[id].owner, \"WRONG_FROM\"); // Can only transfer from the owner.\n        // Can only transfer 1 with ERC1155B.\n        require(amount == 1, \"INVALID_AMOUNT\");\n        getGobblerData[id].owner = to;\n        unchecked {\n            // Get the transferred gobbler's emission multiple. Can be zero before reveal.\n            uint64 emissionMultiple = getGobblerData[id].emissionMultiple;\n            // Decrease the from user's emissionMultiple by the gobbler's emissionMultiple.\n            getEmissionDataForUser[from].lastBalance = uint128(goopBalance(from));\n            getEmissionDataForUser[from].lastTimestamp = uint64(block.timestamp);\n            getEmissionDataForUser[from].emissionMultiple -= emissionMultiple;\n            // Increase the to user's emissionMultiple by the gobbler's emissionMultiple.\n            getEmissionDataForUser[to].lastBalance = uint128(goopBalance(to));\n            getEmissionDataForUser[to].lastTimestamp = uint64(block.timestamp);\n            getEmissionDataForUser[to].emissionMultiple += emissionMultiple;\n        }\n        emit TransferSingle(msg.sender, from, to, id, amount);\n        if (to.code.length != 0) {\n            require(\n                ERC1155TokenReceiver(to).onERC1155Received(msg.sender, from, id, amount, data) ==\n                    ERC1155TokenReceiver.onERC1155Received.selector,\n                \"UNSAFE_RECIPIENT\"\n            );\n        } else require(to != address(0), \"INVALID_RECIPIENT\");\n    }\n}"
    },
    {
        "tag": "bad randomness",
        "url": "https://github.com/artgobblers/art-gobblers/commit/9a7075240c196def482f246b667b5922f7dbb794",
        "file": "src/ArtGobblers.sol",
        "before": "// SPDX-License-Identifier: Unlicense\npragma solidity >=0.8.0;\nimport {FixedPointMathLib} from \"solmate/utils/FixedPointMathLib.sol\";\nimport {ERC1155, ERC1155TokenReceiver} from \"solmate/tokens/ERC1155.sol\";\nimport {VRFConsumerBase} from \"chainlink/v0.8/VRFConsumerBase.sol\";\nimport {VRGDA} from \"./utils/VRGDA.sol\";\nimport {LibString} from \"./utils/LibString.sol\";\nimport {LogisticVRGDA} from \"./utils/LogisticVRGDA.sol\";\nimport {MerkleProofLib} from \"./utils/MerkleProofLib.sol\";\nimport {GobblersERC1155B} from \"./utils/GobblersERC1155B.sol\";\nimport {Goop} from \"./Goop.sol\";\n/// @title Art Gobblers NFT\n/// @notice Art Gobblers scan the cosmos in search of art producing life.\ncontract ArtGobblers is GobblersERC1155B, LogisticVRGDA, VRFConsumerBase, ERC1155TokenReceiver {\n    using LibString for uint256;\n    using FixedPointMathLib for uint256;\n    /*//////////////////////////////////////////////////////////////\n                                ADDRESSES\n    //////////////////////////////////////////////////////////////*/\n    Goop public immutable goop;\n    address public immutable team;\n    /*//////////////////////////////////////////////////////////////\n                            SUPPLY CONSTANTS\n    //////////////////////////////////////////////////////////////*/\n    /// @notice Maximum number of mintable gobblers.\n    uint256 public constant MAX_SUPPLY = 10000;\n    /// @notice Maximum amount of gobblers mintable via mintlist.\n    uint256 public constant MINTLIST_SUPPLY = 2000;\n    /// @notice Maximum amount of mintable leader gobblers.\n    uint256 public constant LEADER_SUPPLY = 10;\n    /// @notice Maximum amount of gobblers that will go to the team.\n    uint256 public constant TEAM_SUPPLY = 799;\n    /// @notice Maximum amount of gobblers that can be minted via VRGDA.\n    uint256 public constant MAX_MINTABLE = MAX_SUPPLY - MINTLIST_SUPPLY - LEADER_SUPPLY - TEAM_SUPPLY;\n    /*//////////////////////////////////////////////////////////////\n                                  URIS\n    //////////////////////////////////////////////////////////////*/\n    /// @notice Base URI for minted gobblers.\n    string public BASE_URI;\n    /// @notice URI for gobblers that have yet to be revealed.\n    string public UNREVEALED_URI;\n    /*//////////////////////////////////////////////////////////////\n                              VRF CONSTANTS\n    //////////////////////////////////////////////////////////////*/\n    bytes32 internal immutable chainlinkKeyHash;\n    uint256 internal immutable chainlinkFee;\n    /*//////////////////////////////////////////////////////////////\n                             MINTLIST STATE\n    //////////////////////////////////////////////////////////////*/\n    /// @notice Merkle root of mint mintlist.\n    bytes32 public immutable merkleRoot;\n    /// @notice Mapping to keep track of which addresses have claimed from mintlist.\n    mapping(address => bool) public hasClaimedMintlistGobbler;\n    /*//////////////////////////////////////////////////////////////\n                            VRGDA INPUT STATE\n    //////////////////////////////////////////////////////////////*/\n    /// @notice Timestamp for the start of minting.\n    uint256 public immutable mintStart;\n    /// @notice Number of gobblers minted from goop.\n    uint128 public numMintedFromGoop;\n    /*//////////////////////////////////////////////////////////////\n                         STANDARD GOBBLER STATE\n    //////////////////////////////////////////////////////////////*/\n    /// @notice Id of the most recently minted non leader gobbler.\n    /// @dev Will be 0 if no non leader gobblers have been minted yet.\n    uint128 public currentNonLeaderId;\n    /// @notice The number of gobblers minted to the team.\n    uint256 public numMintedForTeam;\n    /*//////////////////////////////////////////////////////////////\n                      LEADER GOBBLER AUCTION STATE\n    //////////////////////////////////////////////////////////////*/\n    /// @notice The last LEADER_SUPPLY ids are reserved for leader gobblers.\n    uint256 internal constant FIRST_LEADER_GOBBLER_ID = MAX_SUPPLY - LEADER_SUPPLY + 1;\n    /// @notice Struct holding data required for leader gobbler auctions.\n    struct LeaderGobblerAuctionData {\n        // Start price of current leader gobbler auction.\n        uint120 startPrice;\n        // Start timestamp of current leader gobbler auction.\n        uint120 startTimestamp;\n        // Id of the current leader gobbler being\n        // auctioned. 16 bits has a max value of\n        // ~60k which is within our limits here.\n        uint16 gobblerId;\n    }\n    /// @notice Data about the current leader gobbler auction.\n    LeaderGobblerAuctionData public leaderGobblerAuctionData;\n    /*//////////////////////////////////////////////////////////////\n                          GOBBLER REVEAL STATE\n    //////////////////////////////////////////////////////////////*/\n    /// @notice Struct holding data required for gobbler reveals.\n    struct GobblerRevealsData {\n        // Last random seed obtained from VRF.\n        uint64 randomSeed;\n        // Next reveal cannot happen before this timestamp.\n        uint64 nextRevealTimestamp;\n        // Id of latest gobbler which has been revealed so far.\n        uint56 lastRevealedId;\n        // Remaining gobblers to be assigned from the current seed.\n        uint56 toBeAssigned;\n        // Whether we are waiting to receive a seed from Chainlink.\n        bool waitingForSeed;\n    }\n    /// @notice Data about the current state of gobbler reveals.\n    GobblerRevealsData public gobblerRevealsData;\n    /*//////////////////////////////////////////////////////////////\n                             EMISSION STATE\n    //////////////////////////////////////////////////////////////*/\n    /// @notice Struct data info required for goop emission reward calculations.\n    struct EmissionData {\n        // The sum of the multiples of all gobblers the user holds.\n        uint64 emissionMultiple;\n        // Balance at time of last deposit or withdrawal.\n        uint128 lastBalance;\n        // Timestamp of last deposit or withdrawal.\n        uint64 lastTimestamp;\n    }\n    /// @notice Maps user addresses to their emission data.\n    mapping(address => EmissionData) public getEmissionDataForUser;\n    /*//////////////////////////////////////////////////////////////\n                            ART FEEDING STATE\n    //////////////////////////////////////////////////////////////*/\n    /// @notice Mapping from NFT contracts to their ids to gobbler ids they were fed to.\n    mapping(address => mapping(uint256 => uint256)) public getGobblerFromFedArt;\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n    event GoopAdded(address indexed user, uint256 goopAdded);\n    event GoopRemoved(address indexed user, uint256 goopAdded);\n    event GobblerClaimed(address indexed user, uint256 indexed gobblerId);\n    event GobblerPurchased(address indexed user, uint256 indexed gobblerId, uint256 price);\n    event GobblerMintedForTeam(address indexed user, uint256 indexed gobblerId);\n    event LeaderGobblerMinted(address indexed user, uint256 indexed gobblerId, uint256[] burnedGobblerIds);\n    event RandomnessRequested(address indexed user, uint256 toBeAssigned);\n    event RandomnessFulfilled(uint256 randomness);\n    event GobblersRevealed(address indexed user, uint256 numGobblers, uint256 lastRevealedId);\n    event ArtFeedToGobbler(address indexed user, uint256 indexed gobblerId, address indexed nft, uint256 id);\n    /*//////////////////////////////////////////////////////////////\n                                 ERRORS\n    //////////////////////////////////////////////////////////////*/\n    error Unauthorized();\n    error NoRemainingLeaderGobblers();\n    error CannotBurnLeader(uint256 gobblerId);\n    error AlreadyEaten(uint256 gobblerId, address nft, uint256 id);\n    error PriceExceededMax(uint256 currentPrice, uint256 maxPrice);\n    error IncorrectGobblerAmount(uint256 provided, uint256 needed);\n    /*//////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n    constructor(\n        // Mint config:\n        bytes32 _merkleRoot,\n        uint256 _mintStart,\n        // Addresses:\n        Goop _goop,\n        address _team,\n        // Chainlink:\n        address _vrfCoordinator,\n        address _linkToken,\n        bytes32 _chainlinkKeyHash,\n        uint256 _chainlinkFee,\n        // URIs:\n        string memory _baseUri,\n        string memory _unrevealedUri\n    )\n        VRFConsumerBase(_vrfCoordinator, _linkToken)\n        VRGDA(\n            6.9e18, // Initial price.\n            0.31e18 // Per period price decrease.\n        )\n        LogisticVRGDA(\n            // Max mintable gobblers.\n            int256(MAX_MINTABLE * 1e18),\n            0.014e18 // Time scale.\n        )\n    {\n        mintStart = _mintStart;\n        merkleRoot = _merkleRoot;\n        goop = _goop;\n        team = _team;\n        chainlinkKeyHash = _chainlinkKeyHash;\n        chainlinkFee = _chainlinkFee;\n        BASE_URI = _baseUri;\n        UNREVEALED_URI = _unrevealedUri;\n        // Starting price for leader gobblers is 100 gobblers.\n        leaderGobblerAuctionData.startPrice = 100;\n        // First leader gobbler auction starts 30 days after the mint starts.\n        leaderGobblerAuctionData.startTimestamp = uint120(_mintStart + 30 days);\n        // Current leader id starts at beginning of leader id space.\n        leaderGobblerAuctionData.gobblerId = uint16(FIRST_LEADER_GOBBLER_ID);\n        // Reveal for initial mint must wait 24 hours\n        gobblerRevealsData.nextRevealTimestamp = uint64(_mintStart + 1 days);\n    }\n    /*//////////////////////////////////////////////////////////////\n                          MINTLIST CLAIM LOGIC\n    //////////////////////////////////////////////////////////////*/\n    /// @notice Claim from mintlist, using a merkle proof.\n    /// @param proof Merkle proof to verify the sender is mintlisted.\n    /// @return gobblerId The id of the gobbler that was claimed.\n    function claimGobbler(bytes32[] calldata proof) external returns (uint256 gobblerId) {\n        // If minting has not yet begun or the user has already claimed, revert.\n        if (mintStart > block.timestamp || hasClaimedMintlistGobbler[msg.sender]) revert Unauthorized();\n        // If the user's proof is invalid, revert.\n        if (!MerkleProofLib.verify(proof, merkleRoot, keccak256(abi.encodePacked(msg.sender)))) revert Unauthorized();\n        hasClaimedMintlistGobbler[msg.sender] = true; // Before mint to prevent reentrancy.\n        unchecked {\n            emit GobblerClaimed(msg.sender, gobblerId = ++currentNonLeaderId);\n            _mint(msg.sender, gobblerId, \"\");\n        }\n    }\n    /*//////////////////////////////////////////////////////////////\n                              MINTING LOGIC\n    //////////////////////////////////////////////////////////////*/\n    /// @notice Mint a gobbler with goop, burning the cost.\n    /// @param maxPrice Maximum price to pay to mint the gobbler.\n    /// @return gobblerId The id of the gobbler that was minted.\n    function mintFromGoop(uint256 maxPrice) external returns (uint256 gobblerId) {\n        // No need to check mint cap, gobblerPrice()\n        // will revert due to overflow if we reach it.\n        // It will also revert prior to the mint start.\n        uint256 currentPrice = gobblerPrice();\n        // If the current price is above the user's specified max, revert.\n        if (currentPrice > maxPrice) revert PriceExceededMax(currentPrice, maxPrice);\n        goop.burnForGobblers(msg.sender, currentPrice);\n        unchecked {\n            ++numMintedFromGoop; // Before mint to prevent reentrancy.\n            emit GobblerPurchased(msg.sender, gobblerId = ++currentNonLeaderId, currentPrice);\n            _mint(msg.sender, gobblerId, \"\");\n        }\n    }\n    /// @notice Gobbler pricing in terms of goop.\n    /// @dev Will revert if called before minting starts\n    /// or after all gobblers have been minted via VRGDA.\n    function gobblerPrice() public view returns (uint256) {\n        // We need checked math here to cause overflow\n        // before minting has begun, preventing mints.\n        uint256 timeSinceStart = block.timestamp - mintStart;\n        return getPrice(timeSinceStart, numMintedFromGoop);\n    }\n    /*//////////////////////////////////////////////////////////////\n                           TEAM MINTING LOGIC\n    //////////////////////////////////////////////////////////////*/\n    /// @notice Mint a gobbler for the team.\n    /// @dev Team cannot never mint more than 10% of\n    /// the circulating supply of auctioned gobblers.\n    /// @return gobblerId The id of the gobbler that was minted.\n    function mintForTeam() external returns (uint256 gobblerId) {\n        unchecked {\n            // Can mint up to 10% of the current auctioned gobblers.\n            uint256 currentMintLimit = numMintedFromGoop / 10;\n            // Check that we wouldn't go over the limit after minting.\n            if (++numMintedForTeam > currentMintLimit) revert Unauthorized();\n            emit GobblerMintedForTeam(msg.sender, gobblerId = ++currentNonLeaderId);\n            _mint(address(team), gobblerId, \"\");\n        }\n    }\n    /*//////////////////////////////////////////////////////////////\n                      LEADER GOBBLER AUCTION LOGIC\n    //////////////////////////////////////////////////////////////*/\n    /// @notice Mint a leader gobbler by burning multiple standard gobblers.\n    /// @param gobblerIds The ids of the standard gobblers to burn.\n    /// @return gobblerId The id of the leader gobbler that was minted.\n    function mintLeaderGobbler(uint256[] calldata gobblerIds) external returns (uint256 gobblerId) {\n        gobblerId = leaderGobblerAuctionData.gobblerId; // Assign id.\n        // If the current id is greater than the max supply, there are no remaining leaders.\n        if (gobblerId > MAX_SUPPLY) revert NoRemainingLeaderGobblers();\n        // This will revert if the auction hasn't started yet, no need to check here as well.\n        uint256 cost = leaderGobblerPrice();\n        if (gobblerIds.length != cost) revert IncorrectGobblerAmount(gobblerIds.length, cost);\n        // Overflow in here should not occur, as most math is on emission multiples, which are inherently small.\n        unchecked {\n            uint256 burnedMultipleTotal; // The leader's emissionMultiple will be 2x the sum of the gobblers burned.\n            /*//////////////////////////////////////////////////////////////\n                                    BATCH BURN LOGIC\n            //////////////////////////////////////////////////////////////*/\n            // Generate an amounts array locally to use in the event below.\n            uint256[] memory amounts = new uint256[](gobblerIds.length);\n            uint256 id; // Storing outside the loop saves ~7 gas per iteration.\n            for (uint256 i = 0; i < gobblerIds.length; ++i) {\n                id = gobblerIds[i];\n                if (id >= FIRST_LEADER_GOBBLER_ID) revert CannotBurnLeader(id);\n                require(getGobblerData[id].owner == msg.sender, \"WRONG_FROM\");\n                burnedMultipleTotal += getGobblerData[id].emissionMultiple;\n                getGobblerData[id].owner = address(0);\n                amounts[i] = 1;\n            }\n            emit TransferBatch(msg.sender, msg.sender, address(0), gobblerIds, amounts);\n            /*//////////////////////////////////////////////////////////////\n                                  LEADER MINTING LOGIC\n            //////////////////////////////////////////////////////////////*/\n            // The shift right by 1 is equivalent to multiplication by 2, used to make\n            // the leader's emissionMultiple 2x the sum of the multiples of the gobblers burned.\n            // Must be done before minting as the transfer hook will update the user's emissionMultiple.\n            getGobblerData[gobblerId].emissionMultiple = uint48(burnedMultipleTotal << 1);\n            // Update the user's emission data in one big batch. We add burnedMultipleTotal to their\n            // emission multiple (not burnedMultipleTotal * 2) to account for the standard gobblers that\n            // were burned and hence should have their multiples subtracted from the user's total multiple.\n            getEmissionDataForUser[msg.sender].lastBalance = uint128(goopBalance(msg.sender));\n            getEmissionDataForUser[msg.sender].lastTimestamp = uint64(block.timestamp);\n            getEmissionDataForUser[msg.sender].emissionMultiple += uint64(burnedMultipleTotal);\n            // Start a new auction, 30 days after the previous start, and update the current leader id.\n            // The new start price is max of 100 and cost * 2. Shift left by 1 is like multiplication by 2.\n            leaderGobblerAuctionData.gobblerId = uint16(gobblerId) + 1;\n            leaderGobblerAuctionData.startTimestamp += 30 days;\n            leaderGobblerAuctionData.startPrice = uint120(cost < 50 ? 100 : cost << 1);\n            // If gobblerIds has 1,000 elements this should cost around ~270,000 gas.\n            emit LeaderGobblerMinted(msg.sender, gobblerId, gobblerIds);\n            _mint(msg.sender, gobblerId, \"\");\n        }\n    }\n    /// @notice Calculate the leader gobbler price in terms of gobblers, according to linear decay function.\n    /// @dev Reverts due to underflow if the auction has not yet begun. This is intended behavior and helps save gas.\n    function leaderGobblerPrice() public view returns (uint256) {\n        // Cannot be unchecked, we want this to revert if the auction has not started yet.\n        uint256 daysSinceStart = (block.timestamp - leaderGobblerAuctionData.startTimestamp) / 1 days;\n        // If 30 or more days have passed, leader gobbler is free.\n        if (daysSinceStart >= 30) return 0;\n        unchecked {\n            // If we're less than 30 days into the auction, the price simply decays linearly until the 30th day.\n            return (leaderGobblerAuctionData.startPrice * (30 - daysSinceStart)) / 30;\n        }\n    }\n    /*//////////////////////////////////////////////////////////////\n                                VRF LOGIC\n    //////////////////////////////////////////////////////////////*/\n    /// @notice Get the random seed for revealing gobblers.\n    function getRandomSeed() external returns (bytes32) {\n        uint256 nextRevealTimestamp = gobblerRevealsData.nextRevealTimestamp;\n        // A new random seed cannot be requested before the next reveal timestamp.\n        if (block.timestamp < nextRevealTimestamp) revert Unauthorized();\n        // A random seed can only be requested when all gobblers from previous seed have been assigned.\n        // This prevents a user from requesting additional randomness in hopes of a more favorable outcome.\n        if (gobblerRevealsData.toBeAssigned != 0) revert Unauthorized();\n        // A new seed cannot be requested while we wait for a new seed.\n        if (gobblerRevealsData.waitingForSeed) revert Unauthorized();\n        unchecked {\n            // We want at most one batch of reveals every 24 hours.\n            gobblerRevealsData.nextRevealTimestamp = uint64(nextRevealTimestamp + 1 days);\n            // Fix number of gobblers to be revealed from seed.\n            gobblerRevealsData.toBeAssigned = uint56(currentNonLeaderId - gobblerRevealsData.lastRevealedId);\n            // Prevent revealing while we wait for the seed.\n            gobblerRevealsData.waitingForSeed = true;\n        }\n        emit RandomnessRequested(msg.sender, gobblerRevealsData.toBeAssigned);\n        // Will revert if we don't have enough LINK to afford the request.\n        return requestRandomness(chainlinkKeyHash, chainlinkFee);\n    }\n    /// @notice Callback from Chainlink VRF. Sets randomSeed.\n    function fulfillRandomness(bytes32, uint256 randomness) internal override {\n        // The unchecked cast to uint64 is equivalent to moduloing the randomness by 2**64.\n        gobblerRevealsData.randomSeed = uint64(randomness); // 64 bits of randomness is plenty.\n        gobblerRevealsData.waitingForSeed = false; // We have the seed now, open up reveals.\n        emit RandomnessFulfilled(randomness);\n    }\n    /*//////////////////////////////////////////////////////////////\n                          GOBBLER REVEAL LOGIC\n    //////////////////////////////////////////////////////////////*/\n    /// @notice Knuth shuffle to progressively reveal gobblers using entropy from random seed.\n    /// @param numGobblers The number of gobblers to reveal.\n    function revealGobblers(uint256 numGobblers) external {\n        uint256 currentRandomSeed = gobblerRevealsData.randomSeed;\n        uint256 currentLastRevealedId = gobblerRevealsData.lastRevealedId;\n        uint256 totalRemainingToBeAssigned = gobblerRevealsData.toBeAssigned;\n        // Can't reveal more gobblers than were available when seed was generated.\n        if (numGobblers > totalRemainingToBeAssigned) revert Unauthorized();\n        // Can't reveal if we're still waiting for a new seed.\n        if (gobblerRevealsData.waitingForSeed) revert Unauthorized();\n        emit GobblersRevealed(msg.sender, numGobblers, currentLastRevealedId);\n        // Implements a Knuth shuffle. If something in\n        // here can overflow we've got bigger problems.\n        unchecked {\n            for (uint256 i = 0; i < numGobblers; i++) {\n                /*//////////////////////////////////////////////////////////////\n                                      DETERMINE RANDOM SWAP\n                //////////////////////////////////////////////////////////////*/\n                // Number of ids that have not been revealed. Subtract 1\n                // because we don't want to include any leaders in the swap.\n                uint256 remainingIds = FIRST_LEADER_GOBBLER_ID - currentLastRevealedId - 1;\n                // Randomly pick distance for swap.\n                uint256 distance = currentRandomSeed % remainingIds;\n                // Current id is consecutive to last reveal.\n                uint256 currentId = ++currentLastRevealedId;\n                // Select swap id, adding distance to next reveal id.\n                uint256 swapId = currentId + distance;\n                /*//////////////////////////////////////////////////////////////\n                                       GET INDICES FOR IDS\n                //////////////////////////////////////////////////////////////*/\n                // Get the index of the swap id.\n                uint48 swapIndex = getGobblerData[swapId].idx == 0\n                    ? uint48(swapId) // Hasn't been shuffled before.\n                    : getGobblerData[swapId].idx; // Shuffled before.\n                // Get the owner of the current id.\n                address currentIdOwner = getGobblerData[currentId].owner;\n                // Get the index of the current id.\n                uint48 currentIndex = getGobblerData[currentId].idx == 0\n                    ? uint48(currentId) // Hasn't been shuffled before.\n                    : getGobblerData[currentId].idx; // Shuffled before.\n                /*//////////////////////////////////////////////////////////////\n                                  SWAP INDICES AND SET MULTIPLE\n                //////////////////////////////////////////////////////////////*/\n                // Determine the current id's new emission multiple.\n                uint256 newCurrentIdMultiple = 9; // For beyond 7963.\n                if (swapIndex <= 3054) newCurrentIdMultiple = 6;\n                else if (swapIndex <= 5672) newCurrentIdMultiple = 7;\n                else if (swapIndex <= 7963) newCurrentIdMultiple = 8;\n                // Swap the index and multiple of the current id.\n                getGobblerData[currentId].idx = swapIndex;\n                getGobblerData[currentId].emissionMultiple = uint48(newCurrentIdMultiple);\n                // Swap the index of the swap id.\n                getGobblerData[swapId].idx = currentIndex;\n                /*//////////////////////////////////////////////////////////////\n                                   UPDATE CURRENT ID MULTIPLE\n                //////////////////////////////////////////////////////////////*/\n                // Update the emission data for the owner of the current id.\n                getEmissionDataForUser[currentIdOwner].lastBalance = uint128(goopBalance(currentIdOwner));\n                getEmissionDataForUser[currentIdOwner].lastTimestamp = uint64(block.timestamp);\n                getEmissionDataForUser[currentIdOwner].emissionMultiple += uint64(newCurrentIdMultiple);\n\n                // Update the random seed to choose a new distance for the next iteration.\n                currentRandomSeed = uint256(keccak256(abi.encodePacked(currentRandomSeed)));\n            }\n\n            // Update relevant reveal state state all at once.\n\n    \n          \n            \n    \n\n          \n          Expand Down\n    \n    \n  \n            gobblerRevealsData.randomSeed = uint64(currentRandomSeed);\n            gobblerRevealsData.lastRevealedId = uint56(currentLastRevealedId);\n            gobblerRevealsData.toBeAssigned = uint56(totalRemainingToBeAssigned - numGobblers);\n        }\n    }\n    /*//////////////////////////////////////////////////////////////\n                                URI LOGIC\n    //////////////////////////////////////////////////////////////*/\n    /// @notice Returns a token's URI if it has been minted.\n    /// @param gobblerId The id of the token to get the URI for.\n    function uri(uint256 gobblerId) public view virtual override returns (string memory) {\n        // Between 0 and lastRevealed are revealed normal gobblers.\n        if (gobblerId <= gobblerRevealsData.lastRevealedId) {\n            // 0 is not a valid id:\n            if (gobblerId == 0) return \"\";\n            return string(abi.encodePacked(BASE_URI, uint256(getGobblerData[gobblerId].idx).toString()));\n        }\n        // Between lastRevealed + 1 and currentNonLeaderId are minted but not revealed.\n        if (gobblerId <= currentNonLeaderId) return UNREVEALED_URI;\n        // Between currentNonLeaderId and FIRST_LEADER_GOBBLER_ID are unminted.\n        if (gobblerId < FIRST_LEADER_GOBBLER_ID) return \"\";\n        // Between FIRST_LEADER_GOBBLER_ID and gobblerId are minted leaders.\n        if (gobblerId < leaderGobblerAuctionData.gobblerId)\n            return string(abi.encodePacked(BASE_URI, gobblerId.toString()));\n        return \"\"; // Unminted leaders and invalid token ids.\n    }\n    /*//////////////////////////////////////////////////////////////\n                            ART FEEDING LOGIC\n    //////////////////////////////////////////////////////////////*/\n    /// @notice Feed a gobbler a work of art.\n    /// @param gobblerId The gobbler to feed the page.\n    /// @param nft The contract of the work of art.\n    /// @param id The id of the work of art.\n    /// @dev NFTs should be ERC1155s, ideally ERC1155Bs.\n    function feedArt(\n        uint256 gobblerId,\n        address nft,\n        uint256 id\n    ) external {\n        // The caller must own the gobbler they're feeding.\n        if (getGobblerData[gobblerId].owner != msg.sender) revert Unauthorized();\n        // In case the NFT is not an 1155B, we prevent eating it twice.\n        if (getGobblerFromFedArt[nft][id] != 0) revert AlreadyEaten(gobblerId, nft, id);\n        // Map the NFT to the gobbler that ate it.\n        getGobblerFromFedArt[nft][id] = gobblerId;\n        emit ArtFeedToGobbler(msg.sender, gobblerId, nft, id);\n        // We're assuming this is an 1155B-like NFT, so we'll only transfer 1.\n        ERC1155(nft).safeTransferFrom(msg.sender, address(this), id, 1, \"\");\n    }\n    /*//////////////////////////////////////////////////////////////\n                             EMISSION LOGIC\n    //////////////////////////////////////////////////////////////*/\n    /// @notice Calculate a user's staked goop balance.\n    /// @param user The user to query balance for.\n    function goopBalance(address user) public view returns (uint256) {\n        // If a user's goop balance is greater than\n        // 2**256 - 1 we've got much bigger problems.\n        unchecked {\n            uint256 emissionMultiple = getEmissionDataForUser[user].emissionMultiple;\n            uint256 lastBalanceWad = getEmissionDataForUser[user].lastBalance;\n            // Stored with 18 decimals, such that if a day and a half elapsed this variable would equal 1.5e18.\n            uint256 daysElapsedWad = ((block.timestamp - getEmissionDataForUser[user].lastTimestamp) * 1e18) / 1 days;\n            uint256 daysElapsedSquaredWad = daysElapsedWad.mulWadDown(daysElapsedWad); // Need to use wad math here.\n            // prettier-ignore\n            return lastBalanceWad + // The last recorded balance.\n                \n            // Don't need to do wad multiplication since we're\n            // multiplying by a plain integer with no decimals.\n            // Shift right by 2 is equivalent to division by 4.\n            ((emissionMultiple * daysElapsedSquaredWad) >> 2) +\n            \n            daysElapsedWad.mulWadDown( // Terms are wads, so must mulWad.\n                // No wad multiplication for emissionMultiple * lastBalance\n                // because emissionMultiple is a plain integer with no decimals.\n                // We multiply the sqrt's radicand by 1e18 because it expects ints.\n                (emissionMultiple * lastBalanceWad * 1e18).sqrt()\n            );\n        }\n    }\n    /// @notice Add goop to your emission balance.\n    /// @param goopAmount The amount of goop to add.\n    function addGoop(uint256 goopAmount) external {\n        // Burn goop being added to gobbler.\n        goop.burnForGobblers(msg.sender, goopAmount);\n        unchecked {\n            // If a user has enough goop to overflow their balance we've got big problems.\n            getEmissionDataForUser[msg.sender].lastBalance = uint128(goopBalance(msg.sender) + goopAmount);\n            getEmissionDataForUser[msg.sender].lastTimestamp = uint64(block.timestamp);\n        }\n        emit GoopAdded(msg.sender, goopAmount);\n    }\n    /// @notice Remove goop from your emission balance.\n    /// @param goopAmount The amount of goop to remove.\n    function removeGoop(uint256 goopAmount) external {\n        // Will revert due to underflow if removed amount is larger than the user's current goop balance.\n        getEmissionDataForUser[msg.sender].lastBalance = uint128(goopBalance(msg.sender) - goopAmount);\n        getEmissionDataForUser[msg.sender].lastTimestamp = uint64(block.timestamp);\n        emit GoopRemoved(msg.sender, goopAmount);\n        goop.mintForGobblers(msg.sender, goopAmount);\n    }\n    /*//////////////////////////////////////////////////////////////\n                          CONVENIENCE FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n    /// @notice Convenience function to get emission emissionMultiple for a gobbler.\n    /// @param gobblerId The gobbler to get emissionMultiple for.\n    function getGobblerEmissionMultiple(uint256 gobblerId) external view returns (uint256) {\n        return getGobblerData[gobblerId].emissionMultiple;\n    }\n    /// @notice Convenience function to get emission emissionMultiple for a user.\n    /// @param user The user to get emissionMultiple for.\n    function getUserEmissionMultiple(address user) external view returns (uint256) {\n        return getEmissionDataForUser[user].emissionMultiple;\n    }\n    /*//////////////////////////////////////////////////////////////\n                             ERC1155B LOGIC\n    //////////////////////////////////////////////////////////////*/\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) public override {\n        require(ids.length == amounts.length, \"LENGTH_MISMATCH\");\n        require(msg.sender == from || isApprovedForAll[from][msg.sender], \"NOT_AUTHORIZED\");\n        // Storing these outside the loop saves ~15 gas per iteration.\n        uint256 id;\n        uint256 amount;\n        unchecked {\n            uint64 emissionsMultipleTotal; // Will use to set each user's multiple.\n            for (uint256 i = 0; i < ids.length; i++) {\n                id = ids[i];\n                amount = amounts[i];\n                // Can only transfer from the owner.\n                require(from == getGobblerData[id].owner, \"WRONG_FROM\");\n                // Can only transfer 1 with ERC1155B.\n                require(amount == 1, \"INVALID_AMOUNT\");\n                getGobblerData[id].owner = to;\n                emissionsMultipleTotal += getGobblerData[id].emissionMultiple;\n            }\n            // Decrease the from user's emissionMultiple by emissionsMultipleTotal.\n            getEmissionDataForUser[from].lastBalance = uint128(goopBalance(from));\n            getEmissionDataForUser[from].lastTimestamp = uint64(block.timestamp);\n            getEmissionDataForUser[from].emissionMultiple -= emissionsMultipleTotal;\n            // Increase the to user's emissionMultiple by emissionsMultipleTotal.\n            getEmissionDataForUser[to].lastBalance = uint128(goopBalance(to));\n            getEmissionDataForUser[to].lastTimestamp = uint64(block.timestamp);\n            getEmissionDataForUser[to].emissionMultiple += emissionsMultipleTotal;\n        }\n        emit TransferBatch(msg.sender, from, to, ids, amounts);\n        if (to.code.length != 0) {\n            require(\n                ERC1155TokenReceiver(to).onERC1155BatchReceived(msg.sender, from, ids, amounts, data) ==\n                    ERC1155TokenReceiver.onERC1155BatchReceived.selector,\n                \"UNSAFE_RECIPIENT\"\n            );\n        } else require(to != address(0), \"INVALID_RECIPIENT\");\n    }\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) public override {\n        require(msg.sender == from || isApprovedForAll[from][msg.sender], \"NOT_AUTHORIZED\");\n        require(from == getGobblerData[id].owner, \"WRONG_FROM\"); // Can only transfer from the owner.\n        // Can only transfer 1 with ERC1155B.\n        require(amount == 1, \"INVALID_AMOUNT\");\n        getGobblerData[id].owner = to;\n        unchecked {\n            // Get the transferred gobbler's emission multiple. Can be zero before reveal.\n            uint64 emissionMultiple = getGobblerData[id].emissionMultiple;\n            // Decrease the from user's emissionMultiple by the gobbler's emissionMultiple.\n            getEmissionDataForUser[from].lastBalance = uint128(goopBalance(from));\n            getEmissionDataForUser[from].lastTimestamp = uint64(block.timestamp);\n            getEmissionDataForUser[from].emissionMultiple -= emissionMultiple;\n            // Increase the to user's emissionMultiple by the gobbler's emissionMultiple.\n            getEmissionDataForUser[to].lastBalance = uint128(goopBalance(to));\n            getEmissionDataForUser[to].lastTimestamp = uint64(block.timestamp);\n            getEmissionDataForUser[to].emissionMultiple += emissionMultiple;\n        }\n        emit TransferSingle(msg.sender, from, to, id, amount);\n        if (to.code.length != 0) {\n            require(\n                ERC1155TokenReceiver(to).onERC1155Received(msg.sender, from, id, amount, data) ==\n                    ERC1155TokenReceiver.onERC1155Received.selector,\n                \"UNSAFE_RECIPIENT\"\n            );\n        } else require(to != address(0), \"INVALID_RECIPIENT\");\n    }\n}",
        "after": "// SPDX-License-Identifier: Unlicense\npragma solidity >=0.8.0;\nimport {FixedPointMathLib} from \"solmate/utils/FixedPointMathLib.sol\";\nimport {ERC1155, ERC1155TokenReceiver} from \"solmate/tokens/ERC1155.sol\";\nimport {VRFConsumerBase} from \"chainlink/v0.8/VRFConsumerBase.sol\";\nimport {VRGDA} from \"./utils/VRGDA.sol\";\nimport {LibString} from \"./utils/LibString.sol\";\nimport {LogisticVRGDA} from \"./utils/LogisticVRGDA.sol\";\nimport {MerkleProofLib} from \"./utils/MerkleProofLib.sol\";\nimport {GobblersERC1155B} from \"./utils/GobblersERC1155B.sol\";\nimport {Goop} from \"./Goop.sol\";\n/// @title Art Gobblers NFT\n/// @notice Art Gobblers scan the cosmos in search of art producing life.\ncontract ArtGobblers is GobblersERC1155B, LogisticVRGDA, VRFConsumerBase, ERC1155TokenReceiver {\n    using LibString for uint256;\n    using FixedPointMathLib for uint256;\n    /*//////////////////////////////////////////////////////////////\n                                ADDRESSES\n    //////////////////////////////////////////////////////////////*/\n    Goop public immutable goop;\n    address public immutable team;\n    /*//////////////////////////////////////////////////////////////\n                            SUPPLY CONSTANTS\n    //////////////////////////////////////////////////////////////*/\n    /// @notice Maximum number of mintable gobblers.\n    uint256 public constant MAX_SUPPLY = 10000;\n    /// @notice Maximum amount of gobblers mintable via mintlist.\n    uint256 public constant MINTLIST_SUPPLY = 2000;\n    /// @notice Maximum amount of mintable leader gobblers.\n    uint256 public constant LEADER_SUPPLY = 10;\n    /// @notice Maximum amount of gobblers that will go to the team.\n    uint256 public constant TEAM_SUPPLY = 799;\n    /// @notice Maximum amount of gobblers that can be minted via VRGDA.\n    uint256 public constant MAX_MINTABLE = MAX_SUPPLY - MINTLIST_SUPPLY - LEADER_SUPPLY - TEAM_SUPPLY;\n    /*//////////////////////////////////////////////////////////////\n                                  URIS\n    //////////////////////////////////////////////////////////////*/\n    /// @notice Base URI for minted gobblers.\n    string public BASE_URI;\n    /// @notice URI for gobblers that have yet to be revealed.\n    string public UNREVEALED_URI;\n    /*//////////////////////////////////////////////////////////////\n                              VRF CONSTANTS\n    //////////////////////////////////////////////////////////////*/\n    bytes32 internal immutable chainlinkKeyHash;\n    uint256 internal immutable chainlinkFee;\n    /*//////////////////////////////////////////////////////////////\n                             MINTLIST STATE\n    //////////////////////////////////////////////////////////////*/\n    /// @notice Merkle root of mint mintlist.\n    bytes32 public immutable merkleRoot;\n    /// @notice Mapping to keep track of which addresses have claimed from mintlist.\n    mapping(address => bool) public hasClaimedMintlistGobbler;\n    /*//////////////////////////////////////////////////////////////\n                            VRGDA INPUT STATE\n    //////////////////////////////////////////////////////////////*/\n    /// @notice Timestamp for the start of minting.\n    uint256 public immutable mintStart;\n    /// @notice Number of gobblers minted from goop.\n    uint128 public numMintedFromGoop;\n    /*//////////////////////////////////////////////////////////////\n                         STANDARD GOBBLER STATE\n    //////////////////////////////////////////////////////////////*/\n    /// @notice Id of the most recently minted non leader gobbler.\n    /// @dev Will be 0 if no non leader gobblers have been minted yet.\n    uint128 public currentNonLeaderId;\n    /// @notice The number of gobblers minted to the team.\n    uint256 public numMintedForTeam;\n    /*//////////////////////////////////////////////////////////////\n                      LEADER GOBBLER AUCTION STATE\n    //////////////////////////////////////////////////////////////*/\n    /// @notice The last LEADER_SUPPLY ids are reserved for leader gobblers.\n    uint256 internal constant FIRST_LEADER_GOBBLER_ID = MAX_SUPPLY - LEADER_SUPPLY + 1;\n    /// @notice Struct holding data required for leader gobbler auctions.\n    struct LeaderGobblerAuctionData {\n        // Start price of current leader gobbler auction.\n        uint120 startPrice;\n        // Start timestamp of current leader gobbler auction.\n        uint120 startTimestamp;\n        // Id of the current leader gobbler being\n        // auctioned. 16 bits has a max value of\n        // ~60k which is within our limits here.\n        uint16 gobblerId;\n    }\n    /// @notice Data about the current leader gobbler auction.\n    LeaderGobblerAuctionData public leaderGobblerAuctionData;\n    /*//////////////////////////////////////////////////////////////\n                          GOBBLER REVEAL STATE\n    //////////////////////////////////////////////////////////////*/\n    /// @notice Struct holding data required for gobbler reveals.\n    struct GobblerRevealsData {\n        // Last random seed obtained from VRF.\n        uint64 randomSeed;\n        // Next reveal cannot happen before this timestamp.\n        uint64 nextRevealTimestamp;\n        // Id of latest gobbler which has been revealed so far.\n        uint56 lastRevealedId;\n        // Remaining gobblers to be assigned from the current seed.\n        uint56 toBeAssigned;\n        // Whether we are waiting to receive a seed from Chainlink.\n        bool waitingForSeed;\n    }\n    /// @notice Data about the current state of gobbler reveals.\n    GobblerRevealsData public gobblerRevealsData;\n    /*//////////////////////////////////////////////////////////////\n                             EMISSION STATE\n    //////////////////////////////////////////////////////////////*/\n    /// @notice Struct data info required for goop emission reward calculations.\n    struct EmissionData {\n        // The sum of the multiples of all gobblers the user holds.\n        uint64 emissionMultiple;\n        // Balance at time of last deposit or withdrawal.\n        uint128 lastBalance;\n        // Timestamp of last deposit or withdrawal.\n        uint64 lastTimestamp;\n    }\n    /// @notice Maps user addresses to their emission data.\n    mapping(address => EmissionData) public getEmissionDataForUser;\n    /*//////////////////////////////////////////////////////////////\n                            ART FEEDING STATE\n    //////////////////////////////////////////////////////////////*/\n    /// @notice Mapping from NFT contracts to their ids to gobbler ids they were fed to.\n    mapping(address => mapping(uint256 => uint256)) public getGobblerFromFedArt;\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n    event GoopAdded(address indexed user, uint256 goopAdded);\n    event GoopRemoved(address indexed user, uint256 goopAdded);\n    event GobblerClaimed(address indexed user, uint256 indexed gobblerId);\n    event GobblerPurchased(address indexed user, uint256 indexed gobblerId, uint256 price);\n    event GobblerMintedForTeam(address indexed user, uint256 indexed gobblerId);\n    event LeaderGobblerMinted(address indexed user, uint256 indexed gobblerId, uint256[] burnedGobblerIds);\n    event RandomnessRequested(address indexed user, uint256 toBeAssigned);\n    event RandomnessFulfilled(uint256 randomness);\n    event GobblersRevealed(address indexed user, uint256 numGobblers, uint256 lastRevealedId);\n    event ArtFeedToGobbler(address indexed user, uint256 indexed gobblerId, address indexed nft, uint256 id);\n    /*//////////////////////////////////////////////////////////////\n                                 ERRORS\n    //////////////////////////////////////////////////////////////*/\n    error Unauthorized();\n    error NoRemainingLeaderGobblers();\n    error CannotBurnLeader(uint256 gobblerId);\n    error AlreadyEaten(uint256 gobblerId, address nft, uint256 id);\n    error PriceExceededMax(uint256 currentPrice, uint256 maxPrice);\n    error IncorrectGobblerAmount(uint256 provided, uint256 needed);\n    /*//////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n    constructor(\n        // Mint config:\n        bytes32 _merkleRoot,\n        uint256 _mintStart,\n        // Addresses:\n        Goop _goop,\n        address _team,\n        // Chainlink:\n        address _vrfCoordinator,\n        address _linkToken,\n        bytes32 _chainlinkKeyHash,\n        uint256 _chainlinkFee,\n        // URIs:\n        string memory _baseUri,\n        string memory _unrevealedUri\n    )\n        VRFConsumerBase(_vrfCoordinator, _linkToken)\n        VRGDA(\n            6.9e18, // Initial price.\n            0.31e18 // Per period price decrease.\n        )\n        LogisticVRGDA(\n            // Max mintable gobblers.\n            int256(MAX_MINTABLE * 1e18),\n            0.014e18 // Time scale.\n        )\n    {\n        mintStart = _mintStart;\n        merkleRoot = _merkleRoot;\n        goop = _goop;\n        team = _team;\n        chainlinkKeyHash = _chainlinkKeyHash;\n        chainlinkFee = _chainlinkFee;\n        BASE_URI = _baseUri;\n        UNREVEALED_URI = _unrevealedUri;\n        // Starting price for leader gobblers is 100 gobblers.\n        leaderGobblerAuctionData.startPrice = 100;\n        // First leader gobbler auction starts 30 days after the mint starts.\n        leaderGobblerAuctionData.startTimestamp = uint120(_mintStart + 30 days);\n        // Current leader id starts at beginning of leader id space.\n        leaderGobblerAuctionData.gobblerId = uint16(FIRST_LEADER_GOBBLER_ID);\n        // Reveal for initial mint must wait 24 hours\n        gobblerRevealsData.nextRevealTimestamp = uint64(_mintStart + 1 days);\n    }\n    /*//////////////////////////////////////////////////////////////\n                          MINTLIST CLAIM LOGIC\n    //////////////////////////////////////////////////////////////*/\n    /// @notice Claim from mintlist, using a merkle proof.\n    /// @param proof Merkle proof to verify the sender is mintlisted.\n    /// @return gobblerId The id of the gobbler that was claimed.\n    function claimGobbler(bytes32[] calldata proof) external returns (uint256 gobblerId) {\n        // If minting has not yet begun or the user has already claimed, revert.\n        if (mintStart > block.timestamp || hasClaimedMintlistGobbler[msg.sender]) revert Unauthorized();\n        // If the user's proof is invalid, revert.\n        if (!MerkleProofLib.verify(proof, merkleRoot, keccak256(abi.encodePacked(msg.sender)))) revert Unauthorized();\n        hasClaimedMintlistGobbler[msg.sender] = true; // Before mint to prevent reentrancy.\n        unchecked {\n            emit GobblerClaimed(msg.sender, gobblerId = ++currentNonLeaderId);\n            _mint(msg.sender, gobblerId, \"\");\n        }\n    }\n    /*//////////////////////////////////////////////////////////////\n                              MINTING LOGIC\n    //////////////////////////////////////////////////////////////*/\n    /// @notice Mint a gobbler with goop, burning the cost.\n    /// @param maxPrice Maximum price to pay to mint the gobbler.\n    /// @return gobblerId The id of the gobbler that was minted.\n    function mintFromGoop(uint256 maxPrice) external returns (uint256 gobblerId) {\n        // No need to check mint cap, gobblerPrice()\n        // will revert due to overflow if we reach it.\n        // It will also revert prior to the mint start.\n        uint256 currentPrice = gobblerPrice();\n        // If the current price is above the user's specified max, revert.\n        if (currentPrice > maxPrice) revert PriceExceededMax(currentPrice, maxPrice);\n        goop.burnForGobblers(msg.sender, currentPrice);\n        unchecked {\n            ++numMintedFromGoop; // Before mint to prevent reentrancy.\n            emit GobblerPurchased(msg.sender, gobblerId = ++currentNonLeaderId, currentPrice);\n            _mint(msg.sender, gobblerId, \"\");\n        }\n    }\n    /// @notice Gobbler pricing in terms of goop.\n    /// @dev Will revert if called before minting starts\n    /// or after all gobblers have been minted via VRGDA.\n    function gobblerPrice() public view returns (uint256) {\n        // We need checked math here to cause overflow\n        // before minting has begun, preventing mints.\n        uint256 timeSinceStart = block.timestamp - mintStart;\n        return getPrice(timeSinceStart, numMintedFromGoop);\n    }\n    /*//////////////////////////////////////////////////////////////\n                           TEAM MINTING LOGIC\n    //////////////////////////////////////////////////////////////*/\n    /// @notice Mint a gobbler for the team.\n    /// @dev Team cannot never mint more than 10% of\n    /// the circulating supply of auctioned gobblers.\n    /// @return gobblerId The id of the gobbler that was minted.\n    function mintForTeam() external returns (uint256 gobblerId) {\n        unchecked {\n            // Can mint up to 10% of the current auctioned gobblers.\n            uint256 currentMintLimit = numMintedFromGoop / 10;\n            // Check that we wouldn't go over the limit after minting.\n            if (++numMintedForTeam > currentMintLimit) revert Unauthorized();\n            emit GobblerMintedForTeam(msg.sender, gobblerId = ++currentNonLeaderId);\n            _mint(address(team), gobblerId, \"\");\n        }\n    }\n    /*//////////////////////////////////////////////////////////////\n                      LEADER GOBBLER AUCTION LOGIC\n    //////////////////////////////////////////////////////////////*/\n    /// @notice Mint a leader gobbler by burning multiple standard gobblers.\n    /// @param gobblerIds The ids of the standard gobblers to burn.\n    /// @return gobblerId The id of the leader gobbler that was minted.\n    function mintLeaderGobbler(uint256[] calldata gobblerIds) external returns (uint256 gobblerId) {\n        gobblerId = leaderGobblerAuctionData.gobblerId; // Assign id.\n        // If the current id is greater than the max supply, there are no remaining leaders.\n        if (gobblerId > MAX_SUPPLY) revert NoRemainingLeaderGobblers();\n        // This will revert if the auction hasn't started yet, no need to check here as well.\n        uint256 cost = leaderGobblerPrice();\n        if (gobblerIds.length != cost) revert IncorrectGobblerAmount(gobblerIds.length, cost);\n        // Overflow in here should not occur, as most math is on emission multiples, which are inherently small.\n        unchecked {\n            uint256 burnedMultipleTotal; // The leader's emissionMultiple will be 2x the sum of the gobblers burned.\n            /*//////////////////////////////////////////////////////////////\n                                    BATCH BURN LOGIC\n            //////////////////////////////////////////////////////////////*/\n            // Generate an amounts array locally to use in the event below.\n            uint256[] memory amounts = new uint256[](gobblerIds.length);\n            uint256 id; // Storing outside the loop saves ~7 gas per iteration.\n            for (uint256 i = 0; i < gobblerIds.length; ++i) {\n                id = gobblerIds[i];\n                if (id >= FIRST_LEADER_GOBBLER_ID) revert CannotBurnLeader(id);\n                require(getGobblerData[id].owner == msg.sender, \"WRONG_FROM\");\n                burnedMultipleTotal += getGobblerData[id].emissionMultiple;\n                getGobblerData[id].owner = address(0);\n                amounts[i] = 1;\n            }\n            emit TransferBatch(msg.sender, msg.sender, address(0), gobblerIds, amounts);\n            /*//////////////////////////////////////////////////////////////\n                                  LEADER MINTING LOGIC\n            //////////////////////////////////////////////////////////////*/\n            // The shift right by 1 is equivalent to multiplication by 2, used to make\n            // the leader's emissionMultiple 2x the sum of the multiples of the gobblers burned.\n            // Must be done before minting as the transfer hook will update the user's emissionMultiple.\n            getGobblerData[gobblerId].emissionMultiple = uint48(burnedMultipleTotal << 1);\n            // Update the user's emission data in one big batch. We add burnedMultipleTotal to their\n            // emission multiple (not burnedMultipleTotal * 2) to account for the standard gobblers that\n            // were burned and hence should have their multiples subtracted from the user's total multiple.\n            getEmissionDataForUser[msg.sender].lastBalance = uint128(goopBalance(msg.sender));\n            getEmissionDataForUser[msg.sender].lastTimestamp = uint64(block.timestamp);\n            getEmissionDataForUser[msg.sender].emissionMultiple += uint64(burnedMultipleTotal);\n            // Start a new auction, 30 days after the previous start, and update the current leader id.\n            // The new start price is max of 100 and cost * 2. Shift left by 1 is like multiplication by 2.\n            leaderGobblerAuctionData.gobblerId = uint16(gobblerId) + 1;\n            leaderGobblerAuctionData.startTimestamp += 30 days;\n            leaderGobblerAuctionData.startPrice = uint120(cost < 50 ? 100 : cost << 1);\n            // If gobblerIds has 1,000 elements this should cost around ~270,000 gas.\n            emit LeaderGobblerMinted(msg.sender, gobblerId, gobblerIds);\n            _mint(msg.sender, gobblerId, \"\");\n        }\n    }\n    /// @notice Calculate the leader gobbler price in terms of gobblers, according to linear decay function.\n    /// @dev Reverts due to underflow if the auction has not yet begun. This is intended behavior and helps save gas.\n    function leaderGobblerPrice() public view returns (uint256) {\n        // Cannot be unchecked, we want this to revert if the auction has not started yet.\n        uint256 daysSinceStart = (block.timestamp - leaderGobblerAuctionData.startTimestamp) / 1 days;\n        // If 30 or more days have passed, leader gobbler is free.\n        if (daysSinceStart >= 30) return 0;\n        unchecked {\n            // If we're less than 30 days into the auction, the price simply decays linearly until the 30th day.\n            return (leaderGobblerAuctionData.startPrice * (30 - daysSinceStart)) / 30;\n        }\n    }\n    /*//////////////////////////////////////////////////////////////\n                                VRF LOGIC\n    //////////////////////////////////////////////////////////////*/\n    /// @notice Get the random seed for revealing gobblers.\n    function getRandomSeed() external returns (bytes32) {\n        uint256 nextRevealTimestamp = gobblerRevealsData.nextRevealTimestamp;\n        // A new random seed cannot be requested before the next reveal timestamp.\n        if (block.timestamp < nextRevealTimestamp) revert Unauthorized();\n        // A random seed can only be requested when all gobblers from previous seed have been assigned.\n        // This prevents a user from requesting additional randomness in hopes of a more favorable outcome.\n        if (gobblerRevealsData.toBeAssigned != 0) revert Unauthorized();\n        // A new seed cannot be requested while we wait for a new seed.\n        if (gobblerRevealsData.waitingForSeed) revert Unauthorized();\n        unchecked {\n            // We want at most one batch of reveals every 24 hours.\n            gobblerRevealsData.nextRevealTimestamp = uint64(nextRevealTimestamp + 1 days);\n            // Fix number of gobblers to be revealed from seed.\n            gobblerRevealsData.toBeAssigned = uint56(currentNonLeaderId - gobblerRevealsData.lastRevealedId);\n            // Prevent revealing while we wait for the seed.\n            gobblerRevealsData.waitingForSeed = true;\n        }\n        emit RandomnessRequested(msg.sender, gobblerRevealsData.toBeAssigned);\n        // Will revert if we don't have enough LINK to afford the request.\n        return requestRandomness(chainlinkKeyHash, chainlinkFee);\n    }\n    /// @notice Callback from Chainlink VRF. Sets randomSeed.\n    function fulfillRandomness(bytes32, uint256 randomness) internal override {\n        // The unchecked cast to uint64 is equivalent to moduloing the randomness by 2**64.\n        gobblerRevealsData.randomSeed = uint64(randomness); // 64 bits of randomness is plenty.\n        gobblerRevealsData.waitingForSeed = false; // We have the seed now, open up reveals.\n        emit RandomnessFulfilled(randomness);\n    }\n    /*//////////////////////////////////////////////////////////////\n                          GOBBLER REVEAL LOGIC\n    //////////////////////////////////////////////////////////////*/\n    /// @notice Knuth shuffle to progressively reveal gobblers using entropy from random seed.\n    /// @param numGobblers The number of gobblers to reveal.\n    function revealGobblers(uint256 numGobblers) external {\n        uint256 currentRandomSeed = gobblerRevealsData.randomSeed;\n        uint256 currentLastRevealedId = gobblerRevealsData.lastRevealedId;\n        uint256 totalRemainingToBeAssigned = gobblerRevealsData.toBeAssigned;\n        // Can't reveal more gobblers than were available when seed was generated.\n        if (numGobblers > totalRemainingToBeAssigned) revert Unauthorized();\n        // Can't reveal if we're still waiting for a new seed.\n        if (gobblerRevealsData.waitingForSeed) revert Unauthorized();\n        emit GobblersRevealed(msg.sender, numGobblers, currentLastRevealedId);\n        // Implements a Knuth shuffle. If something in\n        // here can overflow we've got bigger problems.\n        unchecked {\n            for (uint256 i = 0; i < numGobblers; i++) {\n                /*//////////////////////////////////////////////////////////////\n                                      DETERMINE RANDOM SWAP\n                //////////////////////////////////////////////////////////////*/\n                // Number of ids that have not been revealed. Subtract 1\n                // because we don't want to include any leaders in the swap.\n                uint256 remainingIds = FIRST_LEADER_GOBBLER_ID - currentLastRevealedId - 1;\n                // Randomly pick distance for swap.\n                uint256 distance = currentRandomSeed % remainingIds;\n                // Current id is consecutive to last reveal.\n                uint256 currentId = ++currentLastRevealedId;\n                // Select swap id, adding distance to next reveal id.\n                uint256 swapId = currentId + distance;\n                /*//////////////////////////////////////////////////////////////\n                                       GET INDICES FOR IDS\n                //////////////////////////////////////////////////////////////*/\n                // Get the index of the swap id.\n                uint48 swapIndex = getGobblerData[swapId].idx == 0\n                    ? uint48(swapId) // Hasn't been shuffled before.\n                    : getGobblerData[swapId].idx; // Shuffled before.\n                // Get the owner of the current id.\n                address currentIdOwner = getGobblerData[currentId].owner;\n                // Get the index of the current id.\n                uint48 currentIndex = getGobblerData[currentId].idx == 0\n                    ? uint48(currentId) // Hasn't been shuffled before.\n                    : getGobblerData[currentId].idx; // Shuffled before.\n                /*//////////////////////////////////////////////////////////////\n                                  SWAP INDICES AND SET MULTIPLE\n                //////////////////////////////////////////////////////////////*/\n                // Determine the current id's new emission multiple.\n                uint256 newCurrentIdMultiple = 9; // For beyond 7963.\n                if (swapIndex <= 3054) newCurrentIdMultiple = 6;\n                else if (swapIndex <= 5672) newCurrentIdMultiple = 7;\n                else if (swapIndex <= 7963) newCurrentIdMultiple = 8;\n                // Swap the index and multiple of the current id.\n                getGobblerData[currentId].idx = swapIndex;\n                getGobblerData[currentId].emissionMultiple = uint48(newCurrentIdMultiple);\n                // Swap the index of the swap id.\n                getGobblerData[swapId].idx = currentIndex;\n                /*//////////////////////////////////////////////////////////////\n                                   UPDATE CURRENT ID MULTIPLE\n                //////////////////////////////////////////////////////////////*/\n                // Update the emission data for the owner of the current id.\n                getEmissionDataForUser[currentIdOwner].lastBalance = uint128(goopBalance(currentIdOwner));\n                getEmissionDataForUser[currentIdOwner].lastTimestamp = uint64(block.timestamp);\n                getEmissionDataForUser[currentIdOwner].emissionMultiple += uint64(newCurrentIdMultiple);\n\n                // Update the random seed to choose a new distance for the next iteration.\n                // It is critical that we cast to uint64 here, as otherwise the random seed\n                // set after calling revealGobblers(1) thrice would differ from the seed set\n                // after calling revealGobblers(3) a single time. This would enable an attacker\n                // to choose from a number of different seeds and use whichever is most favorable.\n                currentRandomSeed = uint64(uint256(keccak256(abi.encodePacked(currentRandomSeed))));\n            }\n\n            // Update relevant reveal state state all at once.\n\n    \n          \n            \n    \n\n          \n          Expand Down\n    \n    \n  \n            gobblerRevealsData.randomSeed = uint64(currentRandomSeed);\n            gobblerRevealsData.lastRevealedId = uint56(currentLastRevealedId);\n            gobblerRevealsData.toBeAssigned = uint56(totalRemainingToBeAssigned - numGobblers);\n        }\n    }\n    /*//////////////////////////////////////////////////////////////\n                                URI LOGIC\n    //////////////////////////////////////////////////////////////*/\n    /// @notice Returns a token's URI if it has been minted.\n    /// @param gobblerId The id of the token to get the URI for.\n    function uri(uint256 gobblerId) public view virtual override returns (string memory) {\n        // Between 0 and lastRevealed are revealed normal gobblers.\n        if (gobblerId <= gobblerRevealsData.lastRevealedId) {\n            // 0 is not a valid id:\n            if (gobblerId == 0) return \"\";\n            return string(abi.encodePacked(BASE_URI, uint256(getGobblerData[gobblerId].idx).toString()));\n        }\n        // Between lastRevealed + 1 and currentNonLeaderId are minted but not revealed.\n        if (gobblerId <= currentNonLeaderId) return UNREVEALED_URI;\n        // Between currentNonLeaderId and FIRST_LEADER_GOBBLER_ID are unminted.\n        if (gobblerId < FIRST_LEADER_GOBBLER_ID) return \"\";\n        // Between FIRST_LEADER_GOBBLER_ID and gobblerId are minted leaders.\n        if (gobblerId < leaderGobblerAuctionData.gobblerId)\n            return string(abi.encodePacked(BASE_URI, gobblerId.toString()));\n        return \"\"; // Unminted leaders and invalid token ids.\n    }\n    /*//////////////////////////////////////////////////////////////\n                            ART FEEDING LOGIC\n    //////////////////////////////////////////////////////////////*/\n    /// @notice Feed a gobbler a work of art.\n    /// @param gobblerId The gobbler to feed the page.\n    /// @param nft The contract of the work of art.\n    /// @param id The id of the work of art.\n    /// @dev NFTs should be ERC1155s, ideally ERC1155Bs.\n    function feedArt(\n        uint256 gobblerId,\n        address nft,\n        uint256 id\n    ) external {\n        // The caller must own the gobbler they're feeding.\n        if (getGobblerData[gobblerId].owner != msg.sender) revert Unauthorized();\n        // In case the NFT is not an 1155B, we prevent eating it twice.\n        if (getGobblerFromFedArt[nft][id] != 0) revert AlreadyEaten(gobblerId, nft, id);\n        // Map the NFT to the gobbler that ate it.\n        getGobblerFromFedArt[nft][id] = gobblerId;\n        emit ArtFeedToGobbler(msg.sender, gobblerId, nft, id);\n        // We're assuming this is an 1155B-like NFT, so we'll only transfer 1.\n        ERC1155(nft).safeTransferFrom(msg.sender, address(this), id, 1, \"\");\n    }\n    /*//////////////////////////////////////////////////////////////\n                             EMISSION LOGIC\n    //////////////////////////////////////////////////////////////*/\n    /// @notice Calculate a user's staked goop balance.\n    /// @param user The user to query balance for.\n    function goopBalance(address user) public view returns (uint256) {\n        // If a user's goop balance is greater than\n        // 2**256 - 1 we've got much bigger problems.\n        unchecked {\n            uint256 emissionMultiple = getEmissionDataForUser[user].emissionMultiple;\n            uint256 lastBalanceWad = getEmissionDataForUser[user].lastBalance;\n            // Stored with 18 decimals, such that if a day and a half elapsed this variable would equal 1.5e18.\n            uint256 daysElapsedWad = ((block.timestamp - getEmissionDataForUser[user].lastTimestamp) * 1e18) / 1 days;\n            uint256 daysElapsedSquaredWad = daysElapsedWad.mulWadDown(daysElapsedWad); // Need to use wad math here.\n            // prettier-ignore\n            return lastBalanceWad + // The last recorded balance.\n                \n            // Don't need to do wad multiplication since we're\n            // multiplying by a plain integer with no decimals.\n            // Shift right by 2 is equivalent to division by 4.\n            ((emissionMultiple * daysElapsedSquaredWad) >> 2) +\n            \n            daysElapsedWad.mulWadDown( // Terms are wads, so must mulWad.\n                // No wad multiplication for emissionMultiple * lastBalance\n                // because emissionMultiple is a plain integer with no decimals.\n                // We multiply the sqrt's radicand by 1e18 because it expects ints.\n                (emissionMultiple * lastBalanceWad * 1e18).sqrt()\n            );\n        }\n    }\n    /// @notice Add goop to your emission balance.\n    /// @param goopAmount The amount of goop to add.\n    function addGoop(uint256 goopAmount) external {\n        // Burn goop being added to gobbler.\n        goop.burnForGobblers(msg.sender, goopAmount);\n        unchecked {\n            // If a user has enough goop to overflow their balance we've got big problems.\n            getEmissionDataForUser[msg.sender].lastBalance = uint128(goopBalance(msg.sender) + goopAmount);\n            getEmissionDataForUser[msg.sender].lastTimestamp = uint64(block.timestamp);\n        }\n        emit GoopAdded(msg.sender, goopAmount);\n    }\n    /// @notice Remove goop from your emission balance.\n    /// @param goopAmount The amount of goop to remove.\n    function removeGoop(uint256 goopAmount) external {\n        // Will revert due to underflow if removed amount is larger than the user's current goop balance.\n        getEmissionDataForUser[msg.sender].lastBalance = uint128(goopBalance(msg.sender) - goopAmount);\n        getEmissionDataForUser[msg.sender].lastTimestamp = uint64(block.timestamp);\n        emit GoopRemoved(msg.sender, goopAmount);\n        goop.mintForGobblers(msg.sender, goopAmount);\n    }\n    /*//////////////////////////////////////////////////////////////\n                          CONVENIENCE FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n    /// @notice Convenience function to get emission emissionMultiple for a gobbler.\n    /// @param gobblerId The gobbler to get emissionMultiple for.\n    function getGobblerEmissionMultiple(uint256 gobblerId) external view returns (uint256) {\n        return getGobblerData[gobblerId].emissionMultiple;\n    }\n    /// @notice Convenience function to get emission emissionMultiple for a user.\n    /// @param user The user to get emissionMultiple for.\n    function getUserEmissionMultiple(address user) external view returns (uint256) {\n        return getEmissionDataForUser[user].emissionMultiple;\n    }\n    /*//////////////////////////////////////////////////////////////\n                             ERC1155B LOGIC\n    //////////////////////////////////////////////////////////////*/\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) public override {\n        require(ids.length == amounts.length, \"LENGTH_MISMATCH\");\n        require(msg.sender == from || isApprovedForAll[from][msg.sender], \"NOT_AUTHORIZED\");\n        // Storing these outside the loop saves ~15 gas per iteration.\n        uint256 id;\n        uint256 amount;\n        unchecked {\n            uint64 emissionsMultipleTotal; // Will use to set each user's multiple.\n            for (uint256 i = 0; i < ids.length; i++) {\n                id = ids[i];\n                amount = amounts[i];\n                // Can only transfer from the owner.\n                require(from == getGobblerData[id].owner, \"WRONG_FROM\");\n                // Can only transfer 1 with ERC1155B.\n                require(amount == 1, \"INVALID_AMOUNT\");\n                getGobblerData[id].owner = to;\n                emissionsMultipleTotal += getGobblerData[id].emissionMultiple;\n            }\n            // Decrease the from user's emissionMultiple by emissionsMultipleTotal.\n            getEmissionDataForUser[from].lastBalance = uint128(goopBalance(from));\n            getEmissionDataForUser[from].lastTimestamp = uint64(block.timestamp);\n            getEmissionDataForUser[from].emissionMultiple -= emissionsMultipleTotal;\n            // Increase the to user's emissionMultiple by emissionsMultipleTotal.\n            getEmissionDataForUser[to].lastBalance = uint128(goopBalance(to));\n            getEmissionDataForUser[to].lastTimestamp = uint64(block.timestamp);\n            getEmissionDataForUser[to].emissionMultiple += emissionsMultipleTotal;\n        }\n        emit TransferBatch(msg.sender, from, to, ids, amounts);\n        if (to.code.length != 0) {\n            require(\n                ERC1155TokenReceiver(to).onERC1155BatchReceived(msg.sender, from, ids, amounts, data) ==\n                    ERC1155TokenReceiver.onERC1155BatchReceived.selector,\n                \"UNSAFE_RECIPIENT\"\n            );\n        } else require(to != address(0), \"INVALID_RECIPIENT\");\n    }\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) public override {\n        require(msg.sender == from || isApprovedForAll[from][msg.sender], \"NOT_AUTHORIZED\");\n        require(from == getGobblerData[id].owner, \"WRONG_FROM\"); // Can only transfer from the owner.\n        // Can only transfer 1 with ERC1155B.\n        require(amount == 1, \"INVALID_AMOUNT\");\n        getGobblerData[id].owner = to;\n        unchecked {\n            // Get the transferred gobbler's emission multiple. Can be zero before reveal.\n            uint64 emissionMultiple = getGobblerData[id].emissionMultiple;\n            // Decrease the from user's emissionMultiple by the gobbler's emissionMultiple.\n            getEmissionDataForUser[from].lastBalance = uint128(goopBalance(from));\n            getEmissionDataForUser[from].lastTimestamp = uint64(block.timestamp);\n            getEmissionDataForUser[from].emissionMultiple -= emissionMultiple;\n            // Increase the to user's emissionMultiple by the gobbler's emissionMultiple.\n            getEmissionDataForUser[to].lastBalance = uint128(goopBalance(to));\n            getEmissionDataForUser[to].lastTimestamp = uint64(block.timestamp);\n            getEmissionDataForUser[to].emissionMultiple += emissionMultiple;\n        }\n        emit TransferSingle(msg.sender, from, to, id, amount);\n        if (to.code.length != 0) {\n            require(\n                ERC1155TokenReceiver(to).onERC1155Received(msg.sender, from, id, amount, data) ==\n                    ERC1155TokenReceiver.onERC1155Received.selector,\n                \"UNSAFE_RECIPIENT\"\n            );\n        } else require(to != address(0), \"INVALID_RECIPIENT\");\n    }\n}"
    },
    {
        "tag": "reentrancy",
        "url": "https://github.com/kreskohq/kresko-protocol/commit/b5c3e95efcd065b8a853697ba4ccfdf9e2efa780",
        "file": "src/contracts/staking/KrStaking.sol",
        "before": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.20;\nimport {AccessControlUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\nimport {ReentrancyGuardUpgradeable} from \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport {SafeMath} from \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {IKrStaking} from \"./interfaces/IKrStaking.sol\";\ncontract KrStaking is AccessControlUpgradeable, ReentrancyGuardUpgradeable, IKrStaking {\n    using SafeERC20 for IERC20;\n    // keccak256(\"kresko.operator.role\")\n    bytes32 public constant OPERATOR_ROLE = 0x8952ae23cc3fea91b9dba0cefa16d18a26ca2bf124b54f42b5d04bce3aacecd2;\n    /**\n     * ==================================================\n     * =============== Storage ==========================\n     * ==================================================\n     */\n    // Info of each staked user.\n    mapping(uint256 => mapping(address => UserInfo)) private _userInfo;\n    // Reward token drip per block\n    mapping(address => uint256) public rewardPerBlockFor;\n    // Info of each pool.\n    PoolInfo[] private _poolInfo;\n    // Total allocation points.\n    uint128 public totalAllocPoint;\n    /**\n     * ==================================================\n     * ============== Events ============================\n     * ==================================================\n     */\n    event Deposit(address indexed user, uint256 indexed pid, uint256 indexed amount);\n    event Withdraw(address indexed user, uint256 indexed pid, uint256 indexed amount);\n    event EmergencyWithdraw(address indexed user, uint256 indexed pid, uint256 indexed amount);\n    event ClaimRewards(address indexed user, address indexed rewardToken, uint256 indexed amount);\n    /**\n     * ==================================================\n     * ============== Initializer =======================\n     * ==================================================\n     */\n    /**\n     * @notice Initialize the contract with a single pool\n     * @notice Sets initial reward token and rates\n     * @notice Sets the caller as DEFAULT_ADMIN\n     */\n    function initialize(\n        address[] calldata _rewardTokens,\n        uint256[] calldata _rewardPerBlocks,\n        IERC20 _depositToken,\n        uint128 _allocPoint,\n        uint128 _startBlock,\n        address _admin,\n        address _operator\n    ) external initializer {\n        require(_rewardPerBlocks.length == _rewardTokens.length, \"Reward tokens must have a rewardPerBlock value\");\n        __AccessControl_init();\n        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\n        _setupRole(DEFAULT_ADMIN_ROLE, _admin);\n        _setupRole(OPERATOR_ROLE, _operator);\n        _setupRole(OPERATOR_ROLE, msg.sender);\n        // Set initial reward tokens and allocations\n        for (uint256 i; i < _rewardTokens.length; i++) {\n            rewardPerBlockFor[_rewardTokens[i]] = _rewardPerBlocks[i];\n        }\n        // Push the initial pool in.\n        _poolInfo.push(\n            PoolInfo({\n                depositToken: _depositToken,\n                allocPoint: _allocPoint,\n                lastRewardBlock: _startBlock,\n                accRewardPerShares: new uint256[](_rewardTokens.length),\n                rewardTokens: _rewardTokens\n            })\n        );\n        totalAllocPoint += _allocPoint;\n    }\n    /**\n     * ==================================================\n     * =============== Modifiers ========================\n     * ==================================================\n     */\n    /**\n     * @notice Ensures no pool exists with this depositToken\n     * @param _depositToken to check\n     */\n    modifier ensurePoolDoesNotExist(IERC20 _depositToken) {\n        for (uint256 i; i < _poolInfo.length; i++) {\n            require(address(_poolInfo[i].depositToken) != address(_depositToken), \"KR: poolExists\");\n        }\n        _;\n    }\n    /**\n     * @notice Ensures this pool exists\n     * @param _pid to check\n     */\n    modifier ensurePoolExists(uint256 _pid) {\n        require(address(_poolInfo[_pid].depositToken) != address(0), \"KR: !poolExists\");\n        _;\n    }\n    /**\n     * ==================================================\n     * ================== Views =========================\n     * ==================================================\n     */\n    /// @inheritdoc IKrStaking\n    function pendingRewards(uint256 _pid, address _user) public view returns (Reward memory rewards) {\n        PoolInfo memory pool = _poolInfo[_pid];\n        UserInfo memory user = _userInfo[_pid][_user];\n        uint256 depositTokenSupply = pool.depositToken.balanceOf(address(this));\n        uint256 rewardTokensLength = pool.rewardTokens.length;\n        rewards = Reward({pid: _pid, tokens: pool.rewardTokens, amounts: new uint256[](rewardTokensLength)});\n        if (depositTokenSupply != 0 && user.amount > 0) {\n            for (uint256 rewardIndex; rewardIndex < rewardTokensLength; rewardIndex++) {\n                uint256 accRewardPerShare = pool.accRewardPerShares[rewardIndex];\n                uint256 rewardPerBlock = rewardPerBlockFor[pool.rewardTokens[rewardIndex]];\n                uint256 blocks = block.number - pool.lastRewardBlock;\n                uint256 reward = (rewardPerBlock * blocks * pool.allocPoint) / totalAllocPoint;\n                accRewardPerShare += (reward * 1e12) / depositTokenSupply;\n                rewards.amounts[rewardIndex] = (user.amount * accRewardPerShare) / 1e12 - user.rewardDebts[rewardIndex];\n                rewards.tokens[rewardIndex] = pool.rewardTokens[rewardIndex];\n            }\n        }\n    }\n    /// @inheritdoc IKrStaking\n    function allPendingRewards(address _account) external view returns (Reward[] memory allRewards) {\n        allRewards = new Reward[](_poolInfo.length);\n        for (uint256 pid; pid < _poolInfo.length; pid++) {\n            Reward memory poolReward = pendingRewards(pid, _account);\n            allRewards[pid] = poolReward;\n        }\n    }\n    /// @inheritdoc IKrStaking\n    function poolLength() external view returns (uint256) {\n        return _poolInfo.length;\n    }\n    /// @inheritdoc IKrStaking\n    function poolInfo(uint256 _pid) external view returns (PoolInfo memory) {\n        return _poolInfo[_pid];\n    }\n    /// @inheritdoc IKrStaking\n    function getPidFor(address _depositToken) external view returns (uint256 pid, bool found) {\n        for (pid; pid < _poolInfo.length; pid++) {\n            if (address(_poolInfo[pid].depositToken) == _depositToken) {\n                found = true;\n                break;\n            }\n        }\n    }\n    /// @inheritdoc IKrStaking\n    function userInfo(uint256 _pid, address _account) external view returns (UserInfo memory) {\n        return _userInfo[_pid][_account];\n    }\n    /**\n     * ==================================================\n     * =========== Core public functions ================\n     * ==================================================\n     */\n    /// @inheritdoc IKrStaking\n    function massUpdatePools() public payable {\n        for (uint256 pid; pid < _poolInfo.length; ++pid) {\n            updatePool(pid);\n        }\n    }\n    /// @inheritdoc IKrStaking\n    function updatePool(uint256 _pid) public payable returns (PoolInfo memory pool) {\n        pool = _poolInfo[_pid];\n        // Updates once per block\n        if (block.number > pool.lastRewardBlock) {\n            uint256 deposits = pool.depositToken.balanceOf(address(this));\n            // No rewards for 0 deposits\n            if (deposits > 0) {\n                for (uint256 rewardIndex; rewardIndex < pool.rewardTokens.length; rewardIndex++) {\n                    // Reward per block for a particular reward token\n                    uint256 rewardPerBlock = rewardPerBlockFor[pool.rewardTokens[rewardIndex]];\n                    // Blocks advanced since last update\n                    uint256 blocks = block.number - pool.lastRewardBlock;\n                    // Allocation for this particular pool\n                    uint256 reward = (rewardPerBlock * blocks * pool.allocPoint) / totalAllocPoint;\n                    // Increment accumulated rewards for new block height\n                    pool.accRewardPerShares[rewardIndex] += (reward * 1e12) / deposits;\n                }\n            }\n            // No further updates within same block height\n            pool.lastRewardBlock = uint128(block.number);\n            // storage\n            _poolInfo[_pid] = pool;\n        }\n    }\n    /// @inheritdoc IKrStaking\n    function deposit(address _to, uint256 _pid, uint256 _amount) external payable nonReentrant ensurePoolExists(_pid) {\n        PoolInfo memory pool = updatePool(_pid);\n        UserInfo storage user = _userInfo[_pid][_to];\n        // Initialize rewardDebts\n        if (user.rewardDebts.length == 0) {\n            user.rewardDebts = new uint256[](pool.rewardTokens.length);\n        }\n        pool.depositToken.safeTransferFrom(address(msg.sender), address(this), _amount);\n        user.amount += _amount;\n        for (uint256 rewardIndex; rewardIndex < pool.rewardTokens.length; rewardIndex++) {\n            user.rewardDebts[rewardIndex] += (_amount * pool.accRewardPerShares[rewardIndex]) / 1e12;\n        }\n        emit Deposit(_to, _pid, _amount);\n    }\n    /// @inheritdoc IKrStaking\n    function withdraw(uint256 _pid, uint256 _amount, address _rewardRecipient) external payable nonReentrant {\n        require(_amount > 0, \"KR: 0-withdraw\");\n        require(_rewardRecipient != address(0), \"KR: !rewardRecipient\");\n        PoolInfo memory pool = updatePool(_pid);\n        UserInfo storage user = _userInfo[_pid][msg.sender];\n        sendRewards(pool, user, _rewardRecipient);\n        // Send whole balance in case of amount exceeds deposits\n        if (_amount > user.amount) {\n            _amount = user.amount;\n            user.amount = 0;\n        } else {\n            user.amount -= _amount;\n        }\n        pool.depositToken.safeTransfer(address(msg.sender), _amount);\n        for (uint256 rewardIndex; rewardIndex < pool.rewardTokens.length; rewardIndex++) {\n            user.rewardDebts[rewardIndex] = (user.amount * pool.accRewardPerShares[rewardIndex]) / 1e12;\n        }\n        emit Withdraw(msg.sender, _pid, _amount);\n    }\n    /// @inheritdoc IKrStaking\n    function claim(uint256 _pid, address _rewardRecipient) external payable nonReentrant {\n        require(_rewardRecipient != address(0), \"KR: !rewardRecipient\");\n        PoolInfo memory pool = updatePool(_pid);\n        UserInfo storage user = _userInfo[_pid][msg.sender];\n        if (user.amount > 0) {\n            sendRewards(pool, user, _rewardRecipient);\n            for (uint256 rewardIndex; rewardIndex < pool.rewardTokens.length; rewardIndex++) {\n                user.rewardDebts[rewardIndex] = (user.amount * pool.accRewardPerShares[rewardIndex]) / 1e12;\n            }\n        }\n    }\n    /// @inheritdoc IKrStaking\n    function emergencyWithdraw(uint256 _pid) external payable nonReentrant {\n        PoolInfo memory pool = updatePool(_pid);\n        UserInfo storage user = _userInfo[_pid][msg.sender];\n        pool.depositToken.safeTransfer(address(msg.sender), user.amount);\n        user.amount = 0;\n        for (uint256 rewardIndex; rewardIndex < pool.rewardTokens.length; rewardIndex++) {\n            user.rewardDebts[rewardIndex] = 0;\n        }\n        emit EmergencyWithdraw(msg.sender, _pid, user.amount);\n    }\n    /**\n     * ==================================================\n     * ============= Admin functions ====================\n     * ==================================================\n     */\n    /// @inheritdoc IKrStaking\n    function setRewardPerBlockFor(\n        address _rewardToken,\n        uint256 _rewardPerBlock\n    ) external payable onlyRole(OPERATOR_ROLE) {\n        rewardPerBlockFor[_rewardToken] = _rewardPerBlock;\n    }\n    /// @inheritdoc IKrStaking\n    function addPool(\n        address[] calldata _rewardTokens,\n        IERC20 _depositToken,\n        uint128 _allocPoint,\n        uint128 _startBlock\n    ) external payable onlyRole(OPERATOR_ROLE) ensurePoolDoesNotExist(_depositToken) {\n        require(_rewardTokens.length > 0, \"KR: !rewardTokens\");\n        totalAllocPoint += _allocPoint;\n        _poolInfo.push(\n            PoolInfo({\n                depositToken: _depositToken,\n                allocPoint: _allocPoint,\n                lastRewardBlock: _startBlock != 0 ? _startBlock : uint128(block.number),\n                accRewardPerShares: new uint256[](_rewardTokens.length),\n                rewardTokens: _rewardTokens\n            })\n        );\n    }\n    /// @inheritdoc IKrStaking\n    function setPool(\n        uint256 _pid,\n        uint128 _newAllocPoint\n    ) external payable onlyRole(OPERATOR_ROLE) ensurePoolExists(_pid) {\n        totalAllocPoint = totalAllocPoint - _poolInfo[_pid].allocPoint + _newAllocPoint;\n        _poolInfo[_pid].allocPoint = _newAllocPoint;\n    }\n    /**\n     * ==================================================\n     * ============ Protected functions =================\n     * ==================================================\n     */\n    /// @inheritdoc IKrStaking\n    function withdrawFor(\n        address _for,\n        uint256 _pid,\n        uint256 _amount,\n        address _rewardRecipient\n    ) external payable nonReentrant onlyRole(OPERATOR_ROLE) {\n        require(_amount > 0, \"KR: 0-withdraw\");\n        require(_rewardRecipient != address(0), \"KR: !rewardRecipient\");\n        PoolInfo memory pool = updatePool(_pid);\n        UserInfo storage user = _userInfo[_pid][_for];\n        sendRewards(pool, user, _rewardRecipient);\n        // Send whole balance in case of amount exceeds deposits\n        if (_amount > user.amount) {\n            _amount = user.amount;\n            user.amount = 0;\n        } else {\n            user.amount -= _amount;\n        }\n        pool.depositToken.safeTransfer(address(msg.sender), _amount);\n        for (uint256 rewardIndex; rewardIndex < pool.rewardTokens.length; rewardIndex++) {\n            user.rewardDebts[rewardIndex] = (user.amount * pool.accRewardPerShares[rewardIndex]) / 1e12;\n        }\n        emit Withdraw(_for, _pid, _amount);\n    }\n    /// @inheritdoc IKrStaking\n    function claimFor(\n        address _for,\n        uint256 _pid,\n        address _rewardRecipient\n    ) external payable nonReentrant onlyRole(OPERATOR_ROLE) {\n        require(_rewardRecipient != address(0), \"KR: !rewardRecipient\");\n        PoolInfo memory pool = updatePool(_pid);\n        UserInfo storage user = _userInfo[_pid][_for];\n        if (user.amount > 0) {\n            sendRewards(pool, user, _rewardRecipient);\n            for (uint256 rewardIndex; rewardIndex < pool.rewardTokens.length; rewardIndex++) {\n                user.rewardDebts[rewardIndex] = (user.amount * pool.accRewardPerShares[rewardIndex]) / 1e12;\n            }\n        }\n    }\n\n    /// @inheritdoc IKrStaking\n    function rescueNative() external payable onlyRole(OPERATOR_ROLE) {\n        payable(msg.sender).transfer(address(this).balance);\n    }\n\n    /// @inheritdoc IKrStaking\n\n    \n          \n            \n    \n\n          \n          Expand Down\n    \n    \n  \n    function rescueNonPoolToken(\n        IERC20 _tokenToRescue,\n        uint256 _amount\n    ) external payable onlyRole(OPERATOR_ROLE) ensurePoolDoesNotExist(_tokenToRescue) {\n        _tokenToRescue.safeTransfer(msg.sender, _amount);\n    }\n    /**\n     * ==================================================\n     * ============= Internal functions =================\n     * ==================================================\n     */\n    /**\n     * @notice Loops over pools reward tokens and sends them to the user\n     * @param pool pool to send rewards from in `_poolInfo`\n     * @param user users info in the @param pool\n     * @param recipient user to send rewards to\n     */\n    function sendRewards(PoolInfo memory pool, UserInfo memory user, address recipient) internal {\n        for (uint256 rewardIndex; rewardIndex < pool.rewardTokens.length; rewardIndex++) {\n            uint256 rewardDebt = (user.amount * pool.accRewardPerShares[rewardIndex]) / 1e12;\n            uint256 pending = rewardDebt - user.rewardDebts[rewardIndex];\n            if (pending > 0) {\n                IERC20(pool.rewardTokens[rewardIndex]).safeTransfer(recipient, pending);\n                emit ClaimRewards(recipient, pool.rewardTokens[rewardIndex], pending);\n            }\n        }\n    }\n}",
        "after": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.20;\nimport {AccessControlUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\nimport {ReentrancyGuardUpgradeable} from \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport {SafeMath} from \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {IKrStaking} from \"./interfaces/IKrStaking.sol\";\ncontract KrStaking is AccessControlUpgradeable, ReentrancyGuardUpgradeable, IKrStaking {\n    using SafeERC20 for IERC20;\n    // keccak256(\"kresko.operator.role\")\n    bytes32 public constant OPERATOR_ROLE = 0x8952ae23cc3fea91b9dba0cefa16d18a26ca2bf124b54f42b5d04bce3aacecd2;\n    /**\n     * ==================================================\n     * =============== Storage ==========================\n     * ==================================================\n     */\n    // Info of each staked user.\n    mapping(uint256 => mapping(address => UserInfo)) private _userInfo;\n    // Reward token drip per block\n    mapping(address => uint256) public rewardPerBlockFor;\n    // Info of each pool.\n    PoolInfo[] private _poolInfo;\n    // Total allocation points.\n    uint128 public totalAllocPoint;\n    /**\n     * ==================================================\n     * ============== Events ============================\n     * ==================================================\n     */\n    event Deposit(address indexed user, uint256 indexed pid, uint256 indexed amount);\n    event Withdraw(address indexed user, uint256 indexed pid, uint256 indexed amount);\n    event EmergencyWithdraw(address indexed user, uint256 indexed pid, uint256 indexed amount);\n    event ClaimRewards(address indexed user, address indexed rewardToken, uint256 indexed amount);\n    /**\n     * ==================================================\n     * ============== Initializer =======================\n     * ==================================================\n     */\n    /**\n     * @notice Initialize the contract with a single pool\n     * @notice Sets initial reward token and rates\n     * @notice Sets the caller as DEFAULT_ADMIN\n     */\n    function initialize(\n        address[] calldata _rewardTokens,\n        uint256[] calldata _rewardPerBlocks,\n        IERC20 _depositToken,\n        uint128 _allocPoint,\n        uint128 _startBlock,\n        address _admin,\n        address _operator\n    ) external initializer {\n        require(_rewardPerBlocks.length == _rewardTokens.length, \"Reward tokens must have a rewardPerBlock value\");\n        __AccessControl_init();\n        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\n        _setupRole(DEFAULT_ADMIN_ROLE, _admin);\n        _setupRole(OPERATOR_ROLE, _operator);\n        _setupRole(OPERATOR_ROLE, msg.sender);\n        // Set initial reward tokens and allocations\n        for (uint256 i; i < _rewardTokens.length; i++) {\n            rewardPerBlockFor[_rewardTokens[i]] = _rewardPerBlocks[i];\n        }\n        // Push the initial pool in.\n        _poolInfo.push(\n            PoolInfo({\n                depositToken: _depositToken,\n                allocPoint: _allocPoint,\n                lastRewardBlock: _startBlock,\n                accRewardPerShares: new uint256[](_rewardTokens.length),\n                rewardTokens: _rewardTokens\n            })\n        );\n        totalAllocPoint += _allocPoint;\n    }\n    /**\n     * ==================================================\n     * =============== Modifiers ========================\n     * ==================================================\n     */\n    /**\n     * @notice Ensures no pool exists with this depositToken\n     * @param _depositToken to check\n     */\n    modifier ensurePoolDoesNotExist(IERC20 _depositToken) {\n        for (uint256 i; i < _poolInfo.length; i++) {\n            require(address(_poolInfo[i].depositToken) != address(_depositToken), \"KR: poolExists\");\n        }\n        _;\n    }\n    /**\n     * @notice Ensures this pool exists\n     * @param _pid to check\n     */\n    modifier ensurePoolExists(uint256 _pid) {\n        require(address(_poolInfo[_pid].depositToken) != address(0), \"KR: !poolExists\");\n        _;\n    }\n    /**\n     * ==================================================\n     * ================== Views =========================\n     * ==================================================\n     */\n    /// @inheritdoc IKrStaking\n    function pendingRewards(uint256 _pid, address _user) public view returns (Reward memory rewards) {\n        PoolInfo memory pool = _poolInfo[_pid];\n        UserInfo memory user = _userInfo[_pid][_user];\n        uint256 depositTokenSupply = pool.depositToken.balanceOf(address(this));\n        uint256 rewardTokensLength = pool.rewardTokens.length;\n        rewards = Reward({pid: _pid, tokens: pool.rewardTokens, amounts: new uint256[](rewardTokensLength)});\n        if (depositTokenSupply != 0 && user.amount > 0) {\n            for (uint256 rewardIndex; rewardIndex < rewardTokensLength; rewardIndex++) {\n                uint256 accRewardPerShare = pool.accRewardPerShares[rewardIndex];\n                uint256 rewardPerBlock = rewardPerBlockFor[pool.rewardTokens[rewardIndex]];\n                uint256 blocks = block.number - pool.lastRewardBlock;\n                uint256 reward = (rewardPerBlock * blocks * pool.allocPoint) / totalAllocPoint;\n                accRewardPerShare += (reward * 1e12) / depositTokenSupply;\n                rewards.amounts[rewardIndex] = (user.amount * accRewardPerShare) / 1e12 - user.rewardDebts[rewardIndex];\n                rewards.tokens[rewardIndex] = pool.rewardTokens[rewardIndex];\n            }\n        }\n    }\n    /// @inheritdoc IKrStaking\n    function allPendingRewards(address _account) external view returns (Reward[] memory allRewards) {\n        allRewards = new Reward[](_poolInfo.length);\n        for (uint256 pid; pid < _poolInfo.length; pid++) {\n            Reward memory poolReward = pendingRewards(pid, _account);\n            allRewards[pid] = poolReward;\n        }\n    }\n    /// @inheritdoc IKrStaking\n    function poolLength() external view returns (uint256) {\n        return _poolInfo.length;\n    }\n    /// @inheritdoc IKrStaking\n    function poolInfo(uint256 _pid) external view returns (PoolInfo memory) {\n        return _poolInfo[_pid];\n    }\n    /// @inheritdoc IKrStaking\n    function getPidFor(address _depositToken) external view returns (uint256 pid, bool found) {\n        for (pid; pid < _poolInfo.length; pid++) {\n            if (address(_poolInfo[pid].depositToken) == _depositToken) {\n                found = true;\n                break;\n            }\n        }\n    }\n    /// @inheritdoc IKrStaking\n    function userInfo(uint256 _pid, address _account) external view returns (UserInfo memory) {\n        return _userInfo[_pid][_account];\n    }\n    /**\n     * ==================================================\n     * =========== Core public functions ================\n     * ==================================================\n     */\n    /// @inheritdoc IKrStaking\n    function massUpdatePools() public payable {\n        for (uint256 pid; pid < _poolInfo.length; ++pid) {\n            updatePool(pid);\n        }\n    }\n    /// @inheritdoc IKrStaking\n    function updatePool(uint256 _pid) public payable returns (PoolInfo memory pool) {\n        pool = _poolInfo[_pid];\n        // Updates once per block\n        if (block.number > pool.lastRewardBlock) {\n            uint256 deposits = pool.depositToken.balanceOf(address(this));\n            // No rewards for 0 deposits\n            if (deposits > 0) {\n                for (uint256 rewardIndex; rewardIndex < pool.rewardTokens.length; rewardIndex++) {\n                    // Reward per block for a particular reward token\n                    uint256 rewardPerBlock = rewardPerBlockFor[pool.rewardTokens[rewardIndex]];\n                    // Blocks advanced since last update\n                    uint256 blocks = block.number - pool.lastRewardBlock;\n                    // Allocation for this particular pool\n                    uint256 reward = (rewardPerBlock * blocks * pool.allocPoint) / totalAllocPoint;\n                    // Increment accumulated rewards for new block height\n                    pool.accRewardPerShares[rewardIndex] += (reward * 1e12) / deposits;\n                }\n            }\n            // No further updates within same block height\n            pool.lastRewardBlock = uint128(block.number);\n            // storage\n            _poolInfo[_pid] = pool;\n        }\n    }\n    /// @inheritdoc IKrStaking\n    function deposit(address _to, uint256 _pid, uint256 _amount) external payable nonReentrant ensurePoolExists(_pid) {\n        PoolInfo memory pool = updatePool(_pid);\n        UserInfo storage user = _userInfo[_pid][_to];\n        // Initialize rewardDebts\n        if (user.rewardDebts.length == 0) {\n            user.rewardDebts = new uint256[](pool.rewardTokens.length);\n        }\n        pool.depositToken.safeTransferFrom(address(msg.sender), address(this), _amount);\n        user.amount += _amount;\n        for (uint256 rewardIndex; rewardIndex < pool.rewardTokens.length; rewardIndex++) {\n            user.rewardDebts[rewardIndex] += (_amount * pool.accRewardPerShares[rewardIndex]) / 1e12;\n        }\n        emit Deposit(_to, _pid, _amount);\n    }\n    /// @inheritdoc IKrStaking\n    function withdraw(uint256 _pid, uint256 _amount, address _rewardRecipient) external payable nonReentrant {\n        require(_amount > 0, \"KR: 0-withdraw\");\n        require(_rewardRecipient != address(0), \"KR: !rewardRecipient\");\n        PoolInfo memory pool = updatePool(_pid);\n        UserInfo storage user = _userInfo[_pid][msg.sender];\n        sendRewards(pool, user, _rewardRecipient);\n        // Send whole balance in case of amount exceeds deposits\n        if (_amount > user.amount) {\n            _amount = user.amount;\n            user.amount = 0;\n        } else {\n            user.amount -= _amount;\n        }\n        pool.depositToken.safeTransfer(address(msg.sender), _amount);\n        for (uint256 rewardIndex; rewardIndex < pool.rewardTokens.length; rewardIndex++) {\n            user.rewardDebts[rewardIndex] = (user.amount * pool.accRewardPerShares[rewardIndex]) / 1e12;\n        }\n        emit Withdraw(msg.sender, _pid, _amount);\n    }\n    /// @inheritdoc IKrStaking\n    function claim(uint256 _pid, address _rewardRecipient) external payable nonReentrant {\n        require(_rewardRecipient != address(0), \"KR: !rewardRecipient\");\n        PoolInfo memory pool = updatePool(_pid);\n        UserInfo storage user = _userInfo[_pid][msg.sender];\n        if (user.amount > 0) {\n            sendRewards(pool, user, _rewardRecipient);\n            for (uint256 rewardIndex; rewardIndex < pool.rewardTokens.length; rewardIndex++) {\n                user.rewardDebts[rewardIndex] = (user.amount * pool.accRewardPerShares[rewardIndex]) / 1e12;\n            }\n        }\n    }\n    /// @inheritdoc IKrStaking\n    function emergencyWithdraw(uint256 _pid) external payable nonReentrant {\n        PoolInfo memory pool = updatePool(_pid);\n        UserInfo storage user = _userInfo[_pid][msg.sender];\n        pool.depositToken.safeTransfer(address(msg.sender), user.amount);\n        user.amount = 0;\n        for (uint256 rewardIndex; rewardIndex < pool.rewardTokens.length; rewardIndex++) {\n            user.rewardDebts[rewardIndex] = 0;\n        }\n        emit EmergencyWithdraw(msg.sender, _pid, user.amount);\n    }\n    /**\n     * ==================================================\n     * ============= Admin functions ====================\n     * ==================================================\n     */\n    /// @inheritdoc IKrStaking\n    function setRewardPerBlockFor(\n        address _rewardToken,\n        uint256 _rewardPerBlock\n    ) external payable onlyRole(OPERATOR_ROLE) {\n        rewardPerBlockFor[_rewardToken] = _rewardPerBlock;\n    }\n    /// @inheritdoc IKrStaking\n    function addPool(\n        address[] calldata _rewardTokens,\n        IERC20 _depositToken,\n        uint128 _allocPoint,\n        uint128 _startBlock\n    ) external payable onlyRole(OPERATOR_ROLE) ensurePoolDoesNotExist(_depositToken) {\n        require(_rewardTokens.length > 0, \"KR: !rewardTokens\");\n        totalAllocPoint += _allocPoint;\n        _poolInfo.push(\n            PoolInfo({\n                depositToken: _depositToken,\n                allocPoint: _allocPoint,\n                lastRewardBlock: _startBlock != 0 ? _startBlock : uint128(block.number),\n                accRewardPerShares: new uint256[](_rewardTokens.length),\n                rewardTokens: _rewardTokens\n            })\n        );\n    }\n    /// @inheritdoc IKrStaking\n    function setPool(\n        uint256 _pid,\n        uint128 _newAllocPoint\n    ) external payable onlyRole(OPERATOR_ROLE) ensurePoolExists(_pid) {\n        totalAllocPoint = totalAllocPoint - _poolInfo[_pid].allocPoint + _newAllocPoint;\n        _poolInfo[_pid].allocPoint = _newAllocPoint;\n    }\n    /**\n     * ==================================================\n     * ============ Protected functions =================\n     * ==================================================\n     */\n    /// @inheritdoc IKrStaking\n    function withdrawFor(\n        address _for,\n        uint256 _pid,\n        uint256 _amount,\n        address _rewardRecipient\n    ) external payable nonReentrant onlyRole(OPERATOR_ROLE) {\n        require(_amount > 0, \"KR: 0-withdraw\");\n        require(_rewardRecipient != address(0), \"KR: !rewardRecipient\");\n        PoolInfo memory pool = updatePool(_pid);\n        UserInfo storage user = _userInfo[_pid][_for];\n        sendRewards(pool, user, _rewardRecipient);\n        // Send whole balance in case of amount exceeds deposits\n        if (_amount > user.amount) {\n            _amount = user.amount;\n            user.amount = 0;\n        } else {\n            user.amount -= _amount;\n        }\n        pool.depositToken.safeTransfer(address(msg.sender), _amount);\n        for (uint256 rewardIndex; rewardIndex < pool.rewardTokens.length; rewardIndex++) {\n            user.rewardDebts[rewardIndex] = (user.amount * pool.accRewardPerShares[rewardIndex]) / 1e12;\n        }\n        emit Withdraw(_for, _pid, _amount);\n    }\n    /// @inheritdoc IKrStaking\n    function claimFor(\n        address _for,\n        uint256 _pid,\n        address _rewardRecipient\n    ) external payable nonReentrant onlyRole(OPERATOR_ROLE) {\n        require(_rewardRecipient != address(0), \"KR: !rewardRecipient\");\n        PoolInfo memory pool = updatePool(_pid);\n        UserInfo storage user = _userInfo[_pid][_for];\n        if (user.amount > 0) {\n            sendRewards(pool, user, _rewardRecipient);\n            for (uint256 rewardIndex; rewardIndex < pool.rewardTokens.length; rewardIndex++) {\n                user.rewardDebts[rewardIndex] = (user.amount * pool.accRewardPerShares[rewardIndex]) / 1e12;\n            }\n        }\n    }\n\n    /// @inheritdoc IKrStaking\n    function rescueNative() external payable onlyRole(OPERATOR_ROLE) {\n        (bool success, ) = msg.sender.call{value: address(this).balance}(\"\");\n        require(success, \"Transfer failed.\");\n    }\n\n    /// @inheritdoc IKrStaking\n\n    \n          \n            \n    \n\n          \n          Expand Down\n    \n    \n  \n    function rescueNonPoolToken(\n        IERC20 _tokenToRescue,\n        uint256 _amount\n    ) external payable onlyRole(OPERATOR_ROLE) ensurePoolDoesNotExist(_tokenToRescue) {\n        _tokenToRescue.safeTransfer(msg.sender, _amount);\n    }\n    /**\n     * ==================================================\n     * ============= Internal functions =================\n     * ==================================================\n     */\n    /**\n     * @notice Loops over pools reward tokens and sends them to the user\n     * @param pool pool to send rewards from in `_poolInfo`\n     * @param user users info in the @param pool\n     * @param recipient user to send rewards to\n     */\n    function sendRewards(PoolInfo memory pool, UserInfo memory user, address recipient) internal {\n        for (uint256 rewardIndex; rewardIndex < pool.rewardTokens.length; rewardIndex++) {\n            uint256 rewardDebt = (user.amount * pool.accRewardPerShares[rewardIndex]) / 1e12;\n            uint256 pending = rewardDebt - user.rewardDebts[rewardIndex];\n            if (pending > 0) {\n                IERC20(pool.rewardTokens[rewardIndex]).safeTransfer(recipient, pending);\n                emit ClaimRewards(recipient, pool.rewardTokens[rewardIndex], pending);\n            }\n        }\n    }\n}"
    },
    {
        "tag": "access control",
        "url": "https://github.com/SocketDotTech/socket-DL/commit/01f1b51bd725cf0797a912c64b65c31f9e04e578",
        "file": "contracts/switchboard/native/ArbitrumL1Switchboard.sol\n",
        "before": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.7;\nimport \"openzeppelin-contracts/contracts/vendor/arbitrum/IBridge.sol\";\nimport \"openzeppelin-contracts/contracts/vendor/arbitrum/IInbox.sol\";\nimport \"openzeppelin-contracts/contracts/vendor/arbitrum/IOutbox.sol\";\nimport \"./NativeSwitchboardBase.sol\";\n/**\n * @title ArbitrumL1Switchboard\n * @dev This contract is a switchboard contract for the Arbitrum chain that handles packet attestation and actions on the L1 to Arbitrum and\n * Arbitrum to L1 path.\n * This contract inherits base functions from NativeSwitchboardBase, including fee calculation,\n * trip and untrip actions, and limit setting functions.\n */\ncontract ArbitrumL1Switchboard is NativeSwitchboardBase {\n    /**\n     * @notice The address to which refunds for remote calls will be sent.\n     */\n    address public remoteRefundAddress;\n\n    /**\n     * @notice The address to which refunds for call value will be sent.\n     */\n    address public callValueRefundAddress;\n\n    /**\n     * @notice An interface for receiving incoming messages from the Arbitrum chain.\n     */\n\n    \n        \n          \n    \n\n        \n        Expand All\n    \n    @@ -45,16 +35,6 @@ contract ArbitrumL1Switchboard is NativeSwitchboardBase {\n  \n    IInbox public inbox__;\n    /**\n     * @notice An interface for the Arbitrum-to-Ethereum bridge.\n     */\n    IBridge public bridge__;\n    /**\n     * @notice An interface for the Ethereum-to-Arbitrum outbox.\n     */\n    IOutbox public outbox__;\n    /**\n     * @notice Event emitted when the inbox address is updated.\n     * @param inbox The new inbox address.\n     */\n    event UpdatedInboxAddress(address inbox);\n\n    /**\n     * @notice Event emitted when the remote and call value refund addresses are updated.\n     * @param remoteRefundAddress The new remote refund address.\n     * @param callValueRefundAddress The new call value refund address.\n     */\n    event UpdatedRefundAddresses(\n        address remoteRefundAddress,\n        address callValueRefundAddress\n    );\n\n    /**\n     * @notice Event emitted when the bridge address is updated.\n     * @param bridgeAddress The new bridge address.\n\n    \n          \n            \n    \n\n          \n          Expand Down\n          \n            \n    \n\n          \n          Expand Up\n    \n    @@ -102,9 +82,6 @@ contract ArbitrumL1Switchboard is NativeSwitchboardBase {\n  \n     */\n    event UpdatedBridge(address bridgeAddress);\n    /**\n     * @notice Event emitted when the outbox address is updated.\n     * @param outboxAddress The new outbox address.\n     */\n    event UpdatedOutbox(address outboxAddress);\n    /**\n     * @notice Modifier that restricts access to the function to the remote switchboard.\n     */\n    modifier onlyRemoteSwitchboard() override {\n        if (msg.sender != address(bridge__)) revert InvalidSender();\n        address l2Sender = outbox__.l2ToL1Sender();\n        if (l2Sender != remoteNativeSwitchboard) revert InvalidSender();\n        _;\n    }\n    /**\n     * @dev Constructor function for initializing the NativeBridge contract\n     * @param chainSlug_ The identifier of the current chain in the system\n     * @param inbox_ The address of the Arbitrum Inbox contract\n     * @param owner_ The address of the owner of the NativeBridge contract\n     * @param socket_ The address of the socket contract\n     * @param bridge_ The address of the bridge contract\n     * @param outbox_ The address of the Arbitrum Outbox contract\n     */\n    constructor(\n        uint32 chainSlug_,\n        address inbox_,\n        address owner_,\n        address socket_,\n        address bridge_,\n        address outbox_,\n        ISignatureVerifier signatureVerifier_\n    )\n        AccessControlExtended(owner_)\n        NativeSwitchboardBase(socket_, chainSlug_, signatureVerifier_)\n    {\n        inbox__ = IInbox(inbox_);\n\n        bridge__ = IBridge(bridge_);\n        outbox__ = IOutbox(outbox_);\n\n        remoteRefundAddress = msg.sender;\n        callValueRefundAddress = msg.sender;\n    }\n\n    /**\n\n    \n        \n          \n    \n\n        \n        Expand All\n    \n    @@ -122,20 +99,18 @@ contract ArbitrumL1Switchboard is NativeSwitchboardBase {\n  \n     * @notice This function is used to initiate a native confirmation.\n     *         this is invoked in L1 to L2 and L2 to L1 paths\n     *\n     * @param packetId_ (bytes32) The ID of the packet to confirm.\n     * @param maxSubmissionCost_ (uint256) The maximum submission cost for the retryable ticket.\n     * @param maxGas_ (uint256) The maximum gas allowed for the retryable ticket.\n     * @param gasPriceBid_ (uint256) The gas price bid for the retryable ticket.\n     * @dev     encodes the remote call and creates a retryable ticket using the inbox__ contract.\n     *          Finally, it emits the InitiatedNativeConfirmation event.\n     */\n    function initiateNativeConfirmation(\n        bytes32 packetId_,\n        uint256 maxSubmissionCost_,\n        uint256 maxGas_,\n        uint256 gasPriceBid_\n    ) external payable {\n        bytes memory data = _encodeRemoteCall(packetId_);\n\n        // to avoid stack too deep\n        address callValueRefund = callValueRefundAddress;\n        address remoteRefund = remoteRefundAddress;\n\n        inbox__.createRetryableTicket{value: msg.value}(\n            remoteNativeSwitchboard,\n            0, // no value needed for receivePacket\n            maxSubmissionCost_,\n            remoteRefund,\n            callValueRefund,\n            maxGas_,\n            gasPriceBid_,\n            data\n\n    \n        \n          \n    \n\n        \n        Expand All\n    \n    @@ -160,26 +135,6 @@ contract ArbitrumL1Switchboard is NativeSwitchboardBase {\n  \n        );\n        emit InitiatedNativeConfirmation(packetId_);\n    }\n    /**\n     * @notice This function is used to encode data to create retryableTicket on inbox\n     * @param packetId_ (bytes32): The ID of the packet to confirm.\n     * @return data encoded-data (packetId)\n     * @dev  encodes the remote call used to create a retryable ticket using the inbox__ contract.\n     */\n    function _encodeRemoteCall(\n        bytes32 packetId_\n    ) internal view returns (bytes memory data) {\n        data = abi.encodeWithSelector(\n            this.receivePacket.selector,\n            packetId_,\n            _getRoot(packetId_)\n        );\n    }\n\n    /**\n     * @notice This function updates the remote and call value refund addresses for the contract.\n     *         Only users with the GOVERNANCE_ROLE can call this function.\n     * @param remoteRefundAddress_  (address): The new address that will be used to refund remote tokens.\n     * @param callValueRefundAddress_ (address): The new address that will be used to refund call values.\n     * @dev  Ensures that only users with the GOVERNANCE_ROLE can call this function.\n     */\n    function updateRefundAddresses(\n        address remoteRefundAddress_,\n        address callValueRefundAddress_\n    ) external onlyRole(GOVERNANCE_ROLE) {\n        remoteRefundAddress = remoteRefundAddress_;\n        callValueRefundAddress = callValueRefundAddress_;\n\n        emit UpdatedRefundAddresses(\n            remoteRefundAddress_,\n            callValueRefundAddress_\n        );\n    }\n\n    /**\n     * @notice updates the address of the inbox contract that is used to communicate with the Arbitrum Rollup.\n     * @dev This function can only be called by a user with the GOVERNANCE_ROLE.\n\n    \n          \n            \n    \n\n          \n          Expand Down\n    \n    \n  \n     * @param inbox_ address of new inbox to be updated\n     */\n    function updateInboxAddresses(\n        address inbox_\n    ) external onlyRole(GOVERNANCE_ROLE) {\n        inbox__ = IInbox(inbox_);\n        emit UpdatedInboxAddress(inbox_);\n    }\n    /**\n     * @notice updates the address of the bridge contract that is used to communicate with the Arbitrum Rollup.\n     * @dev This function can only be called by a user with the GOVERNANCE_ROLE.\n     * @param bridgeAddress_ address of new bridge to be updated\n     */\n    function updateBridge(\n        address bridgeAddress_\n    ) external onlyRole(GOVERNANCE_ROLE) {\n        bridge__ = IBridge(bridgeAddress_);\n        emit UpdatedBridge(bridgeAddress_);\n    }\n    /**\n     * @notice Updates the address of the outbox__ contract that this contract is configured to use.\n     * @param outboxAddress_ The address of the new outbox__ contract to use.\n     * @dev This function can only be called by an address with the GOVERNANCE_ROLE.\n     * @dev Emits an UpdatedOutbox event with the updated outboxAddress_.\n     */\n    function updateOutbox(\n        address outboxAddress_\n    ) external onlyRole(GOVERNANCE_ROLE) {\n        outbox__ = IOutbox(outboxAddress_);\n        emit UpdatedOutbox(outboxAddress_);\n    }\n}",
        "after": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.7;\nimport \"openzeppelin-contracts/contracts/vendor/arbitrum/IBridge.sol\";\nimport \"openzeppelin-contracts/contracts/vendor/arbitrum/IInbox.sol\";\nimport \"openzeppelin-contracts/contracts/vendor/arbitrum/IOutbox.sol\";\nimport \"./NativeSwitchboardBase.sol\";\n/**\n * @title ArbitrumL1Switchboard\n * @dev This contract is a switchboard contract for the Arbitrum chain that handles packet attestation and actions on the L1 to Arbitrum and\n * Arbitrum to L1 path.\n * This contract inherits base functions from NativeSwitchboardBase, including fee calculation,\n * trip and untrip actions, and limit setting functions.\n */\ncontract ArbitrumL1Switchboard is NativeSwitchboardBase {\n    /**\n     * @notice An interface for receiving incoming messages from the Arbitrum chain.\n     */\n\n    \n        \n          \n    \n\n        \n        Expand All\n    \n    @@ -45,16 +35,6 @@ contract ArbitrumL1Switchboard is NativeSwitchboardBase {\n  \n    IInbox public inbox__;\n    /**\n     * @notice An interface for the Arbitrum-to-Ethereum bridge.\n     */\n    IBridge public bridge__;\n    /**\n     * @notice An interface for the Ethereum-to-Arbitrum outbox.\n     */\n    IOutbox public outbox__;\n    /**\n     * @notice Event emitted when the inbox address is updated.\n     * @param inbox The new inbox address.\n     */\n    event UpdatedInboxAddress(address inbox);\n\n    /**\n     * @notice Event emitted when the bridge address is updated.\n     * @param bridgeAddress The new bridge address.\n\n    \n          \n            \n    \n\n          \n          Expand Down\n          \n            \n    \n\n          \n          Expand Up\n    \n    @@ -102,9 +82,6 @@ contract ArbitrumL1Switchboard is NativeSwitchboardBase {\n  \n     */\n    event UpdatedBridge(address bridgeAddress);\n    /**\n     * @notice Event emitted when the outbox address is updated.\n     * @param outboxAddress The new outbox address.\n     */\n    event UpdatedOutbox(address outboxAddress);\n    /**\n     * @notice Modifier that restricts access to the function to the remote switchboard.\n     */\n    modifier onlyRemoteSwitchboard() override {\n        if (msg.sender != address(bridge__)) revert InvalidSender();\n        address l2Sender = outbox__.l2ToL1Sender();\n        if (l2Sender != remoteNativeSwitchboard) revert InvalidSender();\n        _;\n    }\n    /**\n     * @dev Constructor function for initializing the NativeBridge contract\n     * @param chainSlug_ The identifier of the current chain in the system\n     * @param inbox_ The address of the Arbitrum Inbox contract\n     * @param owner_ The address of the owner of the NativeBridge contract\n     * @param socket_ The address of the socket contract\n     * @param bridge_ The address of the bridge contract\n     * @param outbox_ The address of the Arbitrum Outbox contract\n     */\n    constructor(\n        uint32 chainSlug_,\n        address inbox_,\n        address owner_,\n        address socket_,\n        address bridge_,\n        address outbox_,\n        ISignatureVerifier signatureVerifier_\n    )\n        AccessControlExtended(owner_)\n        NativeSwitchboardBase(socket_, chainSlug_, signatureVerifier_)\n    {\n        inbox__ = IInbox(inbox_);\n\n        bridge__ = IBridge(bridge_);\n        outbox__ = IOutbox(outbox_);\n    }\n\n    /**\n\n    \n        \n          \n    \n\n        \n        Expand All\n    \n    @@ -122,20 +99,18 @@ contract ArbitrumL1Switchboard is NativeSwitchboardBase {\n  \n     * @notice This function is used to initiate a native confirmation.\n     *         this is invoked in L1 to L2 and L2 to L1 paths\n     *\n     * @param packetId_ (bytes32) The ID of the packet to confirm.\n     * @param maxSubmissionCost_ (uint256) The maximum submission cost for the retryable ticket.\n     * @param maxGas_ (uint256) The maximum gas allowed for the retryable ticket.\n     * @param gasPriceBid_ (uint256) The gas price bid for the retryable ticket.\n     * @dev     encodes the remote call and creates a retryable ticket using the inbox__ contract.\n     *          Finally, it emits the InitiatedNativeConfirmation event.\n     */\n    function initiateNativeConfirmation(\n        bytes32 packetId_,\n        uint256 maxSubmissionCost_,\n        uint256 maxGas_,\n        uint256 gasPriceBid_,\n        address callValueRefundAddress_,\n        address remoteRefundAddress_\n    ) external payable {\n        bytes memory data = _encodeRemoteCall(packetId_);\n\n        inbox__.createRetryableTicket{value: msg.value}(\n            remoteNativeSwitchboard,\n            0, // no value needed for receivePacket\n            maxSubmissionCost_,\n            remoteRefundAddress_,\n            callValueRefundAddress_,\n            maxGas_,\n            gasPriceBid_,\n            data\n\n    \n        \n          \n    \n\n        \n        Expand All\n    \n    @@ -160,26 +135,6 @@ contract ArbitrumL1Switchboard is NativeSwitchboardBase {\n  \n        );\n        emit InitiatedNativeConfirmation(packetId_);\n    }\n    /**\n     * @notice This function is used to encode data to create retryableTicket on inbox\n     * @param packetId_ (bytes32): The ID of the packet to confirm.\n     * @return data encoded-data (packetId)\n     * @dev  encodes the remote call used to create a retryable ticket using the inbox__ contract.\n     */\n    function _encodeRemoteCall(\n        bytes32 packetId_\n    ) internal view returns (bytes memory data) {\n        data = abi.encodeWithSelector(\n            this.receivePacket.selector,\n            packetId_,\n            _getRoot(packetId_)\n        );\n    }\n\n    /**\n     * @notice updates the address of the inbox contract that is used to communicate with the Arbitrum Rollup.\n     * @dev This function can only be called by a user with the GOVERNANCE_ROLE.\n\n    \n          \n            \n    \n\n          \n          Expand Down\n    \n    \n  \n     * @param inbox_ address of new inbox to be updated\n     */\n    function updateInboxAddresses(\n        address inbox_\n    ) external onlyRole(GOVERNANCE_ROLE) {\n        inbox__ = IInbox(inbox_);\n        emit UpdatedInboxAddress(inbox_);\n    }\n    /**\n     * @notice updates the address of the bridge contract that is used to communicate with the Arbitrum Rollup.\n     * @dev This function can only be called by a user with the GOVERNANCE_ROLE.\n     * @param bridgeAddress_ address of new bridge to be updated\n     */\n    function updateBridge(\n        address bridgeAddress_\n    ) external onlyRole(GOVERNANCE_ROLE) {\n        bridge__ = IBridge(bridgeAddress_);\n        emit UpdatedBridge(bridgeAddress_);\n    }\n    /**\n     * @notice Updates the address of the outbox__ contract that this contract is configured to use.\n     * @param outboxAddress_ The address of the new outbox__ contract to use.\n     * @dev This function can only be called by an address with the GOVERNANCE_ROLE.\n     * @dev Emits an UpdatedOutbox event with the updated outboxAddress_.\n     */\n    function updateOutbox(\n        address outboxAddress_\n    ) external onlyRole(GOVERNANCE_ROLE) {\n        outbox__ = IOutbox(outboxAddress_);\n        emit UpdatedOutbox(outboxAddress_);\n    }\n}"
    },
    {
        "tag": "bad randomness",
        "url": "https://github.com/smartcontractkit/chainlink-automation-templates/commit/3744fff36c65b3b6f5ce6de6171cce83f51b7f52",
        "file": "packages/batch-nft-reveal/contracts/NFTCollection.sol\n",
        "before": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\nimport \"@chainlink/contracts/src/v0.8/VRFConsumerBase.sol\";\nimport \"@chainlink/contracts/src/v0.8/KeeperCompatible.sol\";\nimport \"base64-sol/base64.sol\";\nimport \"./interfaces/IERC20.sol\";\ncontract NFTCollection is\n    Ownable,\n    ERC721,\n    VRFConsumerBase,\n    KeeperCompatibleInterface\n{\n    // STRUCTS\n    struct Metadata {\n        uint256 startIndex;\n        uint256 endIndex;\n        uint256 entropy;\n    }\n    // IMMUTABLE STORAGE\n    uint256 public immutable maxSupply;\n    uint256 public immutable mintCost;\n    address public immutable linkToken;\n    uint256 internal immutable linkFee;\n    bytes32 internal immutable keyHash;\n    // MUTABLE STORAGE\n    uint256 public totalSupply = 0;\n    uint256 public revealedCount = 0;\n    uint256 public revealBatchSize;\n    uint256 public revealInterval;\n    uint256 public lastRevealed;\n    bool public pendingReveal = false;\n    Metadata[] public metadatas;\n    // ERRORS\n    error InvalidAmount();\n    error MaxSupplyReached();\n    error InsufficientFunds();\n    error RevealCriteriaNotMet();\n    error InsufficientLINK();\n    error WithdrawProceedsFailed();\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        uint256 _maxSupply,\n        uint256 _mintCost,\n        uint256 _revealBatchSize,\n        uint256 _revealInterval,\n        address _vrfCoordinator,\n        address _linkToken,\n        uint256 _linkFee,\n        bytes32 _linkKeyHash\n    ) ERC721(_name, _symbol) VRFConsumerBase(_vrfCoordinator, _linkToken) {\n        maxSupply = _maxSupply;\n        mintCost = _mintCost;\n        revealBatchSize = _revealBatchSize;\n        revealInterval = _revealInterval;\n        linkToken = _linkToken;\n        linkFee = _linkFee;\n        keyHash = _linkKeyHash;\n    }\n    // ACTIONS\n    function mint(uint256 _amount) external payable {\n        if (_amount == 0) {\n            revert InvalidAmount();\n        }\n        if (totalSupply + _amount >= maxSupply) {\n            revert MaxSupplyReached();\n        }\n        if (msg.value < mintCost * _amount) {\n            revert InsufficientFunds();\n        }\n        for (uint256 i = 1; i <= _amount; i++) {\n            _safeMint(msg.sender, totalSupply + i);\n        }\n        totalSupply += _amount;\n    }\n    function withdrawProceeds() external onlyOwner {\n        (bool sent, ) = payable(owner()).call{value: address(this).balance}(\"\");\n        if (!sent) {\n            revert WithdrawProceedsFailed();\n        }\n    }\n    // GETTERS\n    function tokenURI(uint256 tokenId)\n        public\n        view\n        override\n        returns (string memory)\n    {\n        (uint256 randomness, bool metadataCleared) = _getTokenRandomness(tokenId);\n        string memory svg = _generateSVG(randomness, metadataCleared);\n        string memory svgEncoded = _svgToImageURI(svg);\n        return _formatTokenURI(svgEncoded);\n    }\n    function _getTokenRandomness(uint256 tokenId)\n        internal\n        view\n        returns (uint256 randomness, bool metadataCleared)\n    {\n        for (uint256 i = 0; i < metadatas.length; i++) {\n            if (\n                tokenId >= metadatas[i].startIndex &&\n                tokenId < metadatas[i].endIndex\n            ) {\n                randomness = uint256(\n                    keccak256(\n                        abi.encode(metadatas[i].entropy, msg.sender, tokenId)\n                    )\n                );\n                metadataCleared = true;\n            }\n\n    \n          \n            \n    \n\n          \n          Expand Down\n    \n    \n  \n        }\n    }\n    function _formatTokenURI(string memory imageURI)\n        internal\n        pure\n        returns (string memory)\n    {\n        return\n            string(\n                abi.encodePacked(\n                    \"data:application/json;base64,\",\n                    Base64.encode(\n                        bytes(\n                            abi.encodePacked(\n                                '{\"name\":\"',\n                                \"NFT\", // You can add whatever name here\n                                '\", \"description\":\"Batch-revealed NFT!\", \"attributes\":\"\", \"image\":\"',\n                                imageURI,\n                                '\"}'\n                            )\n                        )\n                    )\n                )\n            );\n    }\n    function _generateSVG(uint256 _randomness, bool _metadataCleared)\n        public\n        pure\n        returns (string memory)\n    {\n        string[3] memory parts;\n        parts[0] = '<svg xmlns=\"http://www.w3.org/2000/svg\" preserveAspectRatio=\"xMinYMin meet\" viewBox=\"0 0 350 350\"><style>.base { fill: white; font-family: serif; font-size: 8px; }</style><rect width=\"100%\" height=\"100%\" fill=\"black\" /><text x=\"10\" y=\"20\" class=\"base\">';\n        if (_metadataCleared) {\n            parts[1] = _toString(_randomness);\n        } else {\n            parts[1] = \"No randomness assigned\";\n        }\n        parts[2] = \"</text></svg>\";\n        return string(abi.encodePacked(parts[0], parts[1], parts[2]));\n    }\n    function _svgToImageURI(string memory svg)\n        internal\n        pure\n        returns (string memory)\n    {\n        string memory baseURL = \"data:image/svg+xml;base64,\";\n        string memory svgBase64Encoded = Base64.encode(bytes(string(abi.encodePacked(svg))));\n        return string(abi.encodePacked(baseURL, svgBase64Encoded));\n    }\n    function _canReveal() internal view returns (bool) {\n        uint256 unrevealedCount = totalSupply - revealedCount;\n        if (unrevealedCount == 0) {\n            return false;\n        }\n        bool batchSizeCriteria = false;\n        if (revealBatchSize > 0 && unrevealedCount >= revealBatchSize) {\n            batchSizeCriteria = true;\n        }\n        bool intervalCriteria = false;\n        if (\n            revealInterval > 0 &&\n            block.timestamp - lastRevealed > revealInterval\n        ) {\n            intervalCriteria = true;\n        }\n        return (batchSizeCriteria || intervalCriteria);\n    }\n    // VRF\n    function revealPendingMetadata() public returns (bytes32 requestId) {\n        if (!_canReveal()) {\n            revert RevealCriteriaNotMet();\n        }\n        if (IERC20(linkToken).balanceOf(address(this)) < linkFee) {\n            revert InsufficientLINK();\n        }\n        requestId = requestRandomness(keyHash, linkFee);\n        pendingReveal = true;\n    }\n    function _fulfillRandomnessForMetadata(uint256 randomness) internal {\n        metadatas.push(\n            Metadata({\n                startIndex: revealedCount + 1,\n                endIndex: totalSupply + 1,\n                entropy: randomness\n            })\n        );\n        revealedCount = totalSupply;\n        lastRevealed = block.timestamp;\n        pendingReveal = false;\n    }\n    function fulfillRandomness(bytes32, uint256 randomness)\n        internal\n        virtual\n        override\n    {\n        _fulfillRandomnessForMetadata(randomness);\n    }\n    // KEEPERS\n    function checkUpkeep(bytes calldata)\n        external\n        view\n        override\n        returns (bool upkeepNeeded, bytes memory)\n    {\n        upkeepNeeded = !pendingReveal && _canReveal();\n    }\n    function performUpkeep(bytes calldata) external override {\n        revealPendingMetadata();\n    }\n    // SETTERS\n    function setRevealBatchSize(uint256 _revealBatchSize) external onlyOwner {\n        revealBatchSize = _revealBatchSize;\n    }\n    function setRevealInterval(uint256 _revealInterval) external onlyOwner {\n        revealInterval = _revealInterval;\n    }\n    // HELPERS\n    function _toString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n}",
        "after": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\nimport \"@chainlink/contracts/src/v0.8/VRFConsumerBase.sol\";\nimport \"@chainlink/contracts/src/v0.8/KeeperCompatible.sol\";\nimport \"base64-sol/base64.sol\";\nimport \"./interfaces/IERC20.sol\";\ncontract NFTCollection is\n    Ownable,\n    ERC721,\n    VRFConsumerBase,\n    KeeperCompatibleInterface\n{\n    // STRUCTS\n    struct Metadata {\n        uint256 startIndex;\n        uint256 endIndex;\n        uint256 entropy;\n    }\n    // IMMUTABLE STORAGE\n    uint256 public immutable maxSupply;\n    uint256 public immutable mintCost;\n    address public immutable linkToken;\n    uint256 internal immutable linkFee;\n    bytes32 internal immutable keyHash;\n    // MUTABLE STORAGE\n    uint256 public totalSupply = 0;\n    uint256 public revealedCount = 0;\n    uint256 public revealBatchSize;\n    uint256 public revealInterval;\n    uint256 public lastRevealed;\n    bool public pendingReveal = false;\n    Metadata[] public metadatas;\n    // ERRORS\n    error InvalidAmount();\n    error MaxSupplyReached();\n    error InsufficientFunds();\n    error RevealCriteriaNotMet();\n    error InsufficientLINK();\n    error WithdrawProceedsFailed();\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        uint256 _maxSupply,\n        uint256 _mintCost,\n        uint256 _revealBatchSize,\n        uint256 _revealInterval,\n        address _vrfCoordinator,\n        address _linkToken,\n        uint256 _linkFee,\n        bytes32 _linkKeyHash\n    ) ERC721(_name, _symbol) VRFConsumerBase(_vrfCoordinator, _linkToken) {\n        maxSupply = _maxSupply;\n        mintCost = _mintCost;\n        revealBatchSize = _revealBatchSize;\n        revealInterval = _revealInterval;\n        linkToken = _linkToken;\n        linkFee = _linkFee;\n        keyHash = _linkKeyHash;\n    }\n    // ACTIONS\n    function mint(uint256 _amount) external payable {\n        if (_amount == 0) {\n            revert InvalidAmount();\n        }\n        if (totalSupply + _amount >= maxSupply) {\n            revert MaxSupplyReached();\n        }\n        if (msg.value < mintCost * _amount) {\n            revert InsufficientFunds();\n        }\n        for (uint256 i = 1; i <= _amount; i++) {\n            _safeMint(msg.sender, totalSupply + i);\n        }\n        totalSupply += _amount;\n    }\n    function withdrawProceeds() external onlyOwner {\n        (bool sent, ) = payable(owner()).call{value: address(this).balance}(\"\");\n        if (!sent) {\n            revert WithdrawProceedsFailed();\n        }\n    }\n    // GETTERS\n    function tokenURI(uint256 tokenId)\n        public\n        view\n        override\n        returns (string memory)\n    {\n        (uint256 randomness, bool metadataCleared) = _getTokenRandomness(tokenId);\n        string memory svg = _generateSVG(randomness, metadataCleared);\n        string memory svgEncoded = _svgToImageURI(svg);\n        return _formatTokenURI(svgEncoded);\n    }\n    function _getTokenRandomness(uint256 tokenId)\n        internal\n        view\n        returns (uint256 randomness, bool metadataCleared)\n    {\n        for (uint256 i = 0; i < metadatas.length; i++) {\n            if (\n                tokenId >= metadatas[i].startIndex &&\n                tokenId < metadatas[i].endIndex\n            ) {\n                randomness = uint256(\n                    keccak256(abi.encode(metadatas[i].entropy, tokenId))\n                );\n                metadataCleared = true;\n            }\n\n    \n          \n            \n    \n\n          \n          Expand Down\n    \n    \n  \n        }\n    }\n    function _formatTokenURI(string memory imageURI)\n        internal\n        pure\n        returns (string memory)\n    {\n        return\n            string(\n                abi.encodePacked(\n                    \"data:application/json;base64,\",\n                    Base64.encode(\n                        bytes(\n                            abi.encodePacked(\n                                '{\"name\":\"',\n                                \"NFT\", // You can add whatever name here\n                                '\", \"description\":\"Batch-revealed NFT!\", \"attributes\":\"\", \"image\":\"',\n                                imageURI,\n                                '\"}'\n                            )\n                        )\n                    )\n                )\n            );\n    }\n    function _generateSVG(uint256 _randomness, bool _metadataCleared)\n        public\n        pure\n        returns (string memory)\n    {\n        string[3] memory parts;\n        parts[0] = '<svg xmlns=\"http://www.w3.org/2000/svg\" preserveAspectRatio=\"xMinYMin meet\" viewBox=\"0 0 350 350\"><style>.base { fill: white; font-family: serif; font-size: 8px; }</style><rect width=\"100%\" height=\"100%\" fill=\"black\" /><text x=\"10\" y=\"20\" class=\"base\">';\n        if (_metadataCleared) {\n            parts[1] = _toString(_randomness);\n        } else {\n            parts[1] = \"No randomness assigned\";\n        }\n        parts[2] = \"</text></svg>\";\n        return string(abi.encodePacked(parts[0], parts[1], parts[2]));\n    }\n    function _svgToImageURI(string memory svg)\n        internal\n        pure\n        returns (string memory)\n    {\n        string memory baseURL = \"data:image/svg+xml;base64,\";\n        string memory svgBase64Encoded = Base64.encode(bytes(string(abi.encodePacked(svg))));\n        return string(abi.encodePacked(baseURL, svgBase64Encoded));\n    }\n    function _canReveal() internal view returns (bool) {\n        uint256 unrevealedCount = totalSupply - revealedCount;\n        if (unrevealedCount == 0) {\n            return false;\n        }\n        bool batchSizeCriteria = false;\n        if (revealBatchSize > 0 && unrevealedCount >= revealBatchSize) {\n            batchSizeCriteria = true;\n        }\n        bool intervalCriteria = false;\n        if (\n            revealInterval > 0 &&\n            block.timestamp - lastRevealed > revealInterval\n        ) {\n            intervalCriteria = true;\n        }\n        return (batchSizeCriteria || intervalCriteria);\n    }\n    // VRF\n    function revealPendingMetadata() public returns (bytes32 requestId) {\n        if (!_canReveal()) {\n            revert RevealCriteriaNotMet();\n        }\n        if (IERC20(linkToken).balanceOf(address(this)) < linkFee) {\n            revert InsufficientLINK();\n        }\n        requestId = requestRandomness(keyHash, linkFee);\n        pendingReveal = true;\n    }\n    function _fulfillRandomnessForMetadata(uint256 randomness) internal {\n        metadatas.push(\n            Metadata({\n                startIndex: revealedCount + 1,\n                endIndex: totalSupply + 1,\n                entropy: randomness\n            })\n        );\n        revealedCount = totalSupply;\n        lastRevealed = block.timestamp;\n        pendingReveal = false;\n    }\n    function fulfillRandomness(bytes32, uint256 randomness)\n        internal\n        virtual\n        override\n    {\n        _fulfillRandomnessForMetadata(randomness);\n    }\n    // KEEPERS\n    function checkUpkeep(bytes calldata)\n        external\n        view\n        override\n        returns (bool upkeepNeeded, bytes memory)\n    {\n        upkeepNeeded = !pendingReveal && _canReveal();\n    }\n    function performUpkeep(bytes calldata) external override {\n        revealPendingMetadata();\n    }\n    // SETTERS\n    function setRevealBatchSize(uint256 _revealBatchSize) external onlyOwner {\n        revealBatchSize = _revealBatchSize;\n    }\n    function setRevealInterval(uint256 _revealInterval) external onlyOwner {\n        revealInterval = _revealInterval;\n    }\n    // HELPERS\n    function _toString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n}"
    },
    {
        "tag": "denial of service",
        "url": "https://github.com/InverseFinance/FiRM/commit/0c7808089dbd48b22e106ba2a9423c0752c752e4",
        "file": "src/BorrowController.sol",
        "before": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.13;\n/**\n@title Borrow Controller\n@notice Contract for limiting the contracts that are allowed to interact with markets\n*/\ncontract BorrowController {\n    \n    address public operator;\n    mapping(address => bool) public contractAllowlist;\n    mapping(address => uint) public dailyLimits;\n    mapping(address => mapping(uint => uint)) public dailyBorrows;\n    constructor(address _operator) {\n        operator = _operator;\n    }\n    modifier onlyOperator {\n        require(msg.sender == operator, \"Only operator\");\n        _;\n    }\n    \n    /**\n    @notice Sets the operator of the borrow controller. Only callable by the operator.\n    @param _operator The address of the new operator.\n    */\n    function setOperator(address _operator) public onlyOperator { operator = _operator; }\n    /**\n    @notice Allows a contract to use the associated market.\n    @param allowedContract The address of the allowed contract\n    */\n    function allow(address allowedContract) public onlyOperator { contractAllowlist[allowedContract] = true; }\n    /**\n    @notice Denies a contract to use the associated market\n    @param deniedContract The addres of the denied contract\n    */\n    function deny(address deniedContract) public onlyOperator { contractAllowlist[deniedContract] = false; }\n    /**\n    @notice Sets the daily borrow limit for a specific market\n    @param market The addres of the market contract\n    @param limit The daily borrow limit amount\n    */\n    function setDailyLimit(address market, uint limit) public onlyOperator { dailyLimits[market] = limit; }\n    /**\n    @notice Checks if a borrow is allowed\n    @dev Currently the borrowController checks if contracts are part of an allow list and enforces a daily limit\n    @param msgSender The message sender trying to borrow\n    @param amount The amount to be borrowed\n    @return A boolean that is true if borrowing is allowed and false if not.\n    */\n    function borrowAllowed(address msgSender, address, uint amount) public returns (bool) {\n        uint day = block.timestamp / 1 days;\n        uint dailyLimit = dailyLimits[msg.sender];\n        if(dailyLimit > 0) {\n            if(dailyBorrows[msg.sender][day] + amount > dailyLimit) {\n                return false;\n            } else {\n                dailyBorrows[msg.sender][day] += amount;\n            }\n        }\n        if(msgSender == tx.origin) return true;\n        return contractAllowlist[msgSender];\n    }\n}",
        "after": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.13;\n/**\n@title Borrow Controller\n@notice Contract for limiting the contracts that are allowed to interact with markets\n*/\ncontract BorrowController {\n    \n    address public operator;\n    mapping(address => bool) public contractAllowlist;\n    mapping(address => uint) public dailyLimits;\n    mapping(address => mapping(uint => uint)) public dailyBorrows;\n    constructor(address _operator) {\n        operator = _operator;\n    }\n    modifier onlyOperator {\n        require(msg.sender == operator, \"Only operator\");\n        _;\n    }\n    \n    /**\n    @notice Sets the operator of the borrow controller. Only callable by the operator.\n    @param _operator The address of the new operator.\n    */\n    function setOperator(address _operator) public onlyOperator { operator = _operator; }\n    /**\n    @notice Allows a contract to use the associated market.\n    @param allowedContract The address of the allowed contract\n    */\n    function allow(address allowedContract) public onlyOperator { contractAllowlist[allowedContract] = true; }\n    /**\n    @notice Denies a contract to use the associated market\n    @param deniedContract The addres of the denied contract\n    */\n    function deny(address deniedContract) public onlyOperator { contractAllowlist[deniedContract] = false; }\n    /**\n    @notice Sets the daily borrow limit for a specific market\n    @param market The addres of the market contract\n    @param limit The daily borrow limit amount\n    */\n    function setDailyLimit(address market, uint limit) public onlyOperator { dailyLimits[market] = limit; }\n    /**\n    @notice Checks if a borrow is allowed\n    @dev Currently the borrowController checks if contracts are part of an allow list and enforces a daily limit\n    @param msgSender The message sender trying to borrow\n    @param amount The amount to be borrowed\n    @return A boolean that is true if borrowing is allowed and false if not.\n    */\n    function borrowAllowed(address msgSender, address, uint amount) public returns (bool) {\n        uint day = block.timestamp / 1 days;\n        uint dailyLimit = dailyLimits[msg.sender];\n        if(dailyLimit > 0) {\n            if(dailyBorrows[msg.sender][day] + amount > dailyLimit) {\n                return false;\n            } else {\n                dailyBorrows[msg.sender][day] += amount;\n            }\n        }\n        if(msgSender == tx.origin) return true;\n        return contractAllowlist[msgSender];\n    }\n\n    /**\n    @notice Reduces the daily limit used, when a user repays debt\n    @dev This is necessary to prevent a DOS attack, where a user borrows the daily limit and immediately repays it again.\n    @param amount Amount repaid in the market\n    */\n    function onRepay(uint amount) public {\n        uint day = block.timestamp / 1 days;\n        if(dailyBorrows[msg.sender][day] < amount) {\n            dailyBorrows[msg.sender][day] = 0;\n        } else {\n            dailyBorrows[msg.sender][day] -= amount;\n        }\n    }\n}"
    },
    {
        "tag": "arithmetic",
        "url": "https://github.com/crispymangoes/uniswap-v3-limit-orders/commit/f9934fe5d5eaaf061f4dab110a7b99efda7efb20",
        "file": "src/LimitOrderRegistry.sol",
        "before": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.16;\nimport { ERC20 } from \"@solmate/tokens/ERC20.sol\";\nimport { SafeTransferLib } from \"@solmate/utils/SafeTransferLib.sol\";\nimport { AutomationCompatibleInterface } from \"@chainlink/contracts/src/v0.8/interfaces/AutomationCompatibleInterface.sol\";\nimport { Owned } from \"@solmate/auth/Owned.sol\";\nimport { UniswapV3Pool } from \"src/interfaces/uniswapV3/UniswapV3Pool.sol\";\nimport { NonFungiblePositionManager } from \"src/interfaces/uniswapV3/NonFungiblePositionManager.sol\";\nimport { ERC721Holder } from \"@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol\";\nimport { LinkTokenInterface } from \"@chainlink/contracts/src/v0.8/interfaces/LinkTokenInterface.sol\";\nimport { IKeeperRegistrar, RegistrationParams } from \"src/interfaces/chainlink/IKeeperRegistrar.sol\";\nimport { Context } from \"@openzeppelin/contracts/utils/Context.sol\";\nimport { IChainlinkAggregator } from \"src/interfaces/chainlink/IChainlinkAggregator.sol\";\n/**\n * @title Limit Order Registry\n * @notice Allows users to create decentralized limit orders.\n * @dev DO NOT PLACE LIMIT ORDERS FOR STRONGLY CORRELATED ASSETS.\n *      - If a stable coin pair were to temporarily depeg, and a user places a limit order\n *        whose tick range encompasses the normal trading tick, there is NO way to cancel the order\n *        because the order is mixed. The user would have to wait for another depeg event to happen\n *        so that the order can be fulfilled, or the order can be cancelled.\n * @author crispymangoes\n */\ncontract LimitOrderRegistry is Owned, AutomationCompatibleInterface, ERC721Holder, Context {\n    using SafeTransferLib for ERC20;\n    /*//////////////////////////////////////////////////////////////\n                             STRUCTS\n    //////////////////////////////////////////////////////////////*/\n    /**\n     * @notice Stores linked list center values, and frequently used pool values.\n     * @param centerHead Linked list center value closer to head of the list\n     * @param centerTail Linked list center value closer to tail of the list\n     * @param token0 ERC20 token0 of the pool\n     * @param token1 ERC20 token1 of the pool\n     * @param fee Uniswap V3 pool fee\n     */\n    struct PoolData {\n        uint256 centerHead;\n        uint256 centerTail;\n        ERC20 token0;\n        ERC20 token1;\n        uint24 fee;\n    }\n    /**\n     * @notice Stores information about batches of orders.\n     * @dev User orders can be batched together if they share the same target price.\n     * @param direction Determines what direction the tick must move in order for the order to be filled\n     *        - true, pool tick must INCREASE to fill this order\n     *        - false, pool tick must DECREASE to fill this order\n     * @param tickUpper The upper tick of the underlying LP position\n     * @param tickLower The lower tick of the underlying LP position\n     * @param userCount The number of users in this batch order\n     * @param batchId Unique id used to distinguish this batch order from another batch order in the past that used the same LP position\n     * @param token0Amount The amount of token0 in this order\n     * @param token1Amount The amount of token1 in this order\n     * @param head The next node in the linked list when moving toward the head\n     * @param tail The next node in the linked list when moving toward the tail\n     */\n    struct BatchOrder {\n        bool direction;\n        int24 tickUpper;\n        int24 tickLower;\n        uint64 userCount;\n        uint128 batchId;\n        uint128 token0Amount;\n        uint128 token1Amount;\n        uint256 head;\n        uint256 tail;\n    }\n    /**\n     * @notice Stores information needed for users to make claims.\n     * @param pool The Uniswap V3 pool the batch order was in\n     * @param token0Amount The amount of token0 in the order\n     * @param token1Amount The amount of token1 in the order\n     * @param feePerUser The native token fee that must be paid on order claiming\n     * @param direction The underlying order direction, used to determine input/output token of the order\n     * @param isReadyForClaim Explicit bool indicating whether or not this order is ready to be claimed\n     */\n    struct Claim {\n        UniswapV3Pool pool;\n        uint128 token0Amount; //Can either be the deposit amount or the amount got out of liquidity changing to the other token\n        uint128 token1Amount;\n        uint128 feePerUser; // Fee in terms of network native asset.\n        bool direction; //Determines the token out\n        bool isReadyForClaim;\n    }\n    /**\n     * @notice Struct used to store variables needed during order creation.\n     * @param tick The target tick of the order\n     * @param upper The upper tick of the underlying LP position\n     * @param lower The lower tick of the underlying LP position\n     * @param userTotal The total amount of assets the user has in the order\n     * @param positionId The underling LP position token id this order is adding liquidity to\n     * @param amount0 Can be the amount of assets user added to the order, based off orders direction\n     * @param amount1 Can be the amount of assets user added to the order, based off orders direction\n     */\n    struct OrderDetails {\n        int24 tick;\n        int24 upper;\n        int24 lower;\n        uint128 userTotal;\n        uint256 positionId;\n        uint128 amount0;\n        uint128 amount1;\n    }\n    /*//////////////////////////////////////////////////////////////\n                             GLOBAL STATE\n    //////////////////////////////////////////////////////////////*/\n    /**\n     * @notice Stores swap fees earned from limit order where the input token earns swap fees.\n     */\n    mapping(address => uint256) public tokenToSwapFees;\n    /**\n     * @notice Used to store claim information needed when users are claiming their orders.\n     */\n    mapping(uint128 => Claim) public claim;\n    /**\n     * @notice Stores the pools center head/tail, as well as frequently read values.\n     */\n    mapping(UniswapV3Pool => PoolData) public poolToData;\n    /**\n     * @notice Maps tick ranges to LP positions owned by this contract.\n     */\n    mapping(UniswapV3Pool => mapping(int24 => mapping(int24 => uint256))) public getPositionFromTicks; // maps pool -> lower -> upper -> positionId\n    /**\n     * @notice The minimum amount of assets required to create a `newOrder`.\n     * @dev Changeable by owner.\n     */\n    mapping(ERC20 => uint256) public minimumAssets;\n    /**\n     * @notice Approximated amount of gas needed to fulfill 1 BatchOrder.\n     * @dev Changeable by owner.\n     */\n    uint32 public upkeepGasLimit = 300_000;\n    /**\n     * @notice Approximated gas price used to fulfill orders.\n     * @dev Changeable by owner.\n     */\n    uint32 public upkeepGasPrice = 30;\n    /**\n     * @notice Max number of orders that can be filled in 1 upkeep call.\n     * @dev Changeable by owner.\n     */\n    uint16 public maxFillsPerUpkeep = 10;\n    /**\n     * @notice Value is incremented whenever a new BatchOrder is added to the `orderBook`.\n     * @dev Zero is reserved.\n     */\n    uint128 public batchCount = 1;\n    /**\n     * @notice Mapping is used to store user deposit amounts in each BatchOrder.\n     */\n    mapping(uint128 => mapping(address => uint128)) public batchIdToUserDepositAmount;\n    /**\n     * @notice The `orderBook` maps Uniswap V3 token ids to BatchOrder information.\n     * @dev Each BatchOrder contains a head and tail value which effectively,\n     *      which means BatchOrders are connected using a doubley linked list.\n     */\n    mapping(uint256 => BatchOrder) public orderBook;\n    /**\n     * @notice Chainlink Automation Registrar contract.\n     */\n    IKeeperRegistrar public registrar; // Mainnet 0xDb8e8e2ccb5C033938736aa89Fe4fa1eDfD15a1d\n    /**\n     * @notice Whether or not the contract is shutdown in case of an emergency.\n     */\n    bool public isShutdown;\n    /**\n     * @notice Chainlink Fast Gas Feed for ETH Mainnet.\n     */\n    address public fastGasFeed = 0x169E633A2D1E6c10dD91238Ba11c4A708dfEF37C;\n    /**\n     * @notice The max possible gas the owner can set for the gas limit.\n     */\n    uint32 public constant MAX_GAS_LIMIT = 750_000;\n    /**\n     * @notice The max possible gas price the owner can set for the gas price.\n     * @dev In units of gwei.\n     */\n    uint32 public constant MAX_GAS_PRICE = 1_000;\n    /**\n     * @notice The max number of orders that can be fulfilled in a single upkeep TX.\n     */\n    uint16 public constant MAX_FILLS_PER_UPKEEP = 20;\n    /**\n     * @notice The ETH Fast Gas Feed heartbeat.\n     * @dev If answer is stale, owner set gas price is used.\n     */\n    uint256 public constant FAST_GAS_HEARTBEAT = 7200;\n    /**\n     * @notice Function selector used to create V1 Upkeep versions.\n     */\n    bytes4 private constant FUNC_SELECTOR =\n        bytes4(keccak256(\"register(string,bytes,address,uint32,address,bytes,uint96,uint8,address)\"));\n    /*//////////////////////////////////////////////////////////////\n                                 MODIFIERS\n    //////////////////////////////////////////////////////////////*/\n    /**\n     * @notice Prevent a function from being called during a shutdown.\n     */\n    modifier whenNotShutdown() {\n        if (isShutdown) revert LimitOrderRegistry__ContractShutdown();\n        _;\n    }\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n    event NewOrder(address user, address pool, uint128 amount, uint128 userTotal, BatchOrder effectedOrder);\n    event ClaimOrder(address user, uint128 batchId, uint256 amount);\n    event CancelOrder(address user, uint128 amount0, uint128 amount1, BatchOrder effectedOrder);\n    event OrderFilled(uint256 batchId, address pool);\n    event ShutdownChanged(bool isShutdown);\n    event LimitOrderSetup(address pool);\n    /*//////////////////////////////////////////////////////////////\n                                 ERRORS\n    //////////////////////////////////////////////////////////////*/\n    error LimitOrderRegistry__OrderITM(int24 currentTick, int24 targetTick, bool direction);\n    error LimitOrderRegistry__PoolAlreadySetup(address pool);\n    error LimitOrderRegistry__PoolNotSetup(address pool);\n    error LimitOrderRegistry__InvalidTargetTick(int24 targetTick, int24 tickSpacing);\n    error LimitOrderRegistry__UserNotFound(address user, uint256 batchId);\n    error LimitOrderRegistry__InvalidPositionId();\n    error LimitOrderRegistry__NoLiquidityInOrder();\n    error LimitOrderRegistry__NoOrdersToFulfill();\n    error LimitOrderRegistry__CenterITM();\n    error LimitOrderRegistry__OrderNotInList(uint256 tokenId);\n    error LimitOrderRegistry__MinimumNotSet(address asset);\n    error LimitOrderRegistry__MinimumNotMet(address asset, uint256 minimum, uint256 amount);\n    error LimitOrderRegistry__InvalidTickRange(int24 upper, int24 lower);\n    error LimitOrderRegistry__ZeroFeesToWithdraw(address token);\n    error LimitOrderRegistry__ZeroNativeBalance();\n    error LimitOrderRegistry__InvalidBatchId();\n    error LimitOrderRegistry__OrderNotReadyToClaim(uint128 batchId);\n    error LimitOrderRegistry__ContractShutdown();\n    error LimitOrderRegistry__ContractNotShutdown();\n    error LimitOrderRegistry__InvalidGasLimit();\n    error LimitOrderRegistry__InvalidGasPrice();\n    error LimitOrderRegistry__InvalidFillsPerUpkeep();\n    error LimitOrderRegistry__AmountShouldBeZero();\n    error LimitOrderRegistry__DirectionMisMatch();\n    /*//////////////////////////////////////////////////////////////\n                                 ENUMS\n    //////////////////////////////////////////////////////////////*/\n    enum OrderStatus {\n        ITM,\n        OTM,\n        MIXED\n    }\n    /*//////////////////////////////////////////////////////////////\n                              IMMUTABLES\n    //////////////////////////////////////////////////////////////*/\n    ERC20 public immutable WRAPPED_NATIVE; // Mainnet 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2\n    NonFungiblePositionManager public immutable POSITION_MANAGER; // Mainnet 0xC36442b4a4522E871399CD717aBDD847Ab11FE88\n    LinkTokenInterface public immutable LINK; // Mainnet 0x514910771AF9Ca656af840dff83E8264EcF986CA\n    constructor(\n        address _owner,\n        NonFungiblePositionManager _positionManager,\n        ERC20 wrappedNative,\n        LinkTokenInterface link,\n        IKeeperRegistrar _registrar,\n        address _fastGasFeed\n    ) Owned(_owner) {\n        POSITION_MANAGER = _positionManager;\n        WRAPPED_NATIVE = wrappedNative;\n        LINK = link;\n        registrar = _registrar;\n        fastGasFeed = _fastGasFeed;\n    }\n    /*//////////////////////////////////////////////////////////////\n                              OWNER LOGIC\n    //////////////////////////////////////////////////////////////*/\n    /**\n     * @notice No input validation is done because it is in the owners best interest to choose a valid registrar.\n     */\n    function setRegistrar(IKeeperRegistrar _registrar) external onlyOwner {\n        registrar = _registrar;\n    }\n    /**\n     * @notice Allows owner to set the fills per upkeep.\n     */\n    function setMaxFillsPerUpkeep(uint16 newVal) external onlyOwner {\n        if (newVal == 0 || newVal > MAX_FILLS_PER_UPKEEP) revert LimitOrderRegistry__InvalidFillsPerUpkeep();\n        maxFillsPerUpkeep = newVal;\n    }\n    /**\n     * @notice Allows owner to setup a new limit order for a new pool.\n     * @dev New Limit orders, should have a keeper to fulfill orders.\n     * @dev If `initialUpkeepFunds` is zero, upkeep creation is skipped.\n     */\n    function setupLimitOrder(UniswapV3Pool pool, uint256 initialUpkeepFunds) external onlyOwner {\n        // Check if Limit Order is already setup for `pool`.\n        if (address(poolToData[pool].token0) != address(0)) revert LimitOrderRegistry__PoolAlreadySetup(address(pool));\n        // Create Upkeep.\n        if (initialUpkeepFunds > 0) {\n            // Owner wants to automatically create an upkeep for new pool.\n            ERC20(address(LINK)).safeTransferFrom(owner, address(this), initialUpkeepFunds);\n            if (bytes(registrar.typeAndVersion())[16] == bytes(\"1\")[0]) {\n                // Use V1 Upkeep Registration.\n                bytes memory data = abi.encodeWithSelector(\n                    FUNC_SELECTOR,\n                    \"Limit Order Registry\",\n                    abi.encode(0),\n                    address(this),\n                    uint32(maxFillsPerUpkeep * upkeepGasLimit),\n                    owner,\n                    abi.encode(pool),\n                    uint96(initialUpkeepFunds),\n                    77,\n                    address(this)\n                );\n                LINK.transferAndCall(address(registrar), initialUpkeepFunds, data);\n            } else {\n                // Use V2 Upkeep Registration.\n                ERC20(address(LINK)).safeApprove(address(registrar), initialUpkeepFunds);\n                RegistrationParams memory params = RegistrationParams({\n                    name: \"Limit Order Registry\",\n                    encryptedEmail: abi.encode(0),\n                    upkeepContract: address(this),\n                    gasLimit: uint32(maxFillsPerUpkeep * upkeepGasLimit),\n                    adminAddress: owner,\n                    checkData: abi.encode(pool),\n                    offchainConfig: abi.encode(0),\n                    amount: uint96(initialUpkeepFunds)\n                });\n                registrar.registerUpkeep(params);\n            }\n        }\n        // poolToData\n        poolToData[pool] = PoolData({\n            centerHead: 0,\n            centerTail: 0,\n            token0: ERC20(pool.token0()),\n            token1: ERC20(pool.token1()),\n            fee: pool.fee()\n        });\n        emit LimitOrderSetup(address(pool));\n    }\n    /**\n     * @notice Allows owner to set the minimum assets used to create `newOrder`s.\n     * @dev This value can be zero, but then this contract can be griefed by an attacker spamming low liquidity orders.\n     */\n    function setMinimumAssets(uint256 amount, ERC20 asset) external onlyOwner {\n        minimumAssets[asset] = amount;\n    }\n    /**\n     * @notice Allows owner to change the gas limit value used to determine the Native asset fee needed to claim orders.\n     * @dev premium should be factored into this value.\n     */\n    function setUpkeepGasLimit(uint32 gasLimit) external onlyOwner {\n        if (gasLimit > MAX_GAS_LIMIT) revert LimitOrderRegistry__InvalidGasLimit();\n        upkeepGasLimit = gasLimit;\n    }\n    /**\n     * @notice Allows owner to change the gas price used to determine the Native asset fee needed to claim orders.\n     * @dev `gasPrice` uses units of gwei.\n     */\n    function setUpkeepGasPrice(uint32 gasPrice) external onlyOwner {\n        if (gasPrice > MAX_GAS_PRICE) revert LimitOrderRegistry__InvalidGasPrice();\n        upkeepGasPrice = gasPrice;\n    }\n    /**\n     * @notice Allows owner to set the fast gas feed.\n     */\n    function setFastGasFeed(address feed) external onlyOwner {\n        fastGasFeed = feed;\n    }\n    /**\n     * @notice Allows owner to withdraw swap fees earned from the input token of orders.\n     */\n    function withdrawSwapFees(address tokenFeeIsIn) external onlyOwner {\n        uint256 fee = tokenToSwapFees[tokenFeeIsIn];\n        // Make sure there are actually fees to withdraw.\n        if (fee == 0) revert LimitOrderRegistry__ZeroFeesToWithdraw(tokenFeeIsIn);\n        tokenToSwapFees[tokenFeeIsIn] = 0;\n        ERC20(tokenFeeIsIn).safeTransfer(owner, fee);\n    }\n    /**\n     * @notice Allows owner to withdraw wrapped native and native assets from this contract.\n     */\n    function withdrawNative() external onlyOwner {\n        uint256 wrappedNativeBalance = WRAPPED_NATIVE.balanceOf(address(this));\n        uint256 nativeBalance = address(this).balance;\n        // Make sure there is something to withdraw.\n        if (wrappedNativeBalance == 0 && nativeBalance == 0) revert LimitOrderRegistry__ZeroNativeBalance();\n        WRAPPED_NATIVE.safeTransfer(owner, WRAPPED_NATIVE.balanceOf(address(this)));\n        payable(owner).transfer(address(this).balance);\n    }\n    /**\n     * @notice Shutdown the cellar. Used in an emergency or if the cellar has been deprecated.\n     */\n    function initiateShutdown() external whenNotShutdown onlyOwner {\n        isShutdown = true;\n        emit ShutdownChanged(true);\n    }\n    /**\n     * @notice Restart the cellar.\n     */\n    function liftShutdown() external onlyOwner {\n        if (!isShutdown) revert LimitOrderRegistry__ContractNotShutdown();\n        isShutdown = false;\n        emit ShutdownChanged(false);\n    }\n    /*//////////////////////////////////////////////////////////////\n                        USER ORDER MANAGEMENT LOGIC\n    //////////////////////////////////////////////////////////////*/\n    /**\n     * @notice Creates a new limit order for a specific pool.\n     * @dev Limit orders can be created to buy either token0, or token1 of the pool.\n     * @param pool the Uniswap V3 pool to create a limit order on.\n     * @param targetTick the tick, that when `pool`'s tick passes, the order will be completely fulfilled\n     * @param amount the amount of the input token to sell for the desired token out\n     * @param direction bool indicating what the desired token out is\n     *                  - true  token in = token0 ; token out = token1\n     *                  - false token in = token1 ; token out = token0\n     * @param startingNode an NFT position id indicating where this contract should start searching for a spot in the list\n     *                     - can be zero which defaults to starting the search at center of list\n     * @dev reverts if\n     *      - pool is not setup\n     *      - targetTick is not divisible by the pools tick spacing\n     *      - the new order would be ITM\n     *      - the new order does not meet minimum liquidity requirements\n     *      - transferFrom fails\n     * @dev Emits a `NewOrder` event which contains meta data about the order including the orders `batchId`(which is used for claiming/cancelling).\n     */\n    function newOrder(\n        UniswapV3Pool pool,\n        int24 targetTick,\n        uint128 amount,\n        bool direction,\n        uint256 startingNode\n    ) external whenNotShutdown returns (uint128) {\n        if (address(poolToData[pool].token0) == address(0)) revert LimitOrderRegistry__PoolNotSetup(address(pool));\n        OrderDetails memory details;\n        address sender = _msgSender();\n        (, details.tick, , , , , ) = pool.slot0();\n        // Determine upper and lower ticks.\n        {\n            int24 tickSpacing = pool.tickSpacing();\n            // Make sure targetTick is divisible by spacing.\n            if (targetTick % tickSpacing != 0) revert LimitOrderRegistry__InvalidTargetTick(targetTick, tickSpacing);\n            if (direction) {\n                details.upper = targetTick;\n                details.lower = targetTick - tickSpacing;\n            } else {\n                details.upper = targetTick + tickSpacing;\n                details.lower = targetTick;\n            }\n        }\n        // Validate lower, upper,and direction.\n        {\n            OrderStatus status = _getOrderStatus(details.tick, details.lower, details.upper, direction);\n            if (status != OrderStatus.OTM) revert LimitOrderRegistry__OrderITM(details.tick, targetTick, direction);\n        }\n        // Transfer assets into contract before setting any state.\n        {\n            ERC20 assetIn;\n            if (direction) assetIn = poolToData[pool].token0;\n            else assetIn = poolToData[pool].token1;\n            _enforceMinimumLiquidity(amount, assetIn);\n            assetIn.safeTransferFrom(sender, address(this), amount);\n        }\n        // Get the position id.\n        details.positionId = getPositionFromTicks[pool][details.lower][details.upper];\n        if (direction) details.amount0 = amount;\n        else details.amount1 = amount;\n        if (details.positionId == 0) {\n            // Create new LP position(which adds liquidity)\n            PoolData memory data = poolToData[pool];\n            details.positionId = _mintPosition(\n                data,\n                details.upper,\n                details.lower,\n                details.amount0,\n                details.amount1,\n                direction\n            );\n            // Add it to the list.\n            _addPositionToList(data, startingNode, targetTick, details.positionId);\n            // Set new orders upper and lower tick.\n            orderBook[details.positionId].tickLower = details.lower;\n            orderBook[details.positionId].tickUpper = details.upper;\n            // Setup BatchOrder, setting batchId, direction.\n            _setupOrder(direction, details.positionId);\n            // Update token0Amount, token1Amount, batchIdToUserDepositAmount mapping.\n            details.userTotal = _updateOrder(details.positionId, sender, amount);\n            // Update the center values if need be.\n            _updateCenter(pool, details.positionId, details.tick, details.upper, details.lower);\n            // Update getPositionFromTicks since we have a new LP position.\n            getPositionFromTicks[pool][details.lower][details.upper] = details.positionId;\n        } else {\n            // Check if the position id is already being used in List.\n            BatchOrder memory order = orderBook[details.positionId];\n            if (order.token0Amount > 0 || order.token1Amount > 0) {\n                // Check that supplied direction and order.direction are the same.\n                if (direction != order.direction) revert LimitOrderRegistry__DirectionMisMatch();\n                // Need to add liquidity.\n                PoolData memory data = poolToData[pool];\n                _addToPosition(data, details.positionId, details.amount0, details.amount1, direction);\n                // Update token0Amount, token1Amount, batchIdToUserDepositAmount mapping.\n                details.userTotal = _updateOrder(details.positionId, sender, amount);\n            } else {\n                // We already have an LP position with given tick ranges, but it is not in linked list.\n                PoolData memory data = poolToData[pool];\n                // Add it to the list.\n                _addPositionToList(data, startingNode, targetTick, details.positionId);\n                // Setup BatchOrder, setting batchId, direction.\n                _setupOrder(direction, details.positionId);\n                // Need to add liquidity.\n                _addToPosition(data, details.positionId, details.amount0, details.amount1, direction);\n                // Update token0Amount, token1Amount, batchIdToUserDepositAmount mapping.\n                details.userTotal = _updateOrder(details.positionId, sender, amount);\n                // Update the center values if need be.\n                _updateCenter(pool, details.positionId, details.tick, details.upper, details.lower);\n            }\n        }\n        uint128 batchId = orderBook[details.positionId].batchId;\n        emit NewOrder(sender, address(pool), amount, details.userTotal, orderBook[details.positionId]);\n        return batchId;\n    }\n    /**\n     * @notice Users can claim fulfilled orders by passing in the `batchId` corresponding to the order they want to claim.\n     * @param batchId the batchId corresponding to a fulfilled order to claim\n     * @param user the address of the user in the order to claim for\n     * @dev Caller must either approve this contract to spend their Wrapped Native token, and have at least `getFeePerUser` tokens in their wallet.\n     *      Or caller must send `getFeePerUser` value with this call.\n     */\n    function claimOrder(uint128 batchId, address user) external payable returns (ERC20, uint256) {\n        Claim storage userClaim = claim[batchId];\n        if (!userClaim.isReadyForClaim) revert LimitOrderRegistry__OrderNotReadyToClaim(batchId);\n        uint256 depositAmount = batchIdToUserDepositAmount[batchId][user];\n        if (depositAmount == 0) revert LimitOrderRegistry__UserNotFound(user, batchId);\n        // Zero out user balance.\n        delete batchIdToUserDepositAmount[batchId][user];\n        // Calculate owed amount.\n        uint256 totalTokenDeposited;\n        uint256 totalTokenOut;\n        ERC20 tokenOut;\n        if (userClaim.direction) {\n            totalTokenDeposited = userClaim.token0Amount;\n            totalTokenOut = userClaim.token1Amount;\n            tokenOut = poolToData[userClaim.pool].token1;\n        } else {\n            totalTokenDeposited = userClaim.token1Amount;\n            totalTokenOut = userClaim.token0Amount;\n            tokenOut = poolToData[userClaim.pool].token0;\n        }\n        uint256 owed = (totalTokenOut * depositAmount) / totalTokenDeposited;\n        // Transfer tokens owed to user.\n        tokenOut.safeTransfer(user, owed);\n        // Transfer fee in.\n        address sender = _msgSender();\n        if (msg.value >= userClaim.feePerUser) {\n            // refund if necessary.\n            uint256 refund = msg.value - userClaim.feePerUser;\n            if (refund > 0) payable(sender).transfer(refund);\n        } else {\n            WRAPPED_NATIVE.safeTransferFrom(sender, address(this), userClaim.feePerUser);\n            // If value is non zero send it back to caller.\n            if (msg.value > 0) payable(sender).transfer(msg.value);\n        }\n        emit ClaimOrder(user, batchId, owed);\n        return (tokenOut, owed);\n    }\n    /**\n     * @notice Allows users to cancel orders as long as they are completely OTM.\n     * @param pool the Uniswap V3 pool that contains the limit order to cancel\n     * @param targetTick the targetTick of the order you want to cancel\n     * @param direction bool indication the direction of the order\n     * @dev This logic will send ALL the swap fees from a position to the last person that cancels the order.\n     */\n    function cancelOrder(\n        UniswapV3Pool pool,\n        int24 targetTick,\n        bool direction\n    ) external returns (uint128 amount0, uint128 amount1, uint128 batchId) {\n        uint256 positionId;\n        {\n            // Make sure order is OTM.\n            (, int24 tick, , , , , ) = pool.slot0();\n            // Determine upper and lower ticks.\n            int24 upper;\n            int24 lower;\n            {\n                int24 tickSpacing = pool.tickSpacing();\n                // Make sure targetTick is divisible by spacing.\n                if (targetTick % tickSpacing != 0)\n                    revert LimitOrderRegistry__InvalidTargetTick(targetTick, tickSpacing);\n                if (direction) {\n                    upper = targetTick;\n                    lower = targetTick - tickSpacing;\n                } else {\n                    upper = targetTick + tickSpacing;\n                    lower = targetTick;\n                }\n            }\n            // Validate lower, upper,and direction. Make sure order is not ITM or MIXED\n            {\n                OrderStatus status = _getOrderStatus(tick, lower, upper, direction);\n                if (status != OrderStatus.OTM) revert LimitOrderRegistry__OrderITM(tick, targetTick, direction);\n            }\n            // Get the position id.\n            positionId = getPositionFromTicks[pool][lower][upper];\n            if (positionId == 0) revert LimitOrderRegistry__InvalidPositionId();\n        }\n        uint256 liquidityPercentToTake;\n        // Get the users deposit amount in the order.\n        BatchOrder storage order = orderBook[positionId];\n        if (order.batchId == 0) revert LimitOrderRegistry__InvalidBatchId();\n        address sender = _msgSender();\n        {\n            batchId = order.batchId;\n            uint128 depositAmount = batchIdToUserDepositAmount[batchId][sender];\n            if (depositAmount == 0) revert LimitOrderRegistry__UserNotFound(sender, batchId);\n            // Remove one from the userCount.\n            order.userCount--;\n            // Zero out user balance.\n            delete batchIdToUserDepositAmount[batchId][sender];\n            uint128 orderAmount;\n            if (order.direction) {\n                orderAmount = order.token0Amount;\n                if (orderAmount == depositAmount) {\n                    liquidityPercentToTake = 1e18;\n                    // Update order tokenAmount.\n                    order.token0Amount = 0;\n                } else {\n                    liquidityPercentToTake = (1e18 * depositAmount) / orderAmount;\n                    // Update order tokenAmount.\n                    order.token0Amount = orderAmount - depositAmount;\n                }\n            } else {\n                orderAmount = order.token1Amount;\n                if (orderAmount == depositAmount) {\n                    liquidityPercentToTake = 1e18;\n                    // Update order tokenAmount.\n                    order.token1Amount = 0;\n                } else {\n                    liquidityPercentToTake = (1e18 * depositAmount) / orderAmount;\n                    // Update order tokenAmount.\n                    order.token1Amount = orderAmount - depositAmount;\n                }\n            }\n            (amount0, amount1) = _takeFromPosition(positionId, pool, liquidityPercentToTake);\n            emit CancelOrder(sender, amount0, amount1, order);\n            if (liquidityPercentToTake == 1e18) {\n                _removeOrderFromList(positionId, pool, order);\n                // Zero out balances for cancelled order.\n                order.token0Amount = 0;\n                order.token1Amount = 0;\n                order.batchId = 0;\n            }\n        }\n        if (order.direction) {\n            if (amount0 > 0) poolToData[pool].token0.safeTransfer(sender, amount0);\n            else revert LimitOrderRegistry__NoLiquidityInOrder();\n            if (amount1 > 0) revert LimitOrderRegistry__AmountShouldBeZero();\n        } else {\n            if (amount1 > 0) poolToData[pool].token1.safeTransfer(sender, amount1);\n            else revert LimitOrderRegistry__NoLiquidityInOrder();\n            if (amount0 > 0) revert LimitOrderRegistry__AmountShouldBeZero();\n        }\n    }\n    /*//////////////////////////////////////////////////////////////\n                     CHAINLINK AUTOMATION LOGIC\n    //////////////////////////////////////////////////////////////*/\n    /**\n     * @notice Returned `performData` simply contains a bool indicating which direction in the `orderBook` has orders that need to be fulfilled.\n     */\n    function checkUpkeep(bytes calldata checkData) external view returns (bool upkeepNeeded, bytes memory performData) {\n        UniswapV3Pool pool = abi.decode(checkData, (UniswapV3Pool));\n        (, int24 currentTick, , , , , ) = pool.slot0();\n        PoolData memory data = poolToData[pool];\n        BatchOrder memory order;\n        OrderStatus status;\n        bool walkDirection;\n        if (data.centerHead != 0) {\n            // centerHead is set, check if it is ITM.\n            order = orderBook[data.centerHead];\n            status = _getOrderStatus(currentTick, order.tickLower, order.tickUpper, order.direction);\n            if (status == OrderStatus.ITM) {\n                walkDirection = true; // Walk towards head of list.\n                upkeepNeeded = true;\n                performData = abi.encode(pool, walkDirection);\n                return (upkeepNeeded, performData);\n            }\n        }\n        if (data.centerTail != 0) {\n            // If walk direction has not been set, then we know, no head orders are ITM.\n            // So check tail orders.\n            order = orderBook[data.centerTail];\n            status = _getOrderStatus(currentTick, order.tickLower, order.tickUpper, order.direction);\n            if (status == OrderStatus.ITM) {\n                walkDirection = false; // Walk towards tail of list.\n                upkeepNeeded = true;\n                performData = abi.encode(pool, walkDirection);\n                return (upkeepNeeded, performData);\n            }\n        }\n        return (false, abi.encode(0));\n    }\n    /**\n     * @notice Callable by anyone, as long as there are orders ITM, that need to be fulfilled.\n     * @dev Does not use _removeOrderFromList, so that the center head/tail\n     *      value is not updated every single time and order is fulfilled, instead we just update it once at the end.\n     */\n    function performUpkeep(bytes calldata performData) external {\n        (UniswapV3Pool pool, bool walkDirection) = abi.decode(performData, (UniswapV3Pool, bool));\n        if (address(poolToData[pool].token0) == address(0)) revert LimitOrderRegistry__PoolNotSetup(address(pool));\n        PoolData storage data = poolToData[pool];\n        // Estimate gas cost.\n        uint256 estimatedFee = uint256(upkeepGasLimit * getGasPrice());\n        (, int24 currentTick, , , , , ) = pool.slot0();\n        bool orderFilled;\n        // Fulfill orders.\n        uint256 target = walkDirection ? data.centerHead : data.centerTail;\n        for (uint256 i; i < maxFillsPerUpkeep; ++i) {\n            if (target == 0) break;\n            BatchOrder storage order = orderBook[target];\n            OrderStatus status = _getOrderStatus(currentTick, order.tickLower, order.tickUpper, order.direction);\n            if (status == OrderStatus.ITM) {\n                _fulfillOrder(target, pool, order, estimatedFee);\n                target = walkDirection ? order.head : order.tail;\n                // Reconnect List and Zero out orders head and tail values removing order from the list.\n                orderBook[order.tail].head = order.head;\n                orderBook[order.head].tail = order.tail;\n                order.head = 0;\n                order.tail = 0;\n                // Update bool to indicate batch order is ready to handle claims.\n                claim[order.batchId].isReadyForClaim = true;\n                // Zero out orders batch id.\n                order.batchId = 0;\n                // Reset user count.\n                order.userCount = 0;\n                orderFilled = true;\n            } else break;\n        }\n        if (!orderFilled) revert LimitOrderRegistry__NoOrdersToFulfill();\n        // Continue walking the list towards head/tail until we find the next order that matches walk direction.\n        // Then update center.\n        while (target != 0) {\n            // Note use storage here because memory makes the contract too large.\n            BatchOrder storage order = orderBook[target];\n            if (order.direction == walkDirection) break;\n            target = walkDirection ? order.head : order.tail;\n        }\n        if (walkDirection) {\n            data.centerHead = target;\n            // Need to reconnect list.\n            orderBook[data.centerTail].head = target;\n            if (target != 0) orderBook[target].tail = data.centerTail;\n        } else {\n            data.centerTail = target;\n            // Need to reconnect list.\n            orderBook[data.centerHead].tail = target;\n            if (target != 0) orderBook[target].head = data.centerHead;\n        }\n    }\n    /*//////////////////////////////////////////////////////////////\n                     INTERNAL ORDER LOGIC\n    //////////////////////////////////////////////////////////////*/\n    /**\n     * @notice Check if a given Uniswap V3 position is already in the `orderBook`.\n     * @dev Looks at Nodes head and tail, and checks for edge case of node being the only node in the `orderBook`\n     */\n    function _checkThatNodeIsInList(uint256 node, BatchOrder memory order, PoolData memory data) internal pure {\n        if (order.head == 0 && order.tail == 0) {\n            // Possible but the order may be centerTail or centerHead.\n            if (data.centerHead != node && data.centerTail != node) revert LimitOrderRegistry__OrderNotInList(node);\n        }\n    }\n    /**\n     * @notice Finds appropriate spot in `orderBook` for an order.\n     */\n    function _findSpot(\n        PoolData memory data,\n        uint256 startingNode,\n        int24 targetTick\n    ) internal view returns (uint256 proposedHead, uint256 proposedTail) {\n        BatchOrder memory node;\n        if (startingNode == 0) {\n            if (data.centerHead != 0) {\n                startingNode = data.centerHead;\n                node = orderBook[startingNode];\n            } else if (data.centerTail != 0) {\n                startingNode = data.centerTail;\n                node = orderBook[startingNode];\n            } else return (0, 0);\n        } else {\n            node = orderBook[startingNode];\n            _checkThatNodeIsInList(startingNode, node, data);\n        }\n        uint256 nodeId = startingNode;\n        bool direction = targetTick > node.tickUpper ? true : false;\n        while (true) {\n            if (direction) {\n                // Go until we find an order with a tick lower GREATER or equal to targetTick, then set proposedTail equal to the tail, and proposed head to the current node.\n                if (node.tickLower >= targetTick) {\n                    return (nodeId, node.tail);\n                } else if (node.head == 0) {\n                    // Made it to head of list.\n                    return (0, nodeId);\n                } else {\n                    nodeId = node.head;\n                    node = orderBook[nodeId];\n                }\n            } else {\n                // Go until we find tick upper that is LESS than or equal to targetTick\n                if (node.tickUpper <= targetTick) {\n                    return (node.head, nodeId);\n                } else if (node.tail == 0) {\n                    // Made it to the tail of the list.\n                    return (nodeId, 0);\n                } else {\n                    nodeId = node.tail;\n                    node = orderBook[nodeId];\n                }\n            }\n        }\n    }\n    /**\n     * @notice Checks if newly added order should be made the new center head/tail.\n     */\n    function _updateCenter(\n        UniswapV3Pool pool,\n        uint256 positionId,\n        int24 currentTick,\n        int24 upper,\n        int24 lower\n    ) internal {\n        PoolData memory data = poolToData[pool];\n        if (currentTick > upper) {\n            // Check if centerTail needs to be updated.\n            if (data.centerTail == 0) {\n                // Currently no centerTail, so this order must become it.\n                poolToData[pool].centerTail = positionId;\n            } else {\n                BatchOrder memory centerTail = orderBook[data.centerTail];\n                if (upper > centerTail.tickUpper) {\n                    // New position is closer to the current pool tick, so it becomes new centerTail.\n                    poolToData[pool].centerTail = positionId;\n                }\n                // else nothing to do.\n            }\n        } else if (currentTick < lower) {\n            // Check if centerHead needs to be updated.\n            if (data.centerHead == 0) {\n                // Currently no centerHead, so this order must become it.\n                poolToData[pool].centerHead = positionId;\n            } else {\n                BatchOrder memory centerHead = orderBook[data.centerHead];\n                if (lower < centerHead.tickLower) {\n                    // New position is closer to the current pool tick, so it becomes new centerHead.\n                    poolToData[pool].centerHead = positionId;\n                }\n                // else nothing to do.\n            }\n        }\n    }\n    /**\n     * @notice Add a Uniswap V3 LP position to the `orderBook`.\n     */\n    function _addPositionToList(\n        PoolData memory data,\n        uint256 startingNode,\n        int24 targetTick,\n        uint256 position\n    ) internal {\n        (uint256 head, uint256 tail) = _findSpot(data, startingNode, targetTick);\n        if (tail != 0) {\n            orderBook[tail].head = position;\n            orderBook[position].tail = tail;\n        }\n        if (head != 0) {\n            orderBook[head].tail = position;\n            orderBook[position].head = head;\n        }\n    }\n    /**\n     * @notice Setup a newly minted LP position, or one being reused.\n     * @dev Sets batchId, and direction.\n     */\n    function _setupOrder(bool direction, uint256 position) internal {\n        BatchOrder storage order = orderBook[position];\n        order.batchId = batchCount;\n        order.direction = direction;\n        batchCount++;\n    }\n    /**\n     * @notice Updates a BatchOrder's token0/token1 amount, as well as associated\n     *         `batchIdToUserDepositAmount` mapping value.\n     * @dev If user is new to the order, increment userCount.\n     */\n    function _updateOrder(uint256 positionId, address user, uint128 amount) internal returns (uint128 userTotal) {\n        BatchOrder storage order = orderBook[positionId];\n        if (order.direction) {\n            // token1\n            order.token0Amount += amount;\n        } else {\n            // token0\n            order.token1Amount += amount;\n        }\n        // Check if user is already in the order.\n        uint128 batchId = order.batchId;\n        uint128 originalDepositAmount = batchIdToUserDepositAmount[batchId][user];\n        // If this is a new user in the order, add 1 to userCount.\n        if (originalDepositAmount == 0) order.userCount++;\n        batchIdToUserDepositAmount[batchId][user] = originalDepositAmount + amount;\n        return (originalDepositAmount + amount);\n    }\n    /**\n     * @notice Mints a new Uniswap V3 LP position.\n     */\n    function _mintPosition(\n        PoolData memory data,\n        int24 upper,\n        int24 lower,\n        uint128 amount0,\n        uint128 amount1,\n        bool direction\n    ) internal returns (uint256) {\n        if (direction) data.token0.safeApprove(address(POSITION_MANAGER), amount0);\n        else data.token1.safeApprove(address(POSITION_MANAGER), amount1);\n\n        // 0.9999e18 accounts for rounding errors in the Uniswap V3 protocol.\n        uint128 amount0Min = amount0 == 0 ? 0 : (amount0 * 0.9999e18) / 1e18;\n        uint128 amount1Min = amount1 == 0 ? 0 : (amount1 * 0.9999e18) / 1e18;\n\n        // Create mint params.\n        NonFungiblePositionManager.MintParams memory params = NonFungiblePositionManager.MintParams({\n\n    \n          \n            \n    \n\n          \n          Expand Down\n    \n    \n  \n            token0: address(data.token0),\n            token1: address(data.token1),\n            fee: data.fee,\n            tickLower: lower,\n            tickUpper: upper,\n            amount0Desired: amount0,\n            amount1Desired: amount1,\n            amount0Min: amount0Min,\n            amount1Min: amount1Min,\n            recipient: address(this),\n            deadline: block.timestamp\n        });\n        // Supply liquidity to pool.\n        (uint256 tokenId, , , ) = POSITION_MANAGER.mint(params);\n        // Revert if tokenId received is 0 id.\n        // Zero token id is reserved for NULL values in linked list.\n        if (tokenId == 0) revert LimitOrderRegistry__InvalidPositionId();\n        // If position manager still has allowance, zero it out.\n        if (direction && data.token0.allowance(address(this), address(POSITION_MANAGER)) > 0)\n            data.token0.safeApprove(address(POSITION_MANAGER), 0);\n        if (!direction && data.token1.allowance(address(this), address(POSITION_MANAGER)) > 0)\n            data.token1.safeApprove(address(POSITION_MANAGER), 0);\n        return tokenId;\n    }\n    /**\n     * @notice Adds liquidity to a given `positionId`.\n     */\n    function _addToPosition(\n        PoolData memory data,\n        uint256 positionId,\n        uint128 amount0,\n        uint128 amount1,\n        bool direction\n    ) internal {\n        if (direction) data.token0.safeApprove(address(POSITION_MANAGER), amount0);\n        else data.token1.safeApprove(address(POSITION_MANAGER), amount1);\n        uint128 amount0Min = amount0 == 0 ? 0 : (amount0 * 0.9999e18) / 1e18;\n        uint128 amount1Min = amount1 == 0 ? 0 : (amount1 * 0.9999e18) / 1e18;\n        // Create increase liquidity params.\n        NonFungiblePositionManager.IncreaseLiquidityParams memory params = NonFungiblePositionManager\n            .IncreaseLiquidityParams({\n                tokenId: positionId,\n                amount0Desired: amount0,\n                amount1Desired: amount1,\n                amount0Min: amount0Min,\n                amount1Min: amount1Min,\n                deadline: block.timestamp\n            });\n        // Increase liquidity in pool.\n        POSITION_MANAGER.increaseLiquidity(params);\n        // If position manager still has allowance, zero it out.\n        if (direction && data.token0.allowance(address(this), address(POSITION_MANAGER)) > 0)\n            data.token0.safeApprove(address(POSITION_MANAGER), 0);\n        if (!direction && data.token1.allowance(address(this), address(POSITION_MANAGER)) > 0)\n            data.token1.safeApprove(address(POSITION_MANAGER), 0);\n    }\n    /**\n     * @notice Enforces minimum liquidity requirements for orders.\n     */\n    function _enforceMinimumLiquidity(uint256 amount, ERC20 asset) internal view {\n        uint256 minimum = minimumAssets[asset];\n        if (minimum == 0) revert LimitOrderRegistry__MinimumNotSet(address(asset));\n        if (amount < minimum) revert LimitOrderRegistry__MinimumNotMet(address(asset), minimum, amount);\n    }\n    /**\n     * @notice Helper function to determine an orders status.\n     * @dev Returns\n     *      - ITM if order is ready to be filled, and is composed of wanted asset\n     *      - OTM if order is not ready to be filled, but order can still be cancelled, because order is composed of asset to sell\n     *      - MIXED order is composed of both wanted asset, and asset to sell, can not be fulfilled or cancelled.\n     */\n    function _getOrderStatus(\n        int24 currentTick,\n        int24 lower,\n        int24 upper,\n        bool direction\n    ) internal pure returns (OrderStatus status) {\n        if (upper == lower) revert LimitOrderRegistry__InvalidTickRange(upper, lower);\n        if (direction) {\n            // Indicates we want to go lower -> upper.\n            if (currentTick > upper) return OrderStatus.ITM;\n            if (currentTick >= lower) return OrderStatus.MIXED;\n            else return OrderStatus.OTM;\n        } else {\n            // Indicates we want to go upper -> lower.\n            if (currentTick < lower) return OrderStatus.ITM;\n            if (currentTick <= upper) return OrderStatus.MIXED;\n            else return OrderStatus.OTM;\n        }\n    }\n    /**\n     * @notice Called during `performUpkeep` to fulfill an ITM order.\n     * @dev Sets Claim info, removes all liquidity from position, and zeroes out BatchOrder amount0 and amount1 values.\n     */\n    function _fulfillOrder(\n        uint256 target,\n        UniswapV3Pool pool,\n        BatchOrder storage order,\n        uint256 estimatedFee\n    ) internal {\n        // Save fee per user in Claim Struct.\n        uint256 totalUsers = order.userCount;\n        Claim storage newClaim = claim[order.batchId];\n        newClaim.feePerUser = uint128(estimatedFee / totalUsers);\n        newClaim.pool = pool;\n        // Take all liquidity from the order.\n        uint128 amount0;\n        uint128 amount1;\n        (amount0, amount1) = _takeFromPosition(target, pool, 1e18);\n        if (order.direction) {\n            // Copy the tokenIn amount from the order, this is the total user deposit.\n            newClaim.token0Amount = order.token0Amount;\n            // Total token out is amount1.\n            newClaim.token1Amount = amount1;\n        } else {\n            // Copy the tokenIn amount from the order, this is the total user deposit.\n            newClaim.token1Amount = order.token1Amount;\n            // Total token out is amount0.\n            newClaim.token0Amount = amount0;\n        }\n        newClaim.direction = order.direction;\n        // Zero out order balances.\n        order.token0Amount = 0;\n        order.token1Amount = 0;\n        emit OrderFilled(order.batchId, address(pool));\n    }\n    /**\n     * @notice Removes liquidity from `target` Uniswap V3 LP position.\n     * @dev Collects fees from `target` position, and saves them in `tokenToSwapFees`.\n     */\n    function _takeFromPosition(\n        uint256 target,\n        UniswapV3Pool pool,\n        uint256 liquidityPercent\n    ) internal returns (uint128, uint128) {\n        (, , , , , , , uint128 liquidity, , , , ) = POSITION_MANAGER.positions(target);\n        liquidity = uint128(uint256(liquidity * liquidityPercent) / 1e18);\n        // Create decrease liquidity params.\n        NonFungiblePositionManager.DecreaseLiquidityParams memory params = NonFungiblePositionManager\n            .DecreaseLiquidityParams({\n                tokenId: target,\n                liquidity: liquidity,\n                amount0Min: 0,\n                amount1Min: 0,\n                deadline: block.timestamp\n            });\n        // Decrease liquidity in pool.\n        uint128 amount0;\n        uint128 amount1;\n        {\n            (uint256 a0, uint256 a1) = POSITION_MANAGER.decreaseLiquidity(params);\n            amount0 = uint128(a0);\n            amount1 = uint128(a1);\n        }\n        // If completely closing position, then collect fees as well.\n        NonFungiblePositionManager.CollectParams memory collectParams;\n        {\n            uint128 amount0Max;\n            uint128 amount1Max;\n            if (liquidityPercent == 1e18) {\n                amount0Max = type(uint128).max;\n                amount1Max = type(uint128).max;\n            } else {\n                // Otherwise only collect principal.\n                amount0Max = amount0;\n                amount1Max = amount1;\n            }\n            // Create fee collection params.\n            collectParams = NonFungiblePositionManager.CollectParams({\n                tokenId: target,\n                recipient: address(this),\n                amount0Max: amount0Max,\n                amount1Max: amount1Max\n            });\n        }\n        // Save token balances.\n        ERC20 token0 = poolToData[pool].token0;\n        ERC20 token1 = poolToData[pool].token1;\n        uint256 token0Balance = token0.balanceOf(address(this));\n        uint256 token1Balance = token1.balanceOf(address(this));\n        // Collect fees.\n        POSITION_MANAGER.collect(collectParams);\n        // Save fees earned, take the total token amount out - the amount removed from liquidity to get the fees earned.\n        uint128 token0Fees = uint128(token0.balanceOf(address(this)) - token0Balance) - amount0;\n        uint128 token1Fees = uint128(token1.balanceOf(address(this)) - token1Balance) - amount1;\n        // Save any swap fees.\n        if (token0Fees > 0) tokenToSwapFees[address(token0)] += token0Fees;\n        if (token1Fees > 0) tokenToSwapFees[address(token1)] += token1Fees;\n        return (amount0, amount1);\n    }\n    /**\n     * @notice Removes an order from the `orderBook`.\n     * @dev Checks if order is one of the center values, and updates the head if need be.\n     */\n    function _removeOrderFromList(uint256 target, UniswapV3Pool pool, BatchOrder storage order) internal {\n        // Checks if order is the center, if so then it will set it to the the center orders head(which is okay if it is zero).\n        uint256 centerHead = poolToData[pool].centerHead;\n        uint256 centerTail = poolToData[pool].centerTail;\n        if (target == centerHead) {\n            uint256 newHead = orderBook[centerHead].head;\n            poolToData[pool].centerHead = newHead;\n        } else if (target == centerTail) {\n            uint256 newTail = orderBook[centerTail].tail;\n            poolToData[pool].centerTail = newTail;\n        }\n        // Remove order from linked list.\n        orderBook[order.tail].head = order.head;\n        orderBook[order.head].tail = order.tail;\n        order.head = 0;\n        order.tail = 0;\n    }\n    /**\n     * @notice Helper function to get the gas price used for fee calculation.\n     */\n    function getGasPrice() public view returns (uint256) {\n        // If gas feed is set use it.\n        if (fastGasFeed != address(0)) {\n            (, int256 _answer, , uint256 _timestamp, ) = IChainlinkAggregator(fastGasFeed).latestRoundData();\n            uint256 timeSinceLastUpdate = block.timestamp - _timestamp;\n            // Check answer is not stale.\n            if (timeSinceLastUpdate > FAST_GAS_HEARTBEAT) {\n                // If answer is stale use owner set value.\n                // Multiply by 1e9 to convert gas price to gwei\n                return uint256(upkeepGasPrice) * 1e9;\n            } else {\n                // Else use the datafeed value.\n                uint256 answer = uint256(_answer);\n                return answer;\n            }\n        }\n        // Else use owner set value.\n        return uint256(upkeepGasPrice) * 1e9; // Multiply by 1e9 to convert gas price to gwei\n    }\n    /*//////////////////////////////////////////////////////////////\n                            VIEW LOGIC\n    //////////////////////////////////////////////////////////////*/\n    /**\n     * @notice Helper function that finds the appropriate spot in the linked list for a new order.\n     * @param pool the Uniswap V3 pool you want to create an order in\n     * @param startingNode the UniV3 position Id to start looking\n     * @param targetTick the targetTick of the order you want to place\n     * @return proposedHead , proposedTail pr the correct head and tail for the new order\n     * @dev if both head and tail are zero, just pass in zero for the `startingNode`\n     *      otherwise pass in either the nonzero head or nonzero tail for the `startingNode`\n     */\n    function findSpot(\n        UniswapV3Pool pool,\n        uint256 startingNode,\n        int24 targetTick\n    ) external view returns (uint256 proposedHead, uint256 proposedTail) {\n        PoolData memory data = poolToData[pool];\n        int24 tickSpacing = pool.tickSpacing();\n        // Make sure targetTick is divisible by spacing.\n        if (targetTick % tickSpacing != 0) revert LimitOrderRegistry__InvalidTargetTick(targetTick, tickSpacing);\n        (proposedHead, proposedTail) = _findSpot(data, startingNode, targetTick);\n    }\n    /**\n     * @notice Helper function to get the fee per user for a specific order.\n     */\n    function getFeePerUser(uint128 batchId) external view returns (uint128) {\n        return claim[batchId].feePerUser;\n    }\n    /**\n     * @notice Helper function to view if a BatchOrder is ready to claim.\n     */\n    function isOrderReadyForClaim(uint128 batchId) external view returns (bool) {\n        return claim[batchId].isReadyForClaim;\n    }\n    function getOrderBook(uint256 id) external view returns (BatchOrder memory) {\n        return orderBook[id];\n    }\n    function getClaim(uint128 batchId) external view returns (Claim memory) {\n        return claim[batchId];\n    }\n}",
        "after": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.16;\nimport { ERC20 } from \"@solmate/tokens/ERC20.sol\";\nimport { SafeTransferLib } from \"@solmate/utils/SafeTransferLib.sol\";\nimport { AutomationCompatibleInterface } from \"@chainlink/contracts/src/v0.8/interfaces/AutomationCompatibleInterface.sol\";\nimport { Owned } from \"@solmate/auth/Owned.sol\";\nimport { UniswapV3Pool } from \"src/interfaces/uniswapV3/UniswapV3Pool.sol\";\nimport { NonFungiblePositionManager } from \"src/interfaces/uniswapV3/NonFungiblePositionManager.sol\";\nimport { ERC721Holder } from \"@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol\";\nimport { LinkTokenInterface } from \"@chainlink/contracts/src/v0.8/interfaces/LinkTokenInterface.sol\";\nimport { IKeeperRegistrar, RegistrationParams } from \"src/interfaces/chainlink/IKeeperRegistrar.sol\";\nimport { Context } from \"@openzeppelin/contracts/utils/Context.sol\";\nimport { IChainlinkAggregator } from \"src/interfaces/chainlink/IChainlinkAggregator.sol\";\n/**\n * @title Limit Order Registry\n * @notice Allows users to create decentralized limit orders.\n * @dev DO NOT PLACE LIMIT ORDERS FOR STRONGLY CORRELATED ASSETS.\n *      - If a stable coin pair were to temporarily depeg, and a user places a limit order\n *        whose tick range encompasses the normal trading tick, there is NO way to cancel the order\n *        because the order is mixed. The user would have to wait for another depeg event to happen\n *        so that the order can be fulfilled, or the order can be cancelled.\n * @author crispymangoes\n */\ncontract LimitOrderRegistry is Owned, AutomationCompatibleInterface, ERC721Holder, Context {\n    using SafeTransferLib for ERC20;\n    /*//////////////////////////////////////////////////////////////\n                             STRUCTS\n    //////////////////////////////////////////////////////////////*/\n    /**\n     * @notice Stores linked list center values, and frequently used pool values.\n     * @param centerHead Linked list center value closer to head of the list\n     * @param centerTail Linked list center value closer to tail of the list\n     * @param token0 ERC20 token0 of the pool\n     * @param token1 ERC20 token1 of the pool\n     * @param fee Uniswap V3 pool fee\n     */\n    struct PoolData {\n        uint256 centerHead;\n        uint256 centerTail;\n        ERC20 token0;\n        ERC20 token1;\n        uint24 fee;\n    }\n    /**\n     * @notice Stores information about batches of orders.\n     * @dev User orders can be batched together if they share the same target price.\n     * @param direction Determines what direction the tick must move in order for the order to be filled\n     *        - true, pool tick must INCREASE to fill this order\n     *        - false, pool tick must DECREASE to fill this order\n     * @param tickUpper The upper tick of the underlying LP position\n     * @param tickLower The lower tick of the underlying LP position\n     * @param userCount The number of users in this batch order\n     * @param batchId Unique id used to distinguish this batch order from another batch order in the past that used the same LP position\n     * @param token0Amount The amount of token0 in this order\n     * @param token1Amount The amount of token1 in this order\n     * @param head The next node in the linked list when moving toward the head\n     * @param tail The next node in the linked list when moving toward the tail\n     */\n    struct BatchOrder {\n        bool direction;\n        int24 tickUpper;\n        int24 tickLower;\n        uint64 userCount;\n        uint128 batchId;\n        uint128 token0Amount;\n        uint128 token1Amount;\n        uint256 head;\n        uint256 tail;\n    }\n    /**\n     * @notice Stores information needed for users to make claims.\n     * @param pool The Uniswap V3 pool the batch order was in\n     * @param token0Amount The amount of token0 in the order\n     * @param token1Amount The amount of token1 in the order\n     * @param feePerUser The native token fee that must be paid on order claiming\n     * @param direction The underlying order direction, used to determine input/output token of the order\n     * @param isReadyForClaim Explicit bool indicating whether or not this order is ready to be claimed\n     */\n    struct Claim {\n        UniswapV3Pool pool;\n        uint128 token0Amount; //Can either be the deposit amount or the amount got out of liquidity changing to the other token\n        uint128 token1Amount;\n        uint128 feePerUser; // Fee in terms of network native asset.\n        bool direction; //Determines the token out\n        bool isReadyForClaim;\n    }\n    /**\n     * @notice Struct used to store variables needed during order creation.\n     * @param tick The target tick of the order\n     * @param upper The upper tick of the underlying LP position\n     * @param lower The lower tick of the underlying LP position\n     * @param userTotal The total amount of assets the user has in the order\n     * @param positionId The underling LP position token id this order is adding liquidity to\n     * @param amount0 Can be the amount of assets user added to the order, based off orders direction\n     * @param amount1 Can be the amount of assets user added to the order, based off orders direction\n     */\n    struct OrderDetails {\n        int24 tick;\n        int24 upper;\n        int24 lower;\n        uint128 userTotal;\n        uint256 positionId;\n        uint128 amount0;\n        uint128 amount1;\n    }\n    /*//////////////////////////////////////////////////////////////\n                             GLOBAL STATE\n    //////////////////////////////////////////////////////////////*/\n    /**\n     * @notice Stores swap fees earned from limit order where the input token earns swap fees.\n     */\n    mapping(address => uint256) public tokenToSwapFees;\n    /**\n     * @notice Used to store claim information needed when users are claiming their orders.\n     */\n    mapping(uint128 => Claim) public claim;\n    /**\n     * @notice Stores the pools center head/tail, as well as frequently read values.\n     */\n    mapping(UniswapV3Pool => PoolData) public poolToData;\n    /**\n     * @notice Maps tick ranges to LP positions owned by this contract.\n     */\n    mapping(UniswapV3Pool => mapping(int24 => mapping(int24 => uint256))) public getPositionFromTicks; // maps pool -> lower -> upper -> positionId\n    /**\n     * @notice The minimum amount of assets required to create a `newOrder`.\n     * @dev Changeable by owner.\n     */\n    mapping(ERC20 => uint256) public minimumAssets;\n    /**\n     * @notice Approximated amount of gas needed to fulfill 1 BatchOrder.\n     * @dev Changeable by owner.\n     */\n    uint32 public upkeepGasLimit = 300_000;\n    /**\n     * @notice Approximated gas price used to fulfill orders.\n     * @dev Changeable by owner.\n     */\n    uint32 public upkeepGasPrice = 30;\n    /**\n     * @notice Max number of orders that can be filled in 1 upkeep call.\n     * @dev Changeable by owner.\n     */\n    uint16 public maxFillsPerUpkeep = 10;\n    /**\n     * @notice Value is incremented whenever a new BatchOrder is added to the `orderBook`.\n     * @dev Zero is reserved.\n     */\n    uint128 public batchCount = 1;\n    /**\n     * @notice Mapping is used to store user deposit amounts in each BatchOrder.\n     */\n    mapping(uint128 => mapping(address => uint128)) public batchIdToUserDepositAmount;\n    /**\n     * @notice The `orderBook` maps Uniswap V3 token ids to BatchOrder information.\n     * @dev Each BatchOrder contains a head and tail value which effectively,\n     *      which means BatchOrders are connected using a doubley linked list.\n     */\n    mapping(uint256 => BatchOrder) public orderBook;\n    /**\n     * @notice Chainlink Automation Registrar contract.\n     */\n    IKeeperRegistrar public registrar; // Mainnet 0xDb8e8e2ccb5C033938736aa89Fe4fa1eDfD15a1d\n    /**\n     * @notice Whether or not the contract is shutdown in case of an emergency.\n     */\n    bool public isShutdown;\n    /**\n     * @notice Chainlink Fast Gas Feed for ETH Mainnet.\n     */\n    address public fastGasFeed = 0x169E633A2D1E6c10dD91238Ba11c4A708dfEF37C;\n    /**\n     * @notice The max possible gas the owner can set for the gas limit.\n     */\n    uint32 public constant MAX_GAS_LIMIT = 750_000;\n    /**\n     * @notice The max possible gas price the owner can set for the gas price.\n     * @dev In units of gwei.\n     */\n    uint32 public constant MAX_GAS_PRICE = 1_000;\n    /**\n     * @notice The max number of orders that can be fulfilled in a single upkeep TX.\n     */\n    uint16 public constant MAX_FILLS_PER_UPKEEP = 20;\n    /**\n     * @notice The ETH Fast Gas Feed heartbeat.\n     * @dev If answer is stale, owner set gas price is used.\n     */\n    uint256 public constant FAST_GAS_HEARTBEAT = 7200;\n    /**\n     * @notice Function selector used to create V1 Upkeep versions.\n     */\n    bytes4 private constant FUNC_SELECTOR =\n        bytes4(keccak256(\"register(string,bytes,address,uint32,address,bytes,uint96,uint8,address)\"));\n    /*//////////////////////////////////////////////////////////////\n                                 MODIFIERS\n    //////////////////////////////////////////////////////////////*/\n    /**\n     * @notice Prevent a function from being called during a shutdown.\n     */\n    modifier whenNotShutdown() {\n        if (isShutdown) revert LimitOrderRegistry__ContractShutdown();\n        _;\n    }\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n    event NewOrder(address user, address pool, uint128 amount, uint128 userTotal, BatchOrder effectedOrder);\n    event ClaimOrder(address user, uint128 batchId, uint256 amount);\n    event CancelOrder(address user, uint128 amount0, uint128 amount1, BatchOrder effectedOrder);\n    event OrderFilled(uint256 batchId, address pool);\n    event ShutdownChanged(bool isShutdown);\n    event LimitOrderSetup(address pool);\n    /*//////////////////////////////////////////////////////////////\n                                 ERRORS\n    //////////////////////////////////////////////////////////////*/\n    error LimitOrderRegistry__OrderITM(int24 currentTick, int24 targetTick, bool direction);\n    error LimitOrderRegistry__PoolAlreadySetup(address pool);\n    error LimitOrderRegistry__PoolNotSetup(address pool);\n    error LimitOrderRegistry__InvalidTargetTick(int24 targetTick, int24 tickSpacing);\n    error LimitOrderRegistry__UserNotFound(address user, uint256 batchId);\n    error LimitOrderRegistry__InvalidPositionId();\n    error LimitOrderRegistry__NoLiquidityInOrder();\n    error LimitOrderRegistry__NoOrdersToFulfill();\n    error LimitOrderRegistry__CenterITM();\n    error LimitOrderRegistry__OrderNotInList(uint256 tokenId);\n    error LimitOrderRegistry__MinimumNotSet(address asset);\n    error LimitOrderRegistry__MinimumNotMet(address asset, uint256 minimum, uint256 amount);\n    error LimitOrderRegistry__InvalidTickRange(int24 upper, int24 lower);\n    error LimitOrderRegistry__ZeroFeesToWithdraw(address token);\n    error LimitOrderRegistry__ZeroNativeBalance();\n    error LimitOrderRegistry__InvalidBatchId();\n    error LimitOrderRegistry__OrderNotReadyToClaim(uint128 batchId);\n    error LimitOrderRegistry__ContractShutdown();\n    error LimitOrderRegistry__ContractNotShutdown();\n    error LimitOrderRegistry__InvalidGasLimit();\n    error LimitOrderRegistry__InvalidGasPrice();\n    error LimitOrderRegistry__InvalidFillsPerUpkeep();\n    error LimitOrderRegistry__AmountShouldBeZero();\n    error LimitOrderRegistry__DirectionMisMatch();\n    /*//////////////////////////////////////////////////////////////\n                                 ENUMS\n    //////////////////////////////////////////////////////////////*/\n    enum OrderStatus {\n        ITM,\n        OTM,\n        MIXED\n    }\n    /*//////////////////////////////////////////////////////////////\n                              IMMUTABLES\n    //////////////////////////////////////////////////////////////*/\n    ERC20 public immutable WRAPPED_NATIVE; // Mainnet 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2\n    NonFungiblePositionManager public immutable POSITION_MANAGER; // Mainnet 0xC36442b4a4522E871399CD717aBDD847Ab11FE88\n    LinkTokenInterface public immutable LINK; // Mainnet 0x514910771AF9Ca656af840dff83E8264EcF986CA\n    constructor(\n        address _owner,\n        NonFungiblePositionManager _positionManager,\n        ERC20 wrappedNative,\n        LinkTokenInterface link,\n        IKeeperRegistrar _registrar,\n        address _fastGasFeed\n    ) Owned(_owner) {\n        POSITION_MANAGER = _positionManager;\n        WRAPPED_NATIVE = wrappedNative;\n        LINK = link;\n        registrar = _registrar;\n        fastGasFeed = _fastGasFeed;\n    }\n    /*//////////////////////////////////////////////////////////////\n                              OWNER LOGIC\n    //////////////////////////////////////////////////////////////*/\n    /**\n     * @notice No input validation is done because it is in the owners best interest to choose a valid registrar.\n     */\n    function setRegistrar(IKeeperRegistrar _registrar) external onlyOwner {\n        registrar = _registrar;\n    }\n    /**\n     * @notice Allows owner to set the fills per upkeep.\n     */\n    function setMaxFillsPerUpkeep(uint16 newVal) external onlyOwner {\n        if (newVal == 0 || newVal > MAX_FILLS_PER_UPKEEP) revert LimitOrderRegistry__InvalidFillsPerUpkeep();\n        maxFillsPerUpkeep = newVal;\n    }\n    /**\n     * @notice Allows owner to setup a new limit order for a new pool.\n     * @dev New Limit orders, should have a keeper to fulfill orders.\n     * @dev If `initialUpkeepFunds` is zero, upkeep creation is skipped.\n     */\n    function setupLimitOrder(UniswapV3Pool pool, uint256 initialUpkeepFunds) external onlyOwner {\n        // Check if Limit Order is already setup for `pool`.\n        if (address(poolToData[pool].token0) != address(0)) revert LimitOrderRegistry__PoolAlreadySetup(address(pool));\n        // Create Upkeep.\n        if (initialUpkeepFunds > 0) {\n            // Owner wants to automatically create an upkeep for new pool.\n            ERC20(address(LINK)).safeTransferFrom(owner, address(this), initialUpkeepFunds);\n            if (bytes(registrar.typeAndVersion())[16] == bytes(\"1\")[0]) {\n                // Use V1 Upkeep Registration.\n                bytes memory data = abi.encodeWithSelector(\n                    FUNC_SELECTOR,\n                    \"Limit Order Registry\",\n                    abi.encode(0),\n                    address(this),\n                    uint32(maxFillsPerUpkeep * upkeepGasLimit),\n                    owner,\n                    abi.encode(pool),\n                    uint96(initialUpkeepFunds),\n                    77,\n                    address(this)\n                );\n                LINK.transferAndCall(address(registrar), initialUpkeepFunds, data);\n            } else {\n                // Use V2 Upkeep Registration.\n                ERC20(address(LINK)).safeApprove(address(registrar), initialUpkeepFunds);\n                RegistrationParams memory params = RegistrationParams({\n                    name: \"Limit Order Registry\",\n                    encryptedEmail: abi.encode(0),\n                    upkeepContract: address(this),\n                    gasLimit: uint32(maxFillsPerUpkeep * upkeepGasLimit),\n                    adminAddress: owner,\n                    checkData: abi.encode(pool),\n                    offchainConfig: abi.encode(0),\n                    amount: uint96(initialUpkeepFunds)\n                });\n                registrar.registerUpkeep(params);\n            }\n        }\n        // poolToData\n        poolToData[pool] = PoolData({\n            centerHead: 0,\n            centerTail: 0,\n            token0: ERC20(pool.token0()),\n            token1: ERC20(pool.token1()),\n            fee: pool.fee()\n        });\n        emit LimitOrderSetup(address(pool));\n    }\n    /**\n     * @notice Allows owner to set the minimum assets used to create `newOrder`s.\n     * @dev This value can be zero, but then this contract can be griefed by an attacker spamming low liquidity orders.\n     */\n    function setMinimumAssets(uint256 amount, ERC20 asset) external onlyOwner {\n        minimumAssets[asset] = amount;\n    }\n    /**\n     * @notice Allows owner to change the gas limit value used to determine the Native asset fee needed to claim orders.\n     * @dev premium should be factored into this value.\n     */\n    function setUpkeepGasLimit(uint32 gasLimit) external onlyOwner {\n        if (gasLimit > MAX_GAS_LIMIT) revert LimitOrderRegistry__InvalidGasLimit();\n        upkeepGasLimit = gasLimit;\n    }\n    /**\n     * @notice Allows owner to change the gas price used to determine the Native asset fee needed to claim orders.\n     * @dev `gasPrice` uses units of gwei.\n     */\n    function setUpkeepGasPrice(uint32 gasPrice) external onlyOwner {\n        if (gasPrice > MAX_GAS_PRICE) revert LimitOrderRegistry__InvalidGasPrice();\n        upkeepGasPrice = gasPrice;\n    }\n    /**\n     * @notice Allows owner to set the fast gas feed.\n     */\n    function setFastGasFeed(address feed) external onlyOwner {\n        fastGasFeed = feed;\n    }\n    /**\n     * @notice Allows owner to withdraw swap fees earned from the input token of orders.\n     */\n    function withdrawSwapFees(address tokenFeeIsIn) external onlyOwner {\n        uint256 fee = tokenToSwapFees[tokenFeeIsIn];\n        // Make sure there are actually fees to withdraw.\n        if (fee == 0) revert LimitOrderRegistry__ZeroFeesToWithdraw(tokenFeeIsIn);\n        tokenToSwapFees[tokenFeeIsIn] = 0;\n        ERC20(tokenFeeIsIn).safeTransfer(owner, fee);\n    }\n    /**\n     * @notice Allows owner to withdraw wrapped native and native assets from this contract.\n     */\n    function withdrawNative() external onlyOwner {\n        uint256 wrappedNativeBalance = WRAPPED_NATIVE.balanceOf(address(this));\n        uint256 nativeBalance = address(this).balance;\n        // Make sure there is something to withdraw.\n        if (wrappedNativeBalance == 0 && nativeBalance == 0) revert LimitOrderRegistry__ZeroNativeBalance();\n        WRAPPED_NATIVE.safeTransfer(owner, WRAPPED_NATIVE.balanceOf(address(this)));\n        payable(owner).transfer(address(this).balance);\n    }\n    /**\n     * @notice Shutdown the cellar. Used in an emergency or if the cellar has been deprecated.\n     */\n    function initiateShutdown() external whenNotShutdown onlyOwner {\n        isShutdown = true;\n        emit ShutdownChanged(true);\n    }\n    /**\n     * @notice Restart the cellar.\n     */\n    function liftShutdown() external onlyOwner {\n        if (!isShutdown) revert LimitOrderRegistry__ContractNotShutdown();\n        isShutdown = false;\n        emit ShutdownChanged(false);\n    }\n    /*//////////////////////////////////////////////////////////////\n                        USER ORDER MANAGEMENT LOGIC\n    //////////////////////////////////////////////////////////////*/\n    /**\n     * @notice Creates a new limit order for a specific pool.\n     * @dev Limit orders can be created to buy either token0, or token1 of the pool.\n     * @param pool the Uniswap V3 pool to create a limit order on.\n     * @param targetTick the tick, that when `pool`'s tick passes, the order will be completely fulfilled\n     * @param amount the amount of the input token to sell for the desired token out\n     * @param direction bool indicating what the desired token out is\n     *                  - true  token in = token0 ; token out = token1\n     *                  - false token in = token1 ; token out = token0\n     * @param startingNode an NFT position id indicating where this contract should start searching for a spot in the list\n     *                     - can be zero which defaults to starting the search at center of list\n     * @dev reverts if\n     *      - pool is not setup\n     *      - targetTick is not divisible by the pools tick spacing\n     *      - the new order would be ITM\n     *      - the new order does not meet minimum liquidity requirements\n     *      - transferFrom fails\n     * @dev Emits a `NewOrder` event which contains meta data about the order including the orders `batchId`(which is used for claiming/cancelling).\n     */\n    function newOrder(\n        UniswapV3Pool pool,\n        int24 targetTick,\n        uint128 amount,\n        bool direction,\n        uint256 startingNode\n    ) external whenNotShutdown returns (uint128) {\n        if (address(poolToData[pool].token0) == address(0)) revert LimitOrderRegistry__PoolNotSetup(address(pool));\n        OrderDetails memory details;\n        address sender = _msgSender();\n        (, details.tick, , , , , ) = pool.slot0();\n        // Determine upper and lower ticks.\n        {\n            int24 tickSpacing = pool.tickSpacing();\n            // Make sure targetTick is divisible by spacing.\n            if (targetTick % tickSpacing != 0) revert LimitOrderRegistry__InvalidTargetTick(targetTick, tickSpacing);\n            if (direction) {\n                details.upper = targetTick;\n                details.lower = targetTick - tickSpacing;\n            } else {\n                details.upper = targetTick + tickSpacing;\n                details.lower = targetTick;\n            }\n        }\n        // Validate lower, upper,and direction.\n        {\n            OrderStatus status = _getOrderStatus(details.tick, details.lower, details.upper, direction);\n            if (status != OrderStatus.OTM) revert LimitOrderRegistry__OrderITM(details.tick, targetTick, direction);\n        }\n        // Transfer assets into contract before setting any state.\n        {\n            ERC20 assetIn;\n            if (direction) assetIn = poolToData[pool].token0;\n            else assetIn = poolToData[pool].token1;\n            _enforceMinimumLiquidity(amount, assetIn);\n            assetIn.safeTransferFrom(sender, address(this), amount);\n        }\n        // Get the position id.\n        details.positionId = getPositionFromTicks[pool][details.lower][details.upper];\n        if (direction) details.amount0 = amount;\n        else details.amount1 = amount;\n        if (details.positionId == 0) {\n            // Create new LP position(which adds liquidity)\n            PoolData memory data = poolToData[pool];\n            details.positionId = _mintPosition(\n                data,\n                details.upper,\n                details.lower,\n                details.amount0,\n                details.amount1,\n                direction\n            );\n            // Add it to the list.\n            _addPositionToList(data, startingNode, targetTick, details.positionId);\n            // Set new orders upper and lower tick.\n            orderBook[details.positionId].tickLower = details.lower;\n            orderBook[details.positionId].tickUpper = details.upper;\n            // Setup BatchOrder, setting batchId, direction.\n            _setupOrder(direction, details.positionId);\n            // Update token0Amount, token1Amount, batchIdToUserDepositAmount mapping.\n            details.userTotal = _updateOrder(details.positionId, sender, amount);\n            // Update the center values if need be.\n            _updateCenter(pool, details.positionId, details.tick, details.upper, details.lower);\n            // Update getPositionFromTicks since we have a new LP position.\n            getPositionFromTicks[pool][details.lower][details.upper] = details.positionId;\n        } else {\n            // Check if the position id is already being used in List.\n            BatchOrder memory order = orderBook[details.positionId];\n            if (order.token0Amount > 0 || order.token1Amount > 0) {\n                // Check that supplied direction and order.direction are the same.\n                if (direction != order.direction) revert LimitOrderRegistry__DirectionMisMatch();\n                // Need to add liquidity.\n                PoolData memory data = poolToData[pool];\n                _addToPosition(data, details.positionId, details.amount0, details.amount1, direction);\n                // Update token0Amount, token1Amount, batchIdToUserDepositAmount mapping.\n                details.userTotal = _updateOrder(details.positionId, sender, amount);\n            } else {\n                // We already have an LP position with given tick ranges, but it is not in linked list.\n                PoolData memory data = poolToData[pool];\n                // Add it to the list.\n                _addPositionToList(data, startingNode, targetTick, details.positionId);\n                // Setup BatchOrder, setting batchId, direction.\n                _setupOrder(direction, details.positionId);\n                // Need to add liquidity.\n                _addToPosition(data, details.positionId, details.amount0, details.amount1, direction);\n                // Update token0Amount, token1Amount, batchIdToUserDepositAmount mapping.\n                details.userTotal = _updateOrder(details.positionId, sender, amount);\n                // Update the center values if need be.\n                _updateCenter(pool, details.positionId, details.tick, details.upper, details.lower);\n            }\n        }\n        uint128 batchId = orderBook[details.positionId].batchId;\n        emit NewOrder(sender, address(pool), amount, details.userTotal, orderBook[details.positionId]);\n        return batchId;\n    }\n    /**\n     * @notice Users can claim fulfilled orders by passing in the `batchId` corresponding to the order they want to claim.\n     * @param batchId the batchId corresponding to a fulfilled order to claim\n     * @param user the address of the user in the order to claim for\n     * @dev Caller must either approve this contract to spend their Wrapped Native token, and have at least `getFeePerUser` tokens in their wallet.\n     *      Or caller must send `getFeePerUser` value with this call.\n     */\n    function claimOrder(uint128 batchId, address user) external payable returns (ERC20, uint256) {\n        Claim storage userClaim = claim[batchId];\n        if (!userClaim.isReadyForClaim) revert LimitOrderRegistry__OrderNotReadyToClaim(batchId);\n        uint256 depositAmount = batchIdToUserDepositAmount[batchId][user];\n        if (depositAmount == 0) revert LimitOrderRegistry__UserNotFound(user, batchId);\n        // Zero out user balance.\n        delete batchIdToUserDepositAmount[batchId][user];\n        // Calculate owed amount.\n        uint256 totalTokenDeposited;\n        uint256 totalTokenOut;\n        ERC20 tokenOut;\n        if (userClaim.direction) {\n            totalTokenDeposited = userClaim.token0Amount;\n            totalTokenOut = userClaim.token1Amount;\n            tokenOut = poolToData[userClaim.pool].token1;\n        } else {\n            totalTokenDeposited = userClaim.token1Amount;\n            totalTokenOut = userClaim.token0Amount;\n            tokenOut = poolToData[userClaim.pool].token0;\n        }\n        uint256 owed = (totalTokenOut * depositAmount) / totalTokenDeposited;\n        // Transfer tokens owed to user.\n        tokenOut.safeTransfer(user, owed);\n        // Transfer fee in.\n        address sender = _msgSender();\n        if (msg.value >= userClaim.feePerUser) {\n            // refund if necessary.\n            uint256 refund = msg.value - userClaim.feePerUser;\n            if (refund > 0) payable(sender).transfer(refund);\n        } else {\n            WRAPPED_NATIVE.safeTransferFrom(sender, address(this), userClaim.feePerUser);\n            // If value is non zero send it back to caller.\n            if (msg.value > 0) payable(sender).transfer(msg.value);\n        }\n        emit ClaimOrder(user, batchId, owed);\n        return (tokenOut, owed);\n    }\n    /**\n     * @notice Allows users to cancel orders as long as they are completely OTM.\n     * @param pool the Uniswap V3 pool that contains the limit order to cancel\n     * @param targetTick the targetTick of the order you want to cancel\n     * @param direction bool indication the direction of the order\n     * @dev This logic will send ALL the swap fees from a position to the last person that cancels the order.\n     */\n    function cancelOrder(\n        UniswapV3Pool pool,\n        int24 targetTick,\n        bool direction\n    ) external returns (uint128 amount0, uint128 amount1, uint128 batchId) {\n        uint256 positionId;\n        {\n            // Make sure order is OTM.\n            (, int24 tick, , , , , ) = pool.slot0();\n            // Determine upper and lower ticks.\n            int24 upper;\n            int24 lower;\n            {\n                int24 tickSpacing = pool.tickSpacing();\n                // Make sure targetTick is divisible by spacing.\n                if (targetTick % tickSpacing != 0)\n                    revert LimitOrderRegistry__InvalidTargetTick(targetTick, tickSpacing);\n                if (direction) {\n                    upper = targetTick;\n                    lower = targetTick - tickSpacing;\n                } else {\n                    upper = targetTick + tickSpacing;\n                    lower = targetTick;\n                }\n            }\n            // Validate lower, upper,and direction. Make sure order is not ITM or MIXED\n            {\n                OrderStatus status = _getOrderStatus(tick, lower, upper, direction);\n                if (status != OrderStatus.OTM) revert LimitOrderRegistry__OrderITM(tick, targetTick, direction);\n            }\n            // Get the position id.\n            positionId = getPositionFromTicks[pool][lower][upper];\n            if (positionId == 0) revert LimitOrderRegistry__InvalidPositionId();\n        }\n        uint256 liquidityPercentToTake;\n        // Get the users deposit amount in the order.\n        BatchOrder storage order = orderBook[positionId];\n        if (order.batchId == 0) revert LimitOrderRegistry__InvalidBatchId();\n        address sender = _msgSender();\n        {\n            batchId = order.batchId;\n            uint128 depositAmount = batchIdToUserDepositAmount[batchId][sender];\n            if (depositAmount == 0) revert LimitOrderRegistry__UserNotFound(sender, batchId);\n            // Remove one from the userCount.\n            order.userCount--;\n            // Zero out user balance.\n            delete batchIdToUserDepositAmount[batchId][sender];\n            uint128 orderAmount;\n            if (order.direction) {\n                orderAmount = order.token0Amount;\n                if (orderAmount == depositAmount) {\n                    liquidityPercentToTake = 1e18;\n                    // Update order tokenAmount.\n                    order.token0Amount = 0;\n                } else {\n                    liquidityPercentToTake = (1e18 * depositAmount) / orderAmount;\n                    // Update order tokenAmount.\n                    order.token0Amount = orderAmount - depositAmount;\n                }\n            } else {\n                orderAmount = order.token1Amount;\n                if (orderAmount == depositAmount) {\n                    liquidityPercentToTake = 1e18;\n                    // Update order tokenAmount.\n                    order.token1Amount = 0;\n                } else {\n                    liquidityPercentToTake = (1e18 * depositAmount) / orderAmount;\n                    // Update order tokenAmount.\n                    order.token1Amount = orderAmount - depositAmount;\n                }\n            }\n            (amount0, amount1) = _takeFromPosition(positionId, pool, liquidityPercentToTake);\n            emit CancelOrder(sender, amount0, amount1, order);\n            if (liquidityPercentToTake == 1e18) {\n                _removeOrderFromList(positionId, pool, order);\n                // Zero out balances for cancelled order.\n                order.token0Amount = 0;\n                order.token1Amount = 0;\n                order.batchId = 0;\n            }\n        }\n        if (order.direction) {\n            if (amount0 > 0) poolToData[pool].token0.safeTransfer(sender, amount0);\n            else revert LimitOrderRegistry__NoLiquidityInOrder();\n            if (amount1 > 0) revert LimitOrderRegistry__AmountShouldBeZero();\n        } else {\n            if (amount1 > 0) poolToData[pool].token1.safeTransfer(sender, amount1);\n            else revert LimitOrderRegistry__NoLiquidityInOrder();\n            if (amount0 > 0) revert LimitOrderRegistry__AmountShouldBeZero();\n        }\n    }\n    /*//////////////////////////////////////////////////////////////\n                     CHAINLINK AUTOMATION LOGIC\n    //////////////////////////////////////////////////////////////*/\n    /**\n     * @notice Returned `performData` simply contains a bool indicating which direction in the `orderBook` has orders that need to be fulfilled.\n     */\n    function checkUpkeep(bytes calldata checkData) external view returns (bool upkeepNeeded, bytes memory performData) {\n        UniswapV3Pool pool = abi.decode(checkData, (UniswapV3Pool));\n        (, int24 currentTick, , , , , ) = pool.slot0();\n        PoolData memory data = poolToData[pool];\n        BatchOrder memory order;\n        OrderStatus status;\n        bool walkDirection;\n        if (data.centerHead != 0) {\n            // centerHead is set, check if it is ITM.\n            order = orderBook[data.centerHead];\n            status = _getOrderStatus(currentTick, order.tickLower, order.tickUpper, order.direction);\n            if (status == OrderStatus.ITM) {\n                walkDirection = true; // Walk towards head of list.\n                upkeepNeeded = true;\n                performData = abi.encode(pool, walkDirection);\n                return (upkeepNeeded, performData);\n            }\n        }\n        if (data.centerTail != 0) {\n            // If walk direction has not been set, then we know, no head orders are ITM.\n            // So check tail orders.\n            order = orderBook[data.centerTail];\n            status = _getOrderStatus(currentTick, order.tickLower, order.tickUpper, order.direction);\n            if (status == OrderStatus.ITM) {\n                walkDirection = false; // Walk towards tail of list.\n                upkeepNeeded = true;\n                performData = abi.encode(pool, walkDirection);\n                return (upkeepNeeded, performData);\n            }\n        }\n        return (false, abi.encode(0));\n    }\n    /**\n     * @notice Callable by anyone, as long as there are orders ITM, that need to be fulfilled.\n     * @dev Does not use _removeOrderFromList, so that the center head/tail\n     *      value is not updated every single time and order is fulfilled, instead we just update it once at the end.\n     */\n    function performUpkeep(bytes calldata performData) external {\n        (UniswapV3Pool pool, bool walkDirection) = abi.decode(performData, (UniswapV3Pool, bool));\n        if (address(poolToData[pool].token0) == address(0)) revert LimitOrderRegistry__PoolNotSetup(address(pool));\n        PoolData storage data = poolToData[pool];\n        // Estimate gas cost.\n        uint256 estimatedFee = uint256(upkeepGasLimit * getGasPrice());\n        (, int24 currentTick, , , , , ) = pool.slot0();\n        bool orderFilled;\n        // Fulfill orders.\n        uint256 target = walkDirection ? data.centerHead : data.centerTail;\n        for (uint256 i; i < maxFillsPerUpkeep; ++i) {\n            if (target == 0) break;\n            BatchOrder storage order = orderBook[target];\n            OrderStatus status = _getOrderStatus(currentTick, order.tickLower, order.tickUpper, order.direction);\n            if (status == OrderStatus.ITM) {\n                _fulfillOrder(target, pool, order, estimatedFee);\n                target = walkDirection ? order.head : order.tail;\n                // Reconnect List and Zero out orders head and tail values removing order from the list.\n                orderBook[order.tail].head = order.head;\n                orderBook[order.head].tail = order.tail;\n                order.head = 0;\n                order.tail = 0;\n                // Update bool to indicate batch order is ready to handle claims.\n                claim[order.batchId].isReadyForClaim = true;\n                // Zero out orders batch id.\n                order.batchId = 0;\n                // Reset user count.\n                order.userCount = 0;\n                orderFilled = true;\n            } else break;\n        }\n        if (!orderFilled) revert LimitOrderRegistry__NoOrdersToFulfill();\n        // Continue walking the list towards head/tail until we find the next order that matches walk direction.\n        // Then update center.\n        while (target != 0) {\n            // Note use storage here because memory makes the contract too large.\n            BatchOrder storage order = orderBook[target];\n            if (order.direction == walkDirection) break;\n            target = walkDirection ? order.head : order.tail;\n        }\n        if (walkDirection) {\n            data.centerHead = target;\n            // Need to reconnect list.\n            orderBook[data.centerTail].head = target;\n            if (target != 0) orderBook[target].tail = data.centerTail;\n        } else {\n            data.centerTail = target;\n            // Need to reconnect list.\n            orderBook[data.centerHead].tail = target;\n            if (target != 0) orderBook[target].head = data.centerHead;\n        }\n    }\n    /*//////////////////////////////////////////////////////////////\n                     INTERNAL ORDER LOGIC\n    //////////////////////////////////////////////////////////////*/\n    /**\n     * @notice Check if a given Uniswap V3 position is already in the `orderBook`.\n     * @dev Looks at Nodes head and tail, and checks for edge case of node being the only node in the `orderBook`\n     */\n    function _checkThatNodeIsInList(uint256 node, BatchOrder memory order, PoolData memory data) internal pure {\n        if (order.head == 0 && order.tail == 0) {\n            // Possible but the order may be centerTail or centerHead.\n            if (data.centerHead != node && data.centerTail != node) revert LimitOrderRegistry__OrderNotInList(node);\n        }\n    }\n    /**\n     * @notice Finds appropriate spot in `orderBook` for an order.\n     */\n    function _findSpot(\n        PoolData memory data,\n        uint256 startingNode,\n        int24 targetTick\n    ) internal view returns (uint256 proposedHead, uint256 proposedTail) {\n        BatchOrder memory node;\n        if (startingNode == 0) {\n            if (data.centerHead != 0) {\n                startingNode = data.centerHead;\n                node = orderBook[startingNode];\n            } else if (data.centerTail != 0) {\n                startingNode = data.centerTail;\n                node = orderBook[startingNode];\n            } else return (0, 0);\n        } else {\n            node = orderBook[startingNode];\n            _checkThatNodeIsInList(startingNode, node, data);\n        }\n        uint256 nodeId = startingNode;\n        bool direction = targetTick > node.tickUpper ? true : false;\n        while (true) {\n            if (direction) {\n                // Go until we find an order with a tick lower GREATER or equal to targetTick, then set proposedTail equal to the tail, and proposed head to the current node.\n                if (node.tickLower >= targetTick) {\n                    return (nodeId, node.tail);\n                } else if (node.head == 0) {\n                    // Made it to head of list.\n                    return (0, nodeId);\n                } else {\n                    nodeId = node.head;\n                    node = orderBook[nodeId];\n                }\n            } else {\n                // Go until we find tick upper that is LESS than or equal to targetTick\n                if (node.tickUpper <= targetTick) {\n                    return (node.head, nodeId);\n                } else if (node.tail == 0) {\n                    // Made it to the tail of the list.\n                    return (nodeId, 0);\n                } else {\n                    nodeId = node.tail;\n                    node = orderBook[nodeId];\n                }\n            }\n        }\n    }\n    /**\n     * @notice Checks if newly added order should be made the new center head/tail.\n     */\n    function _updateCenter(\n        UniswapV3Pool pool,\n        uint256 positionId,\n        int24 currentTick,\n        int24 upper,\n        int24 lower\n    ) internal {\n        PoolData memory data = poolToData[pool];\n        if (currentTick > upper) {\n            // Check if centerTail needs to be updated.\n            if (data.centerTail == 0) {\n                // Currently no centerTail, so this order must become it.\n                poolToData[pool].centerTail = positionId;\n            } else {\n                BatchOrder memory centerTail = orderBook[data.centerTail];\n                if (upper > centerTail.tickUpper) {\n                    // New position is closer to the current pool tick, so it becomes new centerTail.\n                    poolToData[pool].centerTail = positionId;\n                }\n                // else nothing to do.\n            }\n        } else if (currentTick < lower) {\n            // Check if centerHead needs to be updated.\n            if (data.centerHead == 0) {\n                // Currently no centerHead, so this order must become it.\n                poolToData[pool].centerHead = positionId;\n            } else {\n                BatchOrder memory centerHead = orderBook[data.centerHead];\n                if (lower < centerHead.tickLower) {\n                    // New position is closer to the current pool tick, so it becomes new centerHead.\n                    poolToData[pool].centerHead = positionId;\n                }\n                // else nothing to do.\n            }\n        }\n    }\n    /**\n     * @notice Add a Uniswap V3 LP position to the `orderBook`.\n     */\n    function _addPositionToList(\n        PoolData memory data,\n        uint256 startingNode,\n        int24 targetTick,\n        uint256 position\n    ) internal {\n        (uint256 head, uint256 tail) = _findSpot(data, startingNode, targetTick);\n        if (tail != 0) {\n            orderBook[tail].head = position;\n            orderBook[position].tail = tail;\n        }\n        if (head != 0) {\n            orderBook[head].tail = position;\n            orderBook[position].head = head;\n        }\n    }\n    /**\n     * @notice Setup a newly minted LP position, or one being reused.\n     * @dev Sets batchId, and direction.\n     */\n    function _setupOrder(bool direction, uint256 position) internal {\n        BatchOrder storage order = orderBook[position];\n        order.batchId = batchCount;\n        order.direction = direction;\n        batchCount++;\n    }\n    /**\n     * @notice Updates a BatchOrder's token0/token1 amount, as well as associated\n     *         `batchIdToUserDepositAmount` mapping value.\n     * @dev If user is new to the order, increment userCount.\n     */\n    function _updateOrder(uint256 positionId, address user, uint128 amount) internal returns (uint128 userTotal) {\n        BatchOrder storage order = orderBook[positionId];\n        if (order.direction) {\n            // token1\n            order.token0Amount += amount;\n        } else {\n            // token0\n            order.token1Amount += amount;\n        }\n        // Check if user is already in the order.\n        uint128 batchId = order.batchId;\n        uint128 originalDepositAmount = batchIdToUserDepositAmount[batchId][user];\n        // If this is a new user in the order, add 1 to userCount.\n        if (originalDepositAmount == 0) order.userCount++;\n        batchIdToUserDepositAmount[batchId][user] = originalDepositAmount + amount;\n        return (originalDepositAmount + amount);\n    }\n    /**\n     * @notice Mints a new Uniswap V3 LP position.\n     */\n    function _mintPosition(\n        PoolData memory data,\n        int24 upper,\n        int24 lower,\n        uint128 amount0,\n        uint128 amount1,\n        bool direction\n    ) internal returns (uint256) {\n        if (direction) data.token0.safeApprove(address(POSITION_MANAGER), amount0);\n        else data.token1.safeApprove(address(POSITION_MANAGER), amount1);\n\n        // 0.9999e18 accounts for rounding errors in the Uniswap V3 protocol.\n        uint128 amount0Min = amount0 == 0 ? 0 : (amount0 * 0.9999e4) / 1e4;\n        uint128 amount1Min = amount1 == 0 ? 0 : (amount1 * 0.9999e4) / 1e4;\n\n        // Create mint params.\n        NonFungiblePositionManager.MintParams memory params = NonFungiblePositionManager.MintParams({\n\n    \n          \n            \n    \n\n          \n          Expand Down\n    \n    \n  \n            token0: address(data.token0),\n            token1: address(data.token1),\n            fee: data.fee,\n            tickLower: lower,\n            tickUpper: upper,\n            amount0Desired: amount0,\n            amount1Desired: amount1,\n            amount0Min: amount0Min,\n            amount1Min: amount1Min,\n            recipient: address(this),\n            deadline: block.timestamp\n        });\n        // Supply liquidity to pool.\n        (uint256 tokenId, , , ) = POSITION_MANAGER.mint(params);\n        // Revert if tokenId received is 0 id.\n        // Zero token id is reserved for NULL values in linked list.\n        if (tokenId == 0) revert LimitOrderRegistry__InvalidPositionId();\n        // If position manager still has allowance, zero it out.\n        if (direction && data.token0.allowance(address(this), address(POSITION_MANAGER)) > 0)\n            data.token0.safeApprove(address(POSITION_MANAGER), 0);\n        if (!direction && data.token1.allowance(address(this), address(POSITION_MANAGER)) > 0)\n            data.token1.safeApprove(address(POSITION_MANAGER), 0);\n        return tokenId;\n    }\n    /**\n     * @notice Adds liquidity to a given `positionId`.\n     */\n    function _addToPosition(\n        PoolData memory data,\n        uint256 positionId,\n        uint128 amount0,\n        uint128 amount1,\n        bool direction\n    ) internal {\n        if (direction) data.token0.safeApprove(address(POSITION_MANAGER), amount0);\n        else data.token1.safeApprove(address(POSITION_MANAGER), amount1);\n        uint128 amount0Min = amount0 == 0 ? 0 : (amount0 * 0.9999e18) / 1e18;\n        uint128 amount1Min = amount1 == 0 ? 0 : (amount1 * 0.9999e18) / 1e18;\n        // Create increase liquidity params.\n        NonFungiblePositionManager.IncreaseLiquidityParams memory params = NonFungiblePositionManager\n            .IncreaseLiquidityParams({\n                tokenId: positionId,\n                amount0Desired: amount0,\n                amount1Desired: amount1,\n                amount0Min: amount0Min,\n                amount1Min: amount1Min,\n                deadline: block.timestamp\n            });\n        // Increase liquidity in pool.\n        POSITION_MANAGER.increaseLiquidity(params);\n        // If position manager still has allowance, zero it out.\n        if (direction && data.token0.allowance(address(this), address(POSITION_MANAGER)) > 0)\n            data.token0.safeApprove(address(POSITION_MANAGER), 0);\n        if (!direction && data.token1.allowance(address(this), address(POSITION_MANAGER)) > 0)\n            data.token1.safeApprove(address(POSITION_MANAGER), 0);\n    }\n    /**\n     * @notice Enforces minimum liquidity requirements for orders.\n     */\n    function _enforceMinimumLiquidity(uint256 amount, ERC20 asset) internal view {\n        uint256 minimum = minimumAssets[asset];\n        if (minimum == 0) revert LimitOrderRegistry__MinimumNotSet(address(asset));\n        if (amount < minimum) revert LimitOrderRegistry__MinimumNotMet(address(asset), minimum, amount);\n    }\n    /**\n     * @notice Helper function to determine an orders status.\n     * @dev Returns\n     *      - ITM if order is ready to be filled, and is composed of wanted asset\n     *      - OTM if order is not ready to be filled, but order can still be cancelled, because order is composed of asset to sell\n     *      - MIXED order is composed of both wanted asset, and asset to sell, can not be fulfilled or cancelled.\n     */\n    function _getOrderStatus(\n        int24 currentTick,\n        int24 lower,\n        int24 upper,\n        bool direction\n    ) internal pure returns (OrderStatus status) {\n        if (upper == lower) revert LimitOrderRegistry__InvalidTickRange(upper, lower);\n        if (direction) {\n            // Indicates we want to go lower -> upper.\n            if (currentTick > upper) return OrderStatus.ITM;\n            if (currentTick >= lower) return OrderStatus.MIXED;\n            else return OrderStatus.OTM;\n        } else {\n            // Indicates we want to go upper -> lower.\n            if (currentTick < lower) return OrderStatus.ITM;\n            if (currentTick <= upper) return OrderStatus.MIXED;\n            else return OrderStatus.OTM;\n        }\n    }\n    /**\n     * @notice Called during `performUpkeep` to fulfill an ITM order.\n     * @dev Sets Claim info, removes all liquidity from position, and zeroes out BatchOrder amount0 and amount1 values.\n     */\n    function _fulfillOrder(\n        uint256 target,\n        UniswapV3Pool pool,\n        BatchOrder storage order,\n        uint256 estimatedFee\n    ) internal {\n        // Save fee per user in Claim Struct.\n        uint256 totalUsers = order.userCount;\n        Claim storage newClaim = claim[order.batchId];\n        newClaim.feePerUser = uint128(estimatedFee / totalUsers);\n        newClaim.pool = pool;\n        // Take all liquidity from the order.\n        uint128 amount0;\n        uint128 amount1;\n        (amount0, amount1) = _takeFromPosition(target, pool, 1e18);\n        if (order.direction) {\n            // Copy the tokenIn amount from the order, this is the total user deposit.\n            newClaim.token0Amount = order.token0Amount;\n            // Total token out is amount1.\n            newClaim.token1Amount = amount1;\n        } else {\n            // Copy the tokenIn amount from the order, this is the total user deposit.\n            newClaim.token1Amount = order.token1Amount;\n            // Total token out is amount0.\n            newClaim.token0Amount = amount0;\n        }\n        newClaim.direction = order.direction;\n        // Zero out order balances.\n        order.token0Amount = 0;\n        order.token1Amount = 0;\n        emit OrderFilled(order.batchId, address(pool));\n    }\n    /**\n     * @notice Removes liquidity from `target` Uniswap V3 LP position.\n     * @dev Collects fees from `target` position, and saves them in `tokenToSwapFees`.\n     */\n    function _takeFromPosition(\n        uint256 target,\n        UniswapV3Pool pool,\n        uint256 liquidityPercent\n    ) internal returns (uint128, uint128) {\n        (, , , , , , , uint128 liquidity, , , , ) = POSITION_MANAGER.positions(target);\n        liquidity = uint128(uint256(liquidity * liquidityPercent) / 1e18);\n        // Create decrease liquidity params.\n        NonFungiblePositionManager.DecreaseLiquidityParams memory params = NonFungiblePositionManager\n            .DecreaseLiquidityParams({\n                tokenId: target,\n                liquidity: liquidity,\n                amount0Min: 0,\n                amount1Min: 0,\n                deadline: block.timestamp\n            });\n        // Decrease liquidity in pool.\n        uint128 amount0;\n        uint128 amount1;\n        {\n            (uint256 a0, uint256 a1) = POSITION_MANAGER.decreaseLiquidity(params);\n            amount0 = uint128(a0);\n            amount1 = uint128(a1);\n        }\n        // If completely closing position, then collect fees as well.\n        NonFungiblePositionManager.CollectParams memory collectParams;\n        {\n            uint128 amount0Max;\n            uint128 amount1Max;\n            if (liquidityPercent == 1e18) {\n                amount0Max = type(uint128).max;\n                amount1Max = type(uint128).max;\n            } else {\n                // Otherwise only collect principal.\n                amount0Max = amount0;\n                amount1Max = amount1;\n            }\n            // Create fee collection params.\n            collectParams = NonFungiblePositionManager.CollectParams({\n                tokenId: target,\n                recipient: address(this),\n                amount0Max: amount0Max,\n                amount1Max: amount1Max\n            });\n        }\n        // Save token balances.\n        ERC20 token0 = poolToData[pool].token0;\n        ERC20 token1 = poolToData[pool].token1;\n        uint256 token0Balance = token0.balanceOf(address(this));\n        uint256 token1Balance = token1.balanceOf(address(this));\n        // Collect fees.\n        POSITION_MANAGER.collect(collectParams);\n        // Save fees earned, take the total token amount out - the amount removed from liquidity to get the fees earned.\n        uint128 token0Fees = uint128(token0.balanceOf(address(this)) - token0Balance) - amount0;\n        uint128 token1Fees = uint128(token1.balanceOf(address(this)) - token1Balance) - amount1;\n        // Save any swap fees.\n        if (token0Fees > 0) tokenToSwapFees[address(token0)] += token0Fees;\n        if (token1Fees > 0) tokenToSwapFees[address(token1)] += token1Fees;\n        return (amount0, amount1);\n    }\n    /**\n     * @notice Removes an order from the `orderBook`.\n     * @dev Checks if order is one of the center values, and updates the head if need be.\n     */\n    function _removeOrderFromList(uint256 target, UniswapV3Pool pool, BatchOrder storage order) internal {\n        // Checks if order is the center, if so then it will set it to the the center orders head(which is okay if it is zero).\n        uint256 centerHead = poolToData[pool].centerHead;\n        uint256 centerTail = poolToData[pool].centerTail;\n        if (target == centerHead) {\n            uint256 newHead = orderBook[centerHead].head;\n            poolToData[pool].centerHead = newHead;\n        } else if (target == centerTail) {\n            uint256 newTail = orderBook[centerTail].tail;\n            poolToData[pool].centerTail = newTail;\n        }\n        // Remove order from linked list.\n        orderBook[order.tail].head = order.head;\n        orderBook[order.head].tail = order.tail;\n        order.head = 0;\n        order.tail = 0;\n    }\n    /**\n     * @notice Helper function to get the gas price used for fee calculation.\n     */\n    function getGasPrice() public view returns (uint256) {\n        // If gas feed is set use it.\n        if (fastGasFeed != address(0)) {\n            (, int256 _answer, , uint256 _timestamp, ) = IChainlinkAggregator(fastGasFeed).latestRoundData();\n            uint256 timeSinceLastUpdate = block.timestamp - _timestamp;\n            // Check answer is not stale.\n            if (timeSinceLastUpdate > FAST_GAS_HEARTBEAT) {\n                // If answer is stale use owner set value.\n                // Multiply by 1e9 to convert gas price to gwei\n                return uint256(upkeepGasPrice) * 1e9;\n            } else {\n                // Else use the datafeed value.\n                uint256 answer = uint256(_answer);\n                return answer;\n            }\n        }\n        // Else use owner set value.\n        return uint256(upkeepGasPrice) * 1e9; // Multiply by 1e9 to convert gas price to gwei\n    }\n    /*//////////////////////////////////////////////////////////////\n                            VIEW LOGIC\n    //////////////////////////////////////////////////////////////*/\n    /**\n     * @notice Helper function that finds the appropriate spot in the linked list for a new order.\n     * @param pool the Uniswap V3 pool you want to create an order in\n     * @param startingNode the UniV3 position Id to start looking\n     * @param targetTick the targetTick of the order you want to place\n     * @return proposedHead , proposedTail pr the correct head and tail for the new order\n     * @dev if both head and tail are zero, just pass in zero for the `startingNode`\n     *      otherwise pass in either the nonzero head or nonzero tail for the `startingNode`\n     */\n    function findSpot(\n        UniswapV3Pool pool,\n        uint256 startingNode,\n        int24 targetTick\n    ) external view returns (uint256 proposedHead, uint256 proposedTail) {\n        PoolData memory data = poolToData[pool];\n        int24 tickSpacing = pool.tickSpacing();\n        // Make sure targetTick is divisible by spacing.\n        if (targetTick % tickSpacing != 0) revert LimitOrderRegistry__InvalidTargetTick(targetTick, tickSpacing);\n        (proposedHead, proposedTail) = _findSpot(data, startingNode, targetTick);\n    }\n    /**\n     * @notice Helper function to get the fee per user for a specific order.\n     */\n    function getFeePerUser(uint128 batchId) external view returns (uint128) {\n        return claim[batchId].feePerUser;\n    }\n    /**\n     * @notice Helper function to view if a BatchOrder is ready to claim.\n     */\n    function isOrderReadyForClaim(uint128 batchId) external view returns (bool) {\n        return claim[batchId].isReadyForClaim;\n    }\n    function getOrderBook(uint256 id) external view returns (BatchOrder memory) {\n        return orderBook[id];\n    }\n    function getClaim(uint128 batchId) external view returns (Claim memory) {\n        return claim[batchId];\n    }\n}"
    },
    {
        "tag": "arithmetic",
        "url": "https://github.com/capofficial/protocol/commit/5959965e1e7c2c957b762a29bd00cbddc80a0189",
        "file": "src/Pool.sol",
        "before": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.13;\nimport \"./Store.sol\";\ncontract Pool {\n    uint256 public constant BPS_DIVIDER = 10000;\n    address public gov;\n    address public trade;\n    address public treasury;\n    Store public store;\n    // Events\n    event AddLiquidity(address indexed user, uint256 amount, uint256 clpAmount, uint256 poolBalance);\n    event RemoveLiquidity(\n        address indexed user, uint256 amount, uint256 feeAmount, uint256 clpAmount, uint256 poolBalance\n    );\n    event PoolPayIn(\n        address indexed user,\n        string market,\n        uint256 amount,\n        uint256 bufferToPoolAmount,\n        uint256 poolBalance,\n        uint256 bufferBalance\n    );\n    event PoolPayOut(address indexed user, string market, uint256 amount, uint256 poolBalance, uint256 bufferBalance);\n    event FeePaid(address indexed user, string market, uint256 fee, uint256 poolFee, bool isLiquidation);\n    // Methods\n    constructor() {\n        gov = msg.sender;\n    }\n    function updateGov(address _gov) external onlyGov {\n        gov = _gov;\n    }\n    function link(address _trade, address _store, address _treasury) external onlyGov {\n        trade = _trade;\n        store = Store(_store);\n        treasury = _treasury;\n    }\n    function addLiquidity(uint256 amount) external {\n        require(amount > 0, \"!amount\");\n        uint256 balance = store.poolBalance();\n        address user = msg.sender;\n        store.transferIn(user, amount);\n        uint256 clpSupply = store.getCLPSupply();\n        uint256 clpAmount = balance == 0 || clpSupply == 0 ? amount : amount * clpSupply / balance;\n        store.mintCLP(user, clpAmount);\n        store.incrementPoolBalance(amount);\n        emit AddLiquidity(user, amount, clpAmount, store.poolBalance());\n    }\n    function addLiquidityThroughUniswap(address tokenIn, uint256 amountIn, uint256 amountOutMin, uint24 poolFee)\n        external\n        payable\n    {\n        if (msg.value == 0) {\n            require(amountIn > 0, \"!amount\");\n            require(tokenIn != address(0), \"!address\");\n        }\n        address user = msg.sender;\n        // executes swap, tokens will be deposited to store contract\n        uint256 amountOut = store.swapExactInputSingle{value: msg.value}(user, amountIn, amountOutMin, tokenIn, poolFee);\n        // add store supported liquidity\n        uint256 balance = store.poolBalance();\n        uint256 clpSupply = store.getCLPSupply();\n        uint256 clpAmount = balance == 0 || clpSupply == 0 ? amountOut : amountOut * clpSupply / balance;\n        store.mintCLP(user, clpAmount);\n        store.incrementPoolBalance(amountOut);\n        emit AddLiquidity(user, amountOut, clpAmount, store.poolBalance());\n    }\n    function removeLiquidity(uint256 amount) external {\n        require(amount > 0, \"!amount\");\n        address user = msg.sender;\n        uint256 balance = store.poolBalance();\n        uint256 clpSupply = store.getCLPSupply();\n        require(balance > 0 && clpSupply > 0, \"!empty\");\n        uint256 userBalance = store.getUserPoolBalance(user);\n        if (amount > userBalance) amount = userBalance;\n        uint256 feeAmount = amount * store.poolWithdrawalFee() / BPS_DIVIDER;\n        uint256 amountMinusFee = amount - feeAmount;\n        // CLP amount\n        uint256 clpAmount = amountMinusFee * clpSupply / balance;\n        store.burnCLP(user, clpAmount);\n        store.decrementPoolBalance(amountMinusFee);\n        store.transferOut(user, amountMinusFee);\n        emit RemoveLiquidity(user, amount, feeAmount, clpAmount, store.poolBalance());\n    }\n    function creditTraderLoss(address user, string memory market, uint256 amount) external onlyTrade {\n        store.incrementBufferBalance(amount);\n        uint256 lastPaid = store.poolLastPaid();\n        uint256 _now = block.timestamp;\n        if (lastPaid == 0) {\n            store.setPoolLastPaid(_now);\n            return;\n        }\n        uint256 bufferBalance = store.bufferBalance();\n        uint256 bufferPayoutPeriod = store.bufferPayoutPeriod();\n        uint256 amountToSendPool = bufferBalance * (block.timestamp - lastPaid) / bufferPayoutPeriod;\n        if (amountToSendPool > bufferBalance) amountToSendPool = bufferBalance;\n        store.incrementPoolBalance(amountToSendPool);\n        store.decrementBufferBalance(amountToSendPool);\n        store.setPoolLastPaid(_now);\n        store.decrementBalance(user, amount);\n        emit PoolPayIn(user, market, amount, amountToSendPool, store.poolBalance(), store.bufferBalance());\n    }\n    function debitTraderProfit(address user, string memory market, uint256 amount) external onlyTrade {\n        if (amount == 0) return;\n\n        uint256 bufferBalance = store.bufferBalance();\n\n        store.decrementBufferBalance(amount);\n\n        if (amount > bufferBalance) {\n            uint256 diffToPayFromPool = amount - bufferBalance;\n            uint256 poolBalance = store.poolBalance();\n            require(diffToPayFromPool < poolBalance, \"!pool-balance\");\n            store.decrementPoolBalance(diffToPayFromPool);\n        }\n\n        store.incrementBalance(user, amount);\n\n    \n          \n            \n    \n\n          \n          Expand Down\n    \n    \n  \n        emit PoolPayOut(user, market, amount, store.poolBalance(), store.bufferBalance());\n    }\n    function creditFee(address user, string memory market, uint256 fee, bool isLiquidation) external onlyTrade {\n        if (fee == 0) return;\n        uint256 poolFee = fee * store.poolFeeShare() / BPS_DIVIDER;\n        uint256 treasuryFee = fee - poolFee;\n        store.incrementPoolBalance(poolFee);\n        store.transferOut(treasury, treasuryFee);\n        emit FeePaid(\n            user,\n            market,\n            fee, // paid by user //\n            poolFee,\n            isLiquidation\n            );\n    }\n    modifier onlyTrade() {\n        require(msg.sender == trade, \"!trade\");\n        _;\n    }\n    modifier onlyGov() {\n        require(msg.sender == gov, \"!gov\");\n        _;\n    }\n}",
        "after": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.13;\nimport \"./Store.sol\";\ncontract Pool {\n    uint256 public constant BPS_DIVIDER = 10000;\n    address public gov;\n    address public trade;\n    address public treasury;\n    Store public store;\n    // Events\n    event AddLiquidity(address indexed user, uint256 amount, uint256 clpAmount, uint256 poolBalance);\n    event RemoveLiquidity(\n        address indexed user, uint256 amount, uint256 feeAmount, uint256 clpAmount, uint256 poolBalance\n    );\n    event PoolPayIn(\n        address indexed user,\n        string market,\n        uint256 amount,\n        uint256 bufferToPoolAmount,\n        uint256 poolBalance,\n        uint256 bufferBalance\n    );\n    event PoolPayOut(address indexed user, string market, uint256 amount, uint256 poolBalance, uint256 bufferBalance);\n    event FeePaid(address indexed user, string market, uint256 fee, uint256 poolFee, bool isLiquidation);\n    // Methods\n    constructor() {\n        gov = msg.sender;\n    }\n    function updateGov(address _gov) external onlyGov {\n        gov = _gov;\n    }\n    function link(address _trade, address _store, address _treasury) external onlyGov {\n        trade = _trade;\n        store = Store(_store);\n        treasury = _treasury;\n    }\n    function addLiquidity(uint256 amount) external {\n        require(amount > 0, \"!amount\");\n        uint256 balance = store.poolBalance();\n        address user = msg.sender;\n        store.transferIn(user, amount);\n        uint256 clpSupply = store.getCLPSupply();\n        uint256 clpAmount = balance == 0 || clpSupply == 0 ? amount : amount * clpSupply / balance;\n        store.mintCLP(user, clpAmount);\n        store.incrementPoolBalance(amount);\n        emit AddLiquidity(user, amount, clpAmount, store.poolBalance());\n    }\n    function addLiquidityThroughUniswap(address tokenIn, uint256 amountIn, uint256 amountOutMin, uint24 poolFee)\n        external\n        payable\n    {\n        if (msg.value == 0) {\n            require(amountIn > 0, \"!amount\");\n            require(tokenIn != address(0), \"!address\");\n        }\n        address user = msg.sender;\n        // executes swap, tokens will be deposited to store contract\n        uint256 amountOut = store.swapExactInputSingle{value: msg.value}(user, amountIn, amountOutMin, tokenIn, poolFee);\n        // add store supported liquidity\n        uint256 balance = store.poolBalance();\n        uint256 clpSupply = store.getCLPSupply();\n        uint256 clpAmount = balance == 0 || clpSupply == 0 ? amountOut : amountOut * clpSupply / balance;\n        store.mintCLP(user, clpAmount);\n        store.incrementPoolBalance(amountOut);\n        emit AddLiquidity(user, amountOut, clpAmount, store.poolBalance());\n    }\n    function removeLiquidity(uint256 amount) external {\n        require(amount > 0, \"!amount\");\n        address user = msg.sender;\n        uint256 balance = store.poolBalance();\n        uint256 clpSupply = store.getCLPSupply();\n        require(balance > 0 && clpSupply > 0, \"!empty\");\n        uint256 userBalance = store.getUserPoolBalance(user);\n        if (amount > userBalance) amount = userBalance;\n        uint256 feeAmount = amount * store.poolWithdrawalFee() / BPS_DIVIDER;\n        uint256 amountMinusFee = amount - feeAmount;\n        // CLP amount\n        uint256 clpAmount = amountMinusFee * clpSupply / balance;\n        store.burnCLP(user, clpAmount);\n        store.decrementPoolBalance(amountMinusFee);\n        store.transferOut(user, amountMinusFee);\n        emit RemoveLiquidity(user, amount, feeAmount, clpAmount, store.poolBalance());\n    }\n    function creditTraderLoss(address user, string memory market, uint256 amount) external onlyTrade {\n        store.incrementBufferBalance(amount);\n        uint256 lastPaid = store.poolLastPaid();\n        uint256 _now = block.timestamp;\n        if (lastPaid == 0) {\n            store.setPoolLastPaid(_now);\n            return;\n        }\n        uint256 bufferBalance = store.bufferBalance();\n        uint256 bufferPayoutPeriod = store.bufferPayoutPeriod();\n        uint256 amountToSendPool = bufferBalance * (block.timestamp - lastPaid) / bufferPayoutPeriod;\n        if (amountToSendPool > bufferBalance) amountToSendPool = bufferBalance;\n        store.incrementPoolBalance(amountToSendPool);\n        store.decrementBufferBalance(amountToSendPool);\n        store.setPoolLastPaid(_now);\n        store.decrementBalance(user, amount);\n        emit PoolPayIn(user, market, amount, amountToSendPool, store.poolBalance(), store.bufferBalance());\n    }\n    function debitTraderProfit(address user, string memory market, uint256 amount) external onlyTrade {\n        if (amount == 0) return;\n\n        uint256 bufferBalance = store.bufferBalance();\n\n        if (amount > bufferBalance) {\n            uint256 diffToPayFromPool = amount - bufferBalance;\n            uint256 poolBalance = store.poolBalance();\n            require(diffToPayFromPool < poolBalance, \"!pool-balance\");\n            store.decrementPoolBalance(diffToPayFromPool);\n        } else {\n            store.decrementBufferBalance(amount);\n        }\n\n        store.incrementBalance(user, amount);\n\n    \n          \n            \n    \n\n          \n          Expand Down\n    \n    \n  \n        emit PoolPayOut(user, market, amount, store.poolBalance(), store.bufferBalance());\n    }\n    function creditFee(address user, string memory market, uint256 fee, bool isLiquidation) external onlyTrade {\n        if (fee == 0) return;\n        uint256 poolFee = fee * store.poolFeeShare() / BPS_DIVIDER;\n        uint256 treasuryFee = fee - poolFee;\n        store.incrementPoolBalance(poolFee);\n        store.transferOut(treasury, treasuryFee);\n        emit FeePaid(\n            user,\n            market,\n            fee, // paid by user //\n            poolFee,\n            isLiquidation\n            );\n    }\n    modifier onlyTrade() {\n        require(msg.sender == trade, \"!trade\");\n        _;\n    }\n    modifier onlyGov() {\n        require(msg.sender == gov, \"!gov\");\n        _;\n    }\n}"
    },
    {
        "tag": "denial of service",
        "url": "https://github.com/p2p-org/eth-staking-fee-distributor-contracts/commit/49db3033572a125fbafa25b3ea7c0eaae0c113be",
        "file": "",
        "before": "",
        "after": ""
    },
    {
        "tag": "reentrancy",
        "url": "https://github.com/morpho-labs/smart-contract-challenges/commit/e51704e408d0173621e70bc21106fd73b14ec86e",
        "file": "src/Hack.sol",
        "before": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n// These contracts are examples of contracts with bugs and vulnerabilities to practice your hacking skills.\n// DO NOT USE THEM OR GET INSPIRATION FROM THEM TO MAKE CODE USED IN PRODUCTION\n// You are required to find vulnerabilities where an attacker harms someone else.\n// Being able to destroy your own stuff is not a vulnerability and should be dealt at the interface level.\n/* Exercise 1 */\n/// @dev Contract to store and redeem money.\ncontract Store {\n    struct Safe {\n        address owner;\n        uint256 amount;\n    }\n    Safe[] public safes;\n    /// @dev Stores some ETH.\n    function store() public payable {\n        safes.push(Safe({owner: msg.sender, amount: msg.value}));\n    }\n    /// @dev Takes back all the amount stored by the sender.\n    function take() public {\n        for (uint256 i; i < safes.length; ++i) {\n            Safe storage safe = safes[i];\n            if (safe.owner == msg.sender && safe.amount != 0) {\n                payable(msg.sender).transfer(safe.amount);\n                safe.amount = 0;\n            }\n        }\n\n    \n          \n            \n    \n\n          \n          Expand Down\n          \n            \n    \n\n          \n          Expand Up\n    \n    @@ -64,7 +65,7 @@ contract DiscountedBuy {\n  \n    }\n}\n/* Exercise 2 */\n/// @dev You can buy some objects.\n///      Further purchases are discounted.\n///      You need to pay basePrice / (1 + objectBought), where objectBought is the number of objects you previously bought.\ncontract DiscountedBuy {\n    uint256 public basePrice = 1 ether;\n    mapping(address => uint256) public objectBought;\n    /// @dev Buy an object.\n    function buy() public payable {\n        require(msg.value * (1 + objectBought[msg.sender]) == basePrice);\n        objectBought[msg.sender] += 1;\n    }\n    /// @dev Returns the price you'll need to pay.\n    /// @return The amount you need to pay in wei.\n    function price() public view returns (uint256) {\n        return basePrice / (1 + objectBought[msg.sender]);\n    }\n}\n/* Exercise 3 */\n/// @dev One party chooses Head or Tail and sends 1 ETH.\n///      The next party sends 1 ETH and tries to guess what the first party chose.\n///      If they succeed, they get 2 ETH, else the first party gets 2 ETH.\ncontract HeadOrTail {\n    bool public chosen; // True if the choice has been made.\n    bool public lastChoiceHead; // True if the choice is head.\n    address payable public lastParty; // The last party who chose.\n\n    /// @dev Must be sent 1 ETH.\n    ///      Choose Head or Tail to be guessed by the other player.\n\n    \n        \n          \n    \n\n        \n        Expand All\n    \n    @@ -75,7 +76,7 @@ contract HeadOrTail {\n  \n    /// @param _chooseHead True if Head was chosen, false if Tail was chosen.\n    function choose(bool _chooseHead) public payable {\n        require(!chosen);\n        require(msg.value == 1 ether);\n\n        chosen = true;\n        lastChoiceHead = _chooseHead;\n        lastParty = payable(msg.sender);\n    }\n\n    /// @dev Guesses the choice of the first party and resolves the Head or Tail Game.\n\n    \n        \n          \n    \n\n        \n        Expand All\n    \n    @@ -84,9 +85,15 @@ contract HeadOrTail {\n  \n    /// @param _guessHead The guess (Head or Tail) of the opposite party.\n    function guess(bool _guessHead) public payable {\n        require(chosen);\n        require(msg.value == 1 ether);\n\n        if (_guessHead == lastChoiceHead) payable(msg.sender).transfer(2 ether);\n        else lastParty.transfer(2 ether);\n\n        chosen = false;\n    }\n}\n\n    \n        \n          \n    \n\n        \n        Expand All\n    \n    @@ -105,7 +112,7 @@ contract Vault {\n  \n/* Exercise 4 */\n/// @dev Contract managing the storage and the redemption of ETH.\ncontract Vault {\n    mapping(address => uint256) public balances;\n    /// @dev Stores the ETH of the sender in the contract.\n    function store() public payable {\n        balances[msg.sender] += msg.value;\n    }\n    /// @dev Redeems the ETH of the sender in the contract.\n    function redeem() public {\n        (bool success,) = msg.sender.call{value: balances[msg.sender]}(\"\");\n        require(success);\n        balances[msg.sender] = 0;\n    }\n}\n\n    \n        \n          \n    \n\n        \n        Expand All\n    \n    @@ -116,8 +123,8 @@ contract Vault {\n  \n/* Exercise 5 */\n/// @dev One party chooses Head or Tail and sends 1 ETH.\n///      The next party sends 1 ETH and tries to guess what the first party chose.\n///      If they succeed, they get 2 ETH, else the first party gets 2 ETH.\ncontract HeadTail {\n    address payable public partyA;\n    address payable public partyB;\n    bytes32 public commitmentA;\n    bool public chooseHeadB;\n    uint256 public timeB;\n\n    \n        \n          \n    \n\n        \n        Expand All\n    \n    @@ -129,7 +136,7 @@ contract HeadTail {\n  \n    /* CONSTRUCTOR */\n    /// @param _commitmentA is the result of the following command: keccak256(abi.encode(chooseHead,randomNumber)).\n    constructor(bytes32 _commitmentA) payable {\n        require(msg.value == 1 ether);\n\n        commitmentA = _commitmentA;\n        partyA = payable(msg.sender);\n    }\n\n    /// @dev Guesses the choice of party A.\n\n    \n        \n          \n    \n\n        \n        Expand All\n    \n    @@ -140,7 +147,7 @@ contract HeadTail {\n  \n    /// @param _chooseHead True if the guess is Head, false otherwise.\n    function guess(bool _chooseHead) public payable {\n        require(msg.value == 1 ether);\n        require(partyB == address(0));\n\n        chooseHeadB = _chooseHead;\n        timeB = block.timestamp;\n        partyB = payable(msg.sender);\n    }\n\n    /// @dev Reveals the commited value and send ETH to the winner.\n\n    \n        \n          \n    \n\n        \n        Expand All\n    \n    @@ -151,16 +158,20 @@ contract HeadTail {\n  \n    /// @param _chooseHead True if Head was chosen, false otherwise.\n    /// @param _randomNumber The random number chosen to obfuscate the commitment.\n    function resolve(bool _chooseHead, uint256 _randomNumber) public {\n        require(msg.sender == partyA);\n        require(keccak256(abi.encode(_chooseHead, _randomNumber)) == commitmentA);\n        require(address(this).balance >= 2 ether);\n\n        if (_chooseHead == chooseHeadB) partyB.transfer(2 ether);\n        else partyA.transfer(2 ether);\n    }\n\n    /// @dev Time out party A if it takes more than 1 day to reveal.\n    ///      Sends ETH to party B.\n    function timeOut() public {\n        require(block.timestamp > timeB + 1 days);\n        require(address(this).balance >= 2 ether);\n        partyB.transfer(2 ether);\n    }\n}\n\n\n    \n          \n            \n    \n\n          \n          Expand Down\n          \n            \n    \n\n          \n          Expand Up\n    \n    @@ -207,7 +218,8 @@ contract LinearBondedCurve {\n  \n/* Exercise 6 */\n/// @dev Contract for a simple token that can be sent.\ncontract SimpleToken {\n    mapping(address => int256) public balances;\n    /* CONSTRUCTOR */\n    /// @dev Creator starts with all the tokens.\n    constructor() {\n        balances[msg.sender] += 1000e18;\n    }\n    /// @dev Sends token.\n    ///  @param _recipient The recipient.\n    /// @param _amount The amount to send.\n    function sendToken(address _recipient, int256 _amount) public {\n        balances[msg.sender] -= _amount;\n        balances[_recipient] += _amount;\n    }\n}\n/* Exercise 7 */\n/// @dev Contract for a simple token that can be exchanged through a bonded curve and sent.\n/// @notice We assume that order frontrunning is fine.\ncontract LinearBondedCurve {\n    mapping(address => uint256) public balances;\n    uint256 public totalSupply;\n    /// @dev Buys token. The price is linear to the total supply.\n    function buy() public payable {\n        uint256 tokenToReceive = (1e18 * msg.value) / (1e18 + totalSupply);\n        balances[msg.sender] += tokenToReceive;\n        totalSupply += tokenToReceive;\n    }\n    /// @dev Sells token. The price of it is linear to the supply.\n    /// @param _amount The amount of tokens to sell.\n    function sell(uint256 _amount) public {\n        uint256 ethToReceive = ((1e18 + totalSupply) * _amount) / 1e18;\n        balances[msg.sender] -= _amount;\n        totalSupply -= _amount;\n        payable(msg.sender).transfer(ethToReceive);\n    }\n\n    /// @dev Sends token.\n\n    \n          \n            \n    \n\n          \n          Expand Down\n          \n            \n    \n\n          \n          Expand Up\n    \n    @@ -252,8 +264,10 @@ contract Coffers {\n  \n    /// @param _recipient The recipient.\n    /// @param _amount The amount to send.\n    function sendToken(address _recipient, uint256 _amount) public {\n        balances[msg.sender] -= _amount;\n        balances[_recipient] += _amount;\n    }\n}\n/* Exercise 8 */\n/// @dev Contract to create coffers, deposit and withdraw money from them.\ncontract Coffers {\n    struct Coffer {\n        uint256 nbSlots;\n        mapping(uint256 => uint256) slots;\n    }\n    mapping(address => Coffer) public coffers;\n    /// @dev Creates coffers.\n    ///  @param _slots The amount of slots the coffer will have.\n    function createCoffer(uint256 _slots) external {\n        Coffer storage coffer = coffers[msg.sender];\n        require(coffer.nbSlots == 0, \"Coffer already created\");\n        coffer.nbSlots = _slots;\n    }\n    /// @dev Deposits money in one's coffer slot.\n    /// @param _owner The coffer to deposit money on.\n    /// @param _slot The slot to deposit money on.\n    function deposit(address _owner, uint256 _slot) external payable {\n        Coffer storage coffer = coffers[_owner];\n        require(_slot < coffer.nbSlots);\n        coffer.slots[_slot] += msg.value;\n    }\n    /// @dev Withdraws all of the money from one's coffer slot.\n    /// @param _slot The slot to withdraw money from.\n    function withdraw(uint256 _slot) external {\n        Coffer storage coffer = coffers[msg.sender];\n        require(_slot < coffer.nbSlots);\n        payable(msg.sender).transfer(coffer.slots[_slot]);\n        coffer.slots[_slot] = 0;\n    }\n\n    /// @dev Closes an account withdrawing all the money.\n\n    \n        \n          \n    \n\n        \n        Expand All\n    \n    @@ -264,7 +278,8 @@ contract Coffers {\n  \n    function closeAccount() external {\n        Coffer storage coffer = coffers[msg.sender];\n        uint256 amountToSend;\n        for (uint256 i = 0; i < coffer.nbSlots; ++i) {\n            amountToSend += coffer.slots[i];\n        }\n        coffer.nbSlots = 0;\n        payable(msg.sender).transfer(amountToSend);\n    }\n}\n\n\n    \n          \n            \n    \n\n          \n          Expand Down\n          \n            \n    \n\n          \n          Expand Up\n    \n    @@ -294,7 +309,8 @@ contract CommonCoffers {\n  \n/* Exercise 9 */\n/// @dev Contract for simple coffer to deposit to and withdraw from.\ncontract CommonCoffers {\n    mapping(address => uint256) public coffers;\n    uint256 public scalingFactor;\n    /// @dev Deposits money in one's coffer.\n    /// @param _owner The coffer to deposit money on.\n    function deposit(address _owner) external payable {\n        if (scalingFactor != 0) {\n            uint256 toAdd = (scalingFactor * msg.value) / (address(this).balance - msg.value);\n            coffers[_owner] += toAdd;\n            scalingFactor += toAdd;\n        } else {\n            scalingFactor = 100;\n            coffers[_owner] = 100;\n        }\n    }\n    /// @dev Withdraws all of the money from one's coffer.\n    /// @param _amount The amount to withdraw from one's coffer.\n    function withdraw(uint256 _amount) external {\n        uint256 toRemove = (scalingFactor * _amount) / address(this).balance;\n        coffers[msg.sender] -= toRemove;\n        scalingFactor -= toRemove;\n        payable(msg.sender).transfer(_amount);\n    }\n}\n\n\n    \n        \n          \n    \n\n        \n        Expand All\n    \n    @@ -309,7 +325,7 @@ contract Resolver {\n  \n/* Exercise 10 */\n/// @dev Two parties deposit on a particular side and the owner decides which side is correct.\n///      Owner's decision is based on some external factors irrelevant to this contract.\ncontract Resolver {\n    enum Side {\n        A,\n        B\n    }\n\n    address public owner = msg.sender;\n    address payable[2] public sides;\n\n    uint256 public baseDeposit;\n    uint256 public reward;\n\n    \n        \n          \n    \n\n        \n        Expand All\n    \n    @@ -332,7 +348,7 @@ contract Resolver {\n  \n    Side public winner;\n    bool public declared;\n    uint256[2] public partyDeposits;\n    /* CONSTRUCTOR */\n    /// @param _baseDeposit The deposit a party has to pay. Note that it is greater than the reward.\n    constructor(uint256 _baseDeposit) payable {\n        reward = msg.value;\n        baseDeposit = _baseDeposit;\n    }\n    /// @dev Makes a deposit to one of the sides.\n    /// @param _side The side chosen by the party.\n    function deposit(Side _side) public payable {\n        require(!declared, \"The winner is already declared\");\n        require(sides[uint256(_side)] == address(0), \"Side already paid\");\n        require(msg.value > baseDeposit, \"Should cover the base deposit\");\n        sides[uint256(_side)] = payable(msg.sender);\n        partyDeposits[uint256(_side)] = msg.value;\n    }\n\n\n    \n        \n          \n    \n\n        \n        Expand All\n    \n    @@ -347,27 +363,31 @@ contract Resolver {\n  \n    /// @dev Declares the winner as an owner.\n    ///      Note that in case no one funded for the winner side when the owner makes its transaction, having someone else deposit to get the reward is fine and doesn't affect the mechanism.\n    /// @param _winner The side that is eligible to a reward according to owner.\n    function declareWinner(Side _winner) public {\n        require(msg.sender == owner, \"Only owner allowed\");\n        require(!declared, \"Winner already declared\");\n        declared = true;\n        winner = _winner;\n    }\n\n    /// @dev Pays the reward to the winner. Reimburses the surplus deposit for both parties if there was one.\n    function payReward() public {\n        require(declared, \"The winner is not declared\");\n        uint256 depositA = partyDeposits[0];\n        uint256 depositB = partyDeposits[1];\n\n        partyDeposits[0] = 0;\n        partyDeposits[1] = 0;\n\n        // Pays the winner. Note that if no one put a deposit for the winning side, the reward will be burnt.\n        require(sides[uint256(winner)].send(reward), \"Unsuccessful send\");\n\n        // Reimburse the surplus deposit if there was one.\n        if (depositA > baseDeposit && sides[0] != address(0)) {\n            require(sides[0].send(depositA - baseDeposit), \"Unsuccessful send\");\n        }\n\n        if (depositB > baseDeposit && sides[1] != address(0)) {\n            require(sides[1].send(depositB - baseDeposit), \"Unsuccessful send\");\n        }\n\n        reward = 0;\n    }\n}\n\n\n    \n          \n            \n    \n\n          \n          Expand Down\n          \n            \n    \n\n          \n          Expand Up\n    \n    @@ -583,8 +603,8 @@ contract GuessTheAverage {\n  \n/* Exercise 11*/\n/// @dev Contract for users to register. It will be used by other contracts to attach rights to those users (rights will be linked to user IDs).\n///      Note that simply being registered does not confer any right.\ncontract Registry {\n    struct User {\n        address payable regAddress;\n        uint64 timestamp;\n        bool registered;\n        string name;\n        string surname;\n        uint256 nonce;\n    }\n    // Nonce is used so the contract can add multiple profiles with the same first name and last name.\n    mapping(string => mapping(string => mapping(uint256 => bool))) public isRegistered; // name -> surname -> nonce -> registered/not registered.\n    mapping(bytes32 => User) public users; // User isn't identified by address but by his ID, since the same person can have multiple addresses.\n    /// @dev Adds yourself to the registry.\n    ///  @param _name The first name of the user.\n    ///  @param _surname The last name of the user.\n    ///  @param _nonce An arbitrary number to allow multiple users with the same first and last name.\n    function register(string calldata _name, string calldata _surname, uint256 _nonce) public {\n        require(!isRegistered[_name][_surname][_nonce], \"This profile is already registered\");\n        isRegistered[_name][_surname][_nonce] = true;\n        bytes32 ID = keccak256(abi.encodePacked(_name, _surname, _nonce));\n        User storage user = users[ID];\n        user.regAddress = payable(msg.sender);\n        user.timestamp = uint64(block.timestamp);\n        user.registered = true;\n        user.name = _name;\n        user.surname = _surname;\n        user.nonce = _nonce;\n    }\n}\n/* Exercise 12 */\n/// @dev A Token contract that keeps a record of the users past balances.\ncontract SnapShotToken {\n    mapping(address => uint256) public balances;\n    mapping(address => mapping(uint256 => uint256)) public balanceAt;\n    event BalanceUpdated(address indexed user, uint256 oldBalance, uint256 newBalance);\n    /// @dev Buys token at the price of 1ETH/token.\n    function buyToken() public payable {\n        uint256 _balance = balances[msg.sender];\n        uint256 _newBalance = _balance + msg.value / 1 ether;\n        balances[msg.sender] = _newBalance;\n        _updateCheckpoint(msg.sender, _balance, _newBalance);\n    }\n    /// @dev Transfers tokens.\n    /// @param _to The recipient.\n    /// @param _value The amount to send.\n    function transfer(address _to, uint256 _value) public {\n        uint256 _balancesFrom = balances[msg.sender];\n        uint256 _balancesTo = balances[_to];\n        uint256 _balancesFromNew = _balancesFrom - _value;\n        balances[msg.sender] = _balancesFromNew;\n        uint256 _balancesToNew = _balancesTo + _value;\n        balances[_to] = _balancesToNew;\n        _updateCheckpoint(msg.sender, _balancesFrom, _balancesFromNew);\n        _updateCheckpoint(_to, _balancesTo, _balancesToNew);\n    }\n    /// @dev Records the users balance at this blocknumber\n    /// @param _user The address who's balance is updated.\n    /// @param _oldBalance The previous balance.\n    /// @param _newBalance The updated balance.\n    function _updateCheckpoint(address _user, uint256 _oldBalance, uint256 _newBalance) internal {\n        balanceAt[_user][block.timestamp] = _newBalance;\n        emit BalanceUpdated(_user, _oldBalance, _newBalance);\n    }\n}\n/* Exercise 13 */\n/// @dev Each player tries to guess the average of all the player's revealed answers combined.\n///      They must pay 1 ETH to play.\n///      The winners are those who are the nearest from the average.\n///      Note that some players may not reveal and use multiple accounts, this is part of the game and can be used tactically.\n///      Also note that waiting the last minute to reveal is also part of the game and can be used tactically (but it would probably cost a lot of gas).\ncontract GuessTheAverage {\n    uint256 public immutable start; // Beginning of the game.\n    uint256 public immutable commitDuration; // Duration of the Commit Period.\n    uint256 public immutable revealDuration; // Duration of the Reveal Period.\n    uint256 public cursorWinner; // Cursor of the last winner.\n    uint256 public cursorDistribute; // Cursor of the last distribution of rewards.\n    uint256 public lastDifference; // Last best difference between a guess and the average.\n    uint256 public average; // Average to guess.\n    uint256 public totalBalance; // Total balance of the contract.\n    uint256 public numberOfLosers; // Number of losers in the winners list.\n    Stage public currentStage; // Current Stage.\n    enum Stage {\n        CommitAndRevealPeriod,\n        AverageCalculated,\n        WinnersFound,\n        Distributed\n    }\n    struct Player {\n        uint256 playerIndex; // Index of the player in the guesses list.\n        bool hasGuessed; // Whether the player has guessed or not.\n        bool hasReveal; // Whether the player has revealed or not.\n        bytes32 commitment; // commitment of the player.\n    }\n    uint256[] public guesses; // List of player's guesses.\n    address[] public winners; // List of winners to reward.\n    mapping(address => Player) public players; // Maps an address to its respective Player status.\n    mapping(uint256 => address) public indexToPlayer; // Maps a guess index to the player who made the guess.\n    /* CONSTRUCTOR */\n    constructor(uint32 _commitDuration, uint32 _revealDuration) {\n        start = block.timestamp;\n        commitDuration = _commitDuration;\n        revealDuration = _revealDuration;\n    }\n    /// @dev Adds the guess for the user.\n    /// @param _commitment The commitment of the user under the form of keccak256(abi.encode(msg.sender, _number, _blindingFactor) where the blinding factor is a bytes32.\n    function guess(bytes32 _commitment) public payable {\n        Player storage player = players[msg.sender];\n        require(!player.hasGuessed, \"Player has already guessed\");\n        require(msg.value == 1 ether, \"Player must send exactly 1 ETH\");\n        require(\n            block.timestamp >= start && block.timestamp <= start + commitDuration,\n            \"Commit period must have begun and not ended\"\n        );\n        // Store the commitment.\n        player.hasGuessed = true;\n        player.commitment = _commitment;\n    }\n    /// @dev Reveals the guess for the user.\n    ///  @param _number The number guessed.\n    ///  @param _blindingFactor Bytes that has been used for the commitment to blind the guess.\n    function reveal(uint256 _number, bytes32 _blindingFactor) public {\n        require(\n            block.timestamp >= start + commitDuration && block.timestamp < start + commitDuration + revealDuration,\n            \"Reveal period must have begun and not ended\"\n        );\n        Player storage player = players[msg.sender];\n        require(!player.hasReveal, \"Player has already revealed\");\n        require(player.hasGuessed, \"Player must have guessed\");\n        // Check the hash to prove the player's honesty\n        require(keccak256(abi.encode(msg.sender, _number, _blindingFactor)) == player.commitment, \"Invalid hash\");\n        // Update player and guesses.\n        player.hasReveal = true;\n        average += _number;\n        indexToPlayer[guesses.length] = msg.sender;\n        guesses.push(_number);\n        player.playerIndex = guesses.length;\n    }\n    /// @dev Finds winners among players who have revealed their guess.\n    /// @param _count The number of transactions to execute. Executes until the end if set to \"0\" or number higher than number of transactions in the list.\n    function findWinners(uint256 _count) public {\n        require(block.timestamp >= start + commitDuration + revealDuration, \"Reveal period must have ended\");\n        require(currentStage < Stage.WinnersFound);\n        // If we don't have calculated the average yet, we calculate it.\n        if (currentStage < Stage.AverageCalculated) {\n            average /= guesses.length;\n            currentStage = Stage.AverageCalculated;\n            totalBalance = address(this).balance;\n            cursorWinner += 1;\n        }\n        // If there is no winner we push the first player into the winners list to initialize it.\n        if (winners.length == 0) {\n            winners.push(indexToPlayer[0]);\n            // Avoid overflow.\n            if (guesses[0] > average) lastDifference = guesses[0] - average;\n            else lastDifference = average - guesses[0];\n        }\n        uint256 i = cursorWinner;\n        for (; i < guesses.length && (_count == 0 || i < cursorWinner + _count); i++) {\n            uint256 difference;\n            // Avoid overflow.\n            if (guesses[i] > average) difference = guesses[i] - average;\n            else difference = average - guesses[i];\n            // Compare difference with the latest lowest difference.\n            if (difference < lastDifference) {\n                // Add winner and update lastDifference.\n                cursorDistribute = numberOfLosers = winners.length;\n                winners.push(indexToPlayer[i]);\n                lastDifference = difference;\n            } else if (difference == lastDifference) {\n                winners.push(indexToPlayer[i]);\n            }\n            // If we have passed through the entire array, update currentStage.\n        }\n        if (i == guesses.length) currentStage = Stage.WinnersFound;\n        // Update the cursor in case we haven't finished going through the list.\n        cursorWinner += _count;\n    }\n    /// @dev Distributes rewards to winners.\n    /// @param _count The number of transactions to execute. Executes until the end if set to \"0\" or number higher than number of winners in the list.\n    function distribute(uint256 _count) public {\n        require(currentStage == Stage.WinnersFound, \"Winners must have been found\");\n        for (uint256 i = cursorDistribute; i < winners.length && (_count == 0 || i < cursorDistribute + _count); i++) {\n            // Send ether to the winners, use send not to block.\n            payable(winners[i]).send(totalBalance / (winners.length - numberOfLosers));\n            if (i == winners.length - 1) currentStage = Stage.Distributed;\n        }\n        // Update the cursor in case we haven't finished going through the list.\n\n    \n          \n            \n    \n\n          \n          Expand Down\n          \n            \n    \n\n          \n          Expand Up\n    \n    @@ -615,7 +635,8 @@ contract PiggyBank {\n  \n        cursorDistribute += _count;\n    }\n}\n/* Exercise 14 */\n/// @dev This is a piggy bank.\n///      The owner can deposit 1 ETH whenever he wants.\n///      He can only withdraw when the deposited amount reaches 10 ETH.\ncontract PiggyBank {\n    address public owner;\n    /* CONSTRUCTOR */\n    /// @dev Sets msg.sender as owner\n    constructor() {\n        owner = msg.sender;\n    }\n    /// @dev Deposits 1 ETH in the smart contract\n    function deposit() public payable {\n        require(msg.sender == owner && msg.value == 1 ether && address(this).balance <= 10 ether);\n    }\n    /// @dev Withdraws the entire smart contract balance\n    function withdrawAll() public {\n        require(msg.sender == owner && address(this).balance == 10 ether);\n        payable(owner).transfer(address(this).balance);\n    }\n}\n\n\n    \n          \n            \n    \n\n          \n          Expand Down\n          \n            \n    \n\n          \n          Expand Up\n    \n    @@ -682,7 +703,8 @@ contract WinnerTakesAll {\n  \n/* Exercise 15 */\n/// @dev This is a game where an Owner considered as TRUSTED can set rounds with rewards.\n///      The Owner allows several users to compete for the rewards. The fastest user gets all the rewards.\n///      The users can propose new rounds but it's up to the Owner to fund them.\n///      The Owner can clear the rounds to create fresh new ones.\ncontract WinnerTakesAll {\n    struct Round {\n        uint256 rewards;\n        mapping(address => bool) isAllowed;\n    }\n    address public owner;\n    Round[] public rounds;\n    /* CONSTRUCTOR */\n    constructor() {\n        owner = msg.sender;\n    }\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n    /// @dev Creates new rounds.\n    /// @param _numberOfRounds The number of rounds to create.\n    function createNewRounds(uint256 _numberOfRounds) external {\n        for (uint256 i = 0; i < _numberOfRounds; i++) {\n            rounds.push();\n        }\n    }\n    /// @dev Set the reward at a specific round.\n    /// @param _roundIndex The index of the round concerned by the reward.\n    function setRewardsAtRound(uint256 _roundIndex) external payable onlyOwner {\n        require(rounds[_roundIndex].rewards == 0);\n        rounds[_roundIndex].rewards = msg.value;\n    }\n    /// @dev Allows the participation of a set of addresses for a specific round.\n    /// @param _roundIndex The index of the round concerned.\n    /// @param _recipients The set of addresses allowed to participate.\n    function setRewardsAtRoundFor(uint256 _roundIndex, address[] calldata _recipients) external onlyOwner {\n        for (uint256 i; i < _recipients.length; i++) {\n            rounds[_roundIndex].isAllowed[_recipients[i]] = true;\n        }\n    }\n    /// @dev Checks if an address can participate in this round.\n    /// @param _roundIndex The index of the round to be checked.\n    /// @param _recipient The address whose authorization is to be checked.\n    function isAllowedAt(uint256 _roundIndex, address _recipient) external view returns (bool) {\n        return rounds[_roundIndex].isAllowed[_recipient];\n    }\n    /// @dev Withdraws rewards of a round.\n    /// @param _roundIndex The index of the round concerned.\n    function withdrawRewards(uint256 _roundIndex) external {\n        require(rounds[_roundIndex].isAllowed[msg.sender]);\n        uint256 amount = rounds[_roundIndex].rewards;\n        rounds[_roundIndex].rewards = 0;\n        payable(msg.sender).transfer(amount);\n    }\n\n    /// @dev Delete all the rounds created.\n\n    \n        \n          \n    \n\n        \n        Expand All\n    \n    @@ -692,6 +714,7 @@ contract WinnerTakesAll {\n  \n    function clearRounds() external onlyOwner {\n        delete rounds;\n    }\n\n    /// @dev Withdraws all the ethers to owner's address.\n    function withdrawETH() external onlyOwner {\n        payable(msg.sender).transfer(address(this).balance);\n    }\n}",
        "after": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n// These contracts are examples of contracts with bugs and vulnerabilities to practice your hacking skills.\n// DO NOT USE THEM OR GET INSPIRATION FROM THEM TO MAKE CODE USED IN PRODUCTION\n// You are required to find vulnerabilities where an attacker harms someone else.\n// Being able to destroy your own stuff is not a vulnerability and should be dealt at the interface level.\n/* Exercise 1 */\n/// @dev Contract to store and redeem money.\ncontract Store {\n    struct Safe {\n        address owner;\n        uint256 amount;\n    }\n    Safe[] public safes;\n    /// @dev Stores some ETH.\n    function store() public payable {\n        safes.push(Safe({owner: msg.sender, amount: msg.value}));\n    }\n    /// @dev Takes back all the amount stored by the sender.\n    function take() public {\n        for (uint256 i; i < safes.length; ++i) {\n            Safe storage safe = safes[i];\n            if (safe.owner == msg.sender && safe.amount != 0) {\n                (bool success,) = msg.sender.call{value: safe.amount}(\"\");\n                require(success, \"Unsuccessful send\");\n                safe.amount = 0;\n            }\n        }\n\n    \n          \n            \n    \n\n          \n          Expand Down\n          \n            \n    \n\n          \n          Expand Up\n    \n    @@ -64,7 +65,7 @@ contract DiscountedBuy {\n  \n    }\n}\n/* Exercise 2 */\n/// @dev You can buy some objects.\n///      Further purchases are discounted.\n///      You need to pay basePrice / (1 + objectBought), where objectBought is the number of objects you previously bought.\ncontract DiscountedBuy {\n    uint256 public basePrice = 1 ether;\n    mapping(address => uint256) public objectBought;\n    /// @dev Buy an object.\n    function buy() public payable {\n        require(msg.value * (1 + objectBought[msg.sender]) == basePrice);\n        objectBought[msg.sender] += 1;\n    }\n    /// @dev Returns the price you'll need to pay.\n    /// @return The amount you need to pay in wei.\n    function price() public view returns (uint256) {\n        return basePrice / (1 + objectBought[msg.sender]);\n    }\n}\n/* Exercise 3 */\n/// @dev One party chooses Head or Tail and sends 1 ETH.\n///      The next party sends 1 ETH and tries to guess what the first party chose.\n///      If they succeed, they get 2 ETH, else the first party gets 2 ETH.\ncontract HeadOrTail {\n    bool public chosen; // True if the choice has been made.\n    bool public lastChoiceHead; // True if the choice is head.\n    address public lastParty; // The last party who chose.\n\n    /// @dev Must be sent 1 ETH.\n    ///      Choose Head or Tail to be guessed by the other player.\n\n    \n        \n          \n    \n\n        \n        Expand All\n    \n    @@ -75,7 +76,7 @@ contract HeadOrTail {\n  \n    /// @param _chooseHead True if Head was chosen, false if Tail was chosen.\n    function choose(bool _chooseHead) public payable {\n        require(!chosen);\n        require(msg.value == 1 ether);\n\n        chosen = true;\n        lastChoiceHead = _chooseHead;\n        lastParty = msg.sender;\n    }\n\n    /// @dev Guesses the choice of the first party and resolves the Head or Tail Game.\n\n    \n        \n          \n    \n\n        \n        Expand All\n    \n    @@ -84,9 +85,15 @@ contract HeadOrTail {\n  \n    /// @param _guessHead The guess (Head or Tail) of the opposite party.\n    function guess(bool _guessHead) public payable {\n        require(chosen);\n        require(msg.value == 1 ether);\n\n        bool success;\n\n        if (_guessHead == lastChoiceHead) {\n            (success,) = msg.sender.call{value: 2 ether}(\"\");\n        } else {\n            (success,) = lastParty.call{value: 2 ether}(\"\");\n        }\n\n        require(success, \"Unsuccessful send\");\n        chosen = false;\n    }\n}\n\n    \n        \n          \n    \n\n        \n        Expand All\n    \n    @@ -105,7 +112,7 @@ contract Vault {\n  \n/* Exercise 4 */\n/// @dev Contract managing the storage and the redemption of ETH.\ncontract Vault {\n    mapping(address => uint256) public balances;\n    /// @dev Stores the ETH of the sender in the contract.\n    function store() public payable {\n        balances[msg.sender] += msg.value;\n    }\n    /// @dev Redeems the ETH of the sender in the contract.\n    function redeem() public {\n        (bool success,) = msg.sender.call{value: balances[msg.sender]}(\"\");\n        require(success, \"Unsuccessful send\");\n        balances[msg.sender] = 0;\n    }\n}\n\n    \n        \n          \n    \n\n        \n        Expand All\n    \n    @@ -116,8 +123,8 @@ contract Vault {\n  \n/* Exercise 5 */\n/// @dev One party chooses Head or Tail and sends 1 ETH.\n///      The next party sends 1 ETH and tries to guess what the first party chose.\n///      If they succeed, they get 2 ETH, else the first party gets 2 ETH.\ncontract HeadTail {\n    address public partyA;\n    address public partyB;\n    bytes32 public commitmentA;\n    bool public chooseHeadB;\n    uint256 public timeB;\n\n    \n        \n          \n    \n\n        \n        Expand All\n    \n    @@ -129,7 +136,7 @@ contract HeadTail {\n  \n    /* CONSTRUCTOR */\n    /// @param _commitmentA is the result of the following command: keccak256(abi.encode(chooseHead,randomNumber)).\n    constructor(bytes32 _commitmentA) payable {\n        require(msg.value == 1 ether);\n\n        commitmentA = _commitmentA;\n        partyA = msg.sender;\n    }\n\n    /// @dev Guesses the choice of party A.\n\n    \n        \n          \n    \n\n        \n        Expand All\n    \n    @@ -140,7 +147,7 @@ contract HeadTail {\n  \n    /// @param _chooseHead True if the guess is Head, false otherwise.\n    function guess(bool _chooseHead) public payable {\n        require(msg.value == 1 ether);\n        require(partyB == address(0));\n\n        chooseHeadB = _chooseHead;\n        timeB = block.timestamp;\n        partyB = msg.sender;\n    }\n\n    /// @dev Reveals the commited value and send ETH to the winner.\n\n    \n        \n          \n    \n\n        \n        Expand All\n    \n    @@ -151,16 +158,20 @@ contract HeadTail {\n  \n    /// @param _chooseHead True if Head was chosen, false otherwise.\n    /// @param _randomNumber The random number chosen to obfuscate the commitment.\n    function resolve(bool _chooseHead, uint256 _randomNumber) public {\n        require(msg.sender == partyA);\n        require(keccak256(abi.encode(_chooseHead, _randomNumber)) == commitmentA);\n        require(address(this).balance >= 2 ether);\n\n        bool success;\n        if (_chooseHead == chooseHeadB) (success,) = partyB.call{value: 2 ether}(\"\");\n        else (success,) = partyA.call{value: 2 ether}(\"\");\n\n        require(success, \"Unsuccessful send\");\n    }\n\n    /// @dev Time out party A if it takes more than 1 day to reveal.\n    ///      Sends ETH to party B.\n    function timeOut() public {\n        require(block.timestamp > timeB + 1 days);\n        require(address(this).balance >= 2 ether);\n        (bool success,) = partyB.call{value: 2 ether}(\"\");\n        require(success, \"Unsuccessful send\");\n    }\n}\n\n\n    \n          \n            \n    \n\n          \n          Expand Down\n          \n            \n    \n\n          \n          Expand Up\n    \n    @@ -207,7 +218,8 @@ contract LinearBondedCurve {\n  \n/* Exercise 6 */\n/// @dev Contract for a simple token that can be sent.\ncontract SimpleToken {\n    mapping(address => int256) public balances;\n    /* CONSTRUCTOR */\n    /// @dev Creator starts with all the tokens.\n    constructor() {\n        balances[msg.sender] += 1000e18;\n    }\n    /// @dev Sends token.\n    ///  @param _recipient The recipient.\n    /// @param _amount The amount to send.\n    function sendToken(address _recipient, int256 _amount) public {\n        balances[msg.sender] -= _amount;\n        balances[_recipient] += _amount;\n    }\n}\n/* Exercise 7 */\n/// @dev Contract for a simple token that can be exchanged through a bonded curve and sent.\n/// @notice We assume that order frontrunning is fine.\ncontract LinearBondedCurve {\n    mapping(address => uint256) public balances;\n    uint256 public totalSupply;\n    /// @dev Buys token. The price is linear to the total supply.\n    function buy() public payable {\n        uint256 tokenToReceive = (1e18 * msg.value) / (1e18 + totalSupply);\n        balances[msg.sender] += tokenToReceive;\n        totalSupply += tokenToReceive;\n    }\n    /// @dev Sells token. The price of it is linear to the supply.\n    /// @param _amount The amount of tokens to sell.\n    function sell(uint256 _amount) public {\n        uint256 ethToReceive = ((1e18 + totalSupply) * _amount) / 1e18;\n        balances[msg.sender] -= _amount;\n        totalSupply -= _amount;\n        (bool success,) = msg.sender.call{value: ethToReceive}(\"\");\n        require(success, \"Unsuccessful send\");\n    }\n\n    /// @dev Sends token.\n\n    \n          \n            \n    \n\n          \n          Expand Down\n          \n            \n    \n\n          \n          Expand Up\n    \n    @@ -252,8 +264,10 @@ contract Coffers {\n  \n    /// @param _recipient The recipient.\n    /// @param _amount The amount to send.\n    function sendToken(address _recipient, uint256 _amount) public {\n        balances[msg.sender] -= _amount;\n        balances[_recipient] += _amount;\n    }\n}\n/* Exercise 8 */\n/// @dev Contract to create coffers, deposit and withdraw money from them.\ncontract Coffers {\n    struct Coffer {\n        uint256 nbSlots;\n        mapping(uint256 => uint256) slots;\n    }\n    mapping(address => Coffer) public coffers;\n    /// @dev Creates coffers.\n    ///  @param _slots The amount of slots the coffer will have.\n    function createCoffer(uint256 _slots) external {\n        Coffer storage coffer = coffers[msg.sender];\n        require(coffer.nbSlots == 0, \"Coffer already created\");\n        coffer.nbSlots = _slots;\n    }\n    /// @dev Deposits money in one's coffer slot.\n    /// @param _owner The coffer to deposit money on.\n    /// @param _slot The slot to deposit money on.\n    function deposit(address _owner, uint256 _slot) external payable {\n        Coffer storage coffer = coffers[_owner];\n        require(_slot < coffer.nbSlots);\n        coffer.slots[_slot] += msg.value;\n    }\n    /// @dev Withdraws all of the money from one's coffer slot.\n    /// @param _slot The slot to withdraw money from.\n    function withdraw(uint256 _slot) external {\n        Coffer storage coffer = coffers[msg.sender];\n        require(_slot < coffer.nbSlots);\n        uint256 ethToReceive = coffer.slots[_slot];\n        coffer.slots[_slot] = 0;\n        (bool success,) = msg.sender.call{value: ethToReceive}(\"\");\n        require(success, \"Unsuccessful send\");\n    }\n\n    /// @dev Closes an account withdrawing all the money.\n\n    \n        \n          \n    \n\n        \n        Expand All\n    \n    @@ -264,7 +278,8 @@ contract Coffers {\n  \n    function closeAccount() external {\n        Coffer storage coffer = coffers[msg.sender];\n        uint256 amountToSend;\n        for (uint256 i = 0; i < coffer.nbSlots; ++i) {\n            amountToSend += coffer.slots[i];\n        }\n        coffer.nbSlots = 0;\n        (bool success,) = msg.sender.call{value: amountToSend}(\"\");\n        require(success, \"Unsuccessful send\");\n    }\n}\n\n\n    \n          \n            \n    \n\n          \n          Expand Down\n          \n            \n    \n\n          \n          Expand Up\n    \n    @@ -294,7 +309,8 @@ contract CommonCoffers {\n  \n/* Exercise 9 */\n/// @dev Contract for simple coffer to deposit to and withdraw from.\ncontract CommonCoffers {\n    mapping(address => uint256) public coffers;\n    uint256 public scalingFactor;\n    /// @dev Deposits money in one's coffer.\n    /// @param _owner The coffer to deposit money on.\n    function deposit(address _owner) external payable {\n        if (scalingFactor != 0) {\n            uint256 toAdd = (scalingFactor * msg.value) / (address(this).balance - msg.value);\n            coffers[_owner] += toAdd;\n            scalingFactor += toAdd;\n        } else {\n            scalingFactor = 100;\n            coffers[_owner] = 100;\n        }\n    }\n    /// @dev Withdraws all of the money from one's coffer.\n    /// @param _amount The amount to withdraw from one's coffer.\n    function withdraw(uint256 _amount) external {\n        uint256 toRemove = (scalingFactor * _amount) / address(this).balance;\n        coffers[msg.sender] -= toRemove;\n        scalingFactor -= toRemove;\n        (bool success,) = msg.sender.call{value: _amount}(\"\");\n        require(success, \"Unsuccessful send\");\n    }\n}\n\n\n    \n        \n          \n    \n\n        \n        Expand All\n    \n    @@ -309,7 +325,7 @@ contract Resolver {\n  \n/* Exercise 10 */\n/// @dev Two parties deposit on a particular side and the owner decides which side is correct.\n///      Owner's decision is based on some external factors irrelevant to this contract.\ncontract Resolver {\n    enum Side {\n        A,\n        B\n    }\n\n    address public owner = msg.sender;\n    address[2] public sides;\n\n    uint256 public baseDeposit;\n    uint256 public reward;\n\n    \n        \n          \n    \n\n        \n        Expand All\n    \n    @@ -332,7 +348,7 @@ contract Resolver {\n  \n    Side public winner;\n    bool public declared;\n    uint256[2] public partyDeposits;\n    /* CONSTRUCTOR */\n    /// @param _baseDeposit The deposit a party has to pay. Note that it is greater than the reward.\n    constructor(uint256 _baseDeposit) payable {\n        reward = msg.value;\n        baseDeposit = _baseDeposit;\n    }\n    /// @dev Makes a deposit to one of the sides.\n    /// @param _side The side chosen by the party.\n    function deposit(Side _side) public payable {\n        require(!declared, \"The winner is already declared\");\n        require(sides[uint256(_side)] == address(0), \"Side already paid\");\n        require(msg.value > baseDeposit, \"Should cover the base deposit\");\n        sides[uint256(_side)] = msg.sender;\n        partyDeposits[uint256(_side)] = msg.value;\n    }\n\n\n    \n        \n          \n    \n\n        \n        Expand All\n    \n    @@ -347,27 +363,31 @@ contract Resolver {\n  \n    /// @dev Declares the winner as an owner.\n    ///      Note that in case no one funded for the winner side when the owner makes its transaction, having someone else deposit to get the reward is fine and doesn't affect the mechanism.\n    /// @param _winner The side that is eligible to a reward according to owner.\n    function declareWinner(Side _winner) public {\n        require(msg.sender == owner, \"Only owner allowed\");\n        require(!declared, \"Winner already declared\");\n        declared = true;\n        winner = _winner;\n    }\n\n    /// @dev Pays the reward to the winner. Reimburses the surplus deposit for both parties if there was one.\n    function payReward() public payable {\n        require(declared, \"The winner is not declared\");\n        uint256 depositA = partyDeposits[0];\n        uint256 depositB = partyDeposits[1];\n\n        uint256 rewardSent = reward;\n        reward = 0;\n        partyDeposits[0] = 0;\n        partyDeposits[1] = 0;\n        bool success;\n\n        // Pays the winner. Note that if no one put a deposit for the winning side, the reward will be burnt.\n        (success,) = sides[uint256(winner)].call{value: rewardSent}(\"\");\n        require(success, \"Unsuccessful send\");\n\n        // Reimburse the surplus deposit if there was one.\n        if (depositA > baseDeposit && sides[0] != address(0)) {\n            (success,) = sides[0].call{value: depositA - baseDeposit}(\"\");\n            require(success, \"Unsuccessful send\");\n        }\n\n        if (depositB > baseDeposit && sides[1] != address(0)) {\n            (success,) = sides[1].call{value: depositB - baseDeposit}(\"\");\n            require(success, \"Unsuccessful send\");\n        }\n    }\n}\n\n\n    \n          \n            \n    \n\n          \n          Expand Down\n          \n            \n    \n\n          \n          Expand Up\n    \n    @@ -583,8 +603,8 @@ contract GuessTheAverage {\n  \n/* Exercise 11*/\n/// @dev Contract for users to register. It will be used by other contracts to attach rights to those users (rights will be linked to user IDs).\n///      Note that simply being registered does not confer any right.\ncontract Registry {\n    struct User {\n        address payable regAddress;\n        uint64 timestamp;\n        bool registered;\n        string name;\n        string surname;\n        uint256 nonce;\n    }\n    // Nonce is used so the contract can add multiple profiles with the same first name and last name.\n    mapping(string => mapping(string => mapping(uint256 => bool))) public isRegistered; // name -> surname -> nonce -> registered/not registered.\n    mapping(bytes32 => User) public users; // User isn't identified by address but by his ID, since the same person can have multiple addresses.\n    /// @dev Adds yourself to the registry.\n    ///  @param _name The first name of the user.\n    ///  @param _surname The last name of the user.\n    ///  @param _nonce An arbitrary number to allow multiple users with the same first and last name.\n    function register(string calldata _name, string calldata _surname, uint256 _nonce) public {\n        require(!isRegistered[_name][_surname][_nonce], \"This profile is already registered\");\n        isRegistered[_name][_surname][_nonce] = true;\n        bytes32 ID = keccak256(abi.encodePacked(_name, _surname, _nonce));\n        User storage user = users[ID];\n        user.regAddress = payable(msg.sender);\n        user.timestamp = uint64(block.timestamp);\n        user.registered = true;\n        user.name = _name;\n        user.surname = _surname;\n        user.nonce = _nonce;\n    }\n}\n/* Exercise 12 */\n/// @dev A Token contract that keeps a record of the users past balances.\ncontract SnapShotToken {\n    mapping(address => uint256) public balances;\n    mapping(address => mapping(uint256 => uint256)) public balanceAt;\n    event BalanceUpdated(address indexed user, uint256 oldBalance, uint256 newBalance);\n    /// @dev Buys token at the price of 1ETH/token.\n    function buyToken() public payable {\n        uint256 _balance = balances[msg.sender];\n        uint256 _newBalance = _balance + msg.value / 1 ether;\n        balances[msg.sender] = _newBalance;\n        _updateCheckpoint(msg.sender, _balance, _newBalance);\n    }\n    /// @dev Transfers tokens.\n    /// @param _to The recipient.\n    /// @param _value The amount to send.\n    function transfer(address _to, uint256 _value) public {\n        uint256 _balancesFrom = balances[msg.sender];\n        uint256 _balancesTo = balances[_to];\n        uint256 _balancesFromNew = _balancesFrom - _value;\n        balances[msg.sender] = _balancesFromNew;\n        uint256 _balancesToNew = _balancesTo + _value;\n        balances[_to] = _balancesToNew;\n        _updateCheckpoint(msg.sender, _balancesFrom, _balancesFromNew);\n        _updateCheckpoint(_to, _balancesTo, _balancesToNew);\n    }\n    /// @dev Records the users balance at this blocknumber\n    /// @param _user The address who's balance is updated.\n    /// @param _oldBalance The previous balance.\n    /// @param _newBalance The updated balance.\n    function _updateCheckpoint(address _user, uint256 _oldBalance, uint256 _newBalance) internal {\n        balanceAt[_user][block.timestamp] = _newBalance;\n        emit BalanceUpdated(_user, _oldBalance, _newBalance);\n    }\n}\n/* Exercise 13 */\n/// @dev Each player tries to guess the average of all the player's revealed answers combined.\n///      They must pay 1 ETH to play.\n///      The winners are those who are the nearest from the average.\n///      Note that some players may not reveal and use multiple accounts, this is part of the game and can be used tactically.\n///      Also note that waiting the last minute to reveal is also part of the game and can be used tactically (but it would probably cost a lot of gas).\ncontract GuessTheAverage {\n    uint256 public immutable start; // Beginning of the game.\n    uint256 public immutable commitDuration; // Duration of the Commit Period.\n    uint256 public immutable revealDuration; // Duration of the Reveal Period.\n    uint256 public cursorWinner; // Cursor of the last winner.\n    uint256 public cursorDistribute; // Cursor of the last distribution of rewards.\n    uint256 public lastDifference; // Last best difference between a guess and the average.\n    uint256 public average; // Average to guess.\n    uint256 public totalBalance; // Total balance of the contract.\n    uint256 public numberOfLosers; // Number of losers in the winners list.\n    Stage public currentStage; // Current Stage.\n    enum Stage {\n        CommitAndRevealPeriod,\n        AverageCalculated,\n        WinnersFound,\n        Distributed\n    }\n    struct Player {\n        uint256 playerIndex; // Index of the player in the guesses list.\n        bool hasGuessed; // Whether the player has guessed or not.\n        bool hasReveal; // Whether the player has revealed or not.\n        bytes32 commitment; // commitment of the player.\n    }\n    uint256[] public guesses; // List of player's guesses.\n    address[] public winners; // List of winners to reward.\n    mapping(address => Player) public players; // Maps an address to its respective Player status.\n    mapping(uint256 => address) public indexToPlayer; // Maps a guess index to the player who made the guess.\n    /* CONSTRUCTOR */\n    constructor(uint32 _commitDuration, uint32 _revealDuration) {\n        start = block.timestamp;\n        commitDuration = _commitDuration;\n        revealDuration = _revealDuration;\n    }\n    /// @dev Adds the guess for the user.\n    /// @param _commitment The commitment of the user under the form of keccak256(abi.encode(msg.sender, _number, _blindingFactor) where the blinding factor is a bytes32.\n    function guess(bytes32 _commitment) public payable {\n        Player storage player = players[msg.sender];\n        require(!player.hasGuessed, \"Player has already guessed\");\n        require(msg.value == 1 ether, \"Player must send exactly 1 ETH\");\n        require(\n            block.timestamp >= start && block.timestamp <= start + commitDuration,\n            \"Commit period must have begun and not ended\"\n        );\n        // Store the commitment.\n        player.hasGuessed = true;\n        player.commitment = _commitment;\n    }\n    /// @dev Reveals the guess for the user.\n    ///  @param _number The number guessed.\n    ///  @param _blindingFactor Bytes that has been used for the commitment to blind the guess.\n    function reveal(uint256 _number, bytes32 _blindingFactor) public {\n        require(\n            block.timestamp >= start + commitDuration && block.timestamp < start + commitDuration + revealDuration,\n            \"Reveal period must have begun and not ended\"\n        );\n        Player storage player = players[msg.sender];\n        require(!player.hasReveal, \"Player has already revealed\");\n        require(player.hasGuessed, \"Player must have guessed\");\n        // Check the hash to prove the player's honesty\n        require(keccak256(abi.encode(msg.sender, _number, _blindingFactor)) == player.commitment, \"Invalid hash\");\n        // Update player and guesses.\n        player.hasReveal = true;\n        average += _number;\n        indexToPlayer[guesses.length] = msg.sender;\n        guesses.push(_number);\n        player.playerIndex = guesses.length;\n    }\n    /// @dev Finds winners among players who have revealed their guess.\n    /// @param _count The number of transactions to execute. Executes until the end if set to \"0\" or number higher than number of transactions in the list.\n    function findWinners(uint256 _count) public {\n        require(block.timestamp >= start + commitDuration + revealDuration, \"Reveal period must have ended\");\n        require(currentStage < Stage.WinnersFound);\n        // If we don't have calculated the average yet, we calculate it.\n        if (currentStage < Stage.AverageCalculated) {\n            average /= guesses.length;\n            currentStage = Stage.AverageCalculated;\n            totalBalance = address(this).balance;\n            cursorWinner += 1;\n        }\n        // If there is no winner we push the first player into the winners list to initialize it.\n        if (winners.length == 0) {\n            winners.push(indexToPlayer[0]);\n            // Avoid overflow.\n            if (guesses[0] > average) lastDifference = guesses[0] - average;\n            else lastDifference = average - guesses[0];\n        }\n        uint256 i = cursorWinner;\n        for (; i < guesses.length && (_count == 0 || i < cursorWinner + _count); i++) {\n            uint256 difference;\n            // Avoid overflow.\n            if (guesses[i] > average) difference = guesses[i] - average;\n            else difference = average - guesses[i];\n            // Compare difference with the latest lowest difference.\n            if (difference < lastDifference) {\n                // Add winner and update lastDifference.\n                cursorDistribute = numberOfLosers = winners.length;\n                winners.push(indexToPlayer[i]);\n                lastDifference = difference;\n            } else if (difference == lastDifference) {\n                winners.push(indexToPlayer[i]);\n            }\n            // If we have passed through the entire array, update currentStage.\n        }\n        if (i == guesses.length) currentStage = Stage.WinnersFound;\n        // Update the cursor in case we haven't finished going through the list.\n        cursorWinner += _count;\n    }\n    /// @dev Distributes rewards to winners.\n    /// @param _count The number of transactions to execute. Executes until the end if set to \"0\" or number higher than number of winners in the list.\n    function distribute(uint256 _count) public {\n        require(currentStage == Stage.WinnersFound, \"Winners must have been found\");\n        for (uint256 i = cursorDistribute; i < winners.length && (_count == 0 || i < cursorDistribute + _count); i++) {\n            // Send ether to the winners, use send not to block, if one of the account cannot receive ETH.\n            winners[i].call{value: totalBalance / (winners.length - numberOfLosers)}(\"\");\n            if (i == winners.length - 1) currentStage = Stage.Distributed;\n        }\n        // Update the cursor in case we haven't finished going through the list.\n\n    \n          \n            \n    \n\n          \n          Expand Down\n          \n            \n    \n\n          \n          Expand Up\n    \n    @@ -615,7 +635,8 @@ contract PiggyBank {\n  \n        cursorDistribute += _count;\n    }\n}\n/* Exercise 14 */\n/// @dev This is a piggy bank.\n///      The owner can deposit 1 ETH whenever he wants.\n///      He can only withdraw when the deposited amount reaches 10 ETH.\ncontract PiggyBank {\n    address public owner;\n    /* CONSTRUCTOR */\n    /// @dev Sets msg.sender as owner\n    constructor() {\n        owner = msg.sender;\n    }\n    /// @dev Deposits 1 ETH in the smart contract\n    function deposit() public payable {\n        require(msg.sender == owner && msg.value == 1 ether && address(this).balance <= 10 ether);\n    }\n    /// @dev Withdraws the entire smart contract balance\n    function withdrawAll() public {\n        require(msg.sender == owner && address(this).balance == 10 ether);\n        (bool success,) = msg.sender.call{value: address(this).balance}(\"\");\n        require(success, \"Unsuccessful send\");\n    }\n}\n\n\n    \n          \n            \n    \n\n          \n          Expand Down\n          \n            \n    \n\n          \n          Expand Up\n    \n    @@ -682,7 +703,8 @@ contract WinnerTakesAll {\n  \n/* Exercise 15 */\n/// @dev This is a game where an Owner considered as TRUSTED can set rounds with rewards.\n///      The Owner allows several users to compete for the rewards. The fastest user gets all the rewards.\n///      The users can propose new rounds but it's up to the Owner to fund them.\n///      The Owner can clear the rounds to create fresh new ones.\ncontract WinnerTakesAll {\n    struct Round {\n        uint256 rewards;\n        mapping(address => bool) isAllowed;\n    }\n    address public owner;\n    Round[] public rounds;\n    /* CONSTRUCTOR */\n    constructor() {\n        owner = msg.sender;\n    }\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n    /// @dev Creates new rounds.\n    /// @param _numberOfRounds The number of rounds to create.\n    function createNewRounds(uint256 _numberOfRounds) external {\n        for (uint256 i = 0; i < _numberOfRounds; i++) {\n            rounds.push();\n        }\n    }\n    /// @dev Set the reward at a specific round.\n    /// @param _roundIndex The index of the round concerned by the reward.\n    function setRewardsAtRound(uint256 _roundIndex) external payable onlyOwner {\n        require(rounds[_roundIndex].rewards == 0);\n        rounds[_roundIndex].rewards = msg.value;\n    }\n    /// @dev Allows the participation of a set of addresses for a specific round.\n    /// @param _roundIndex The index of the round concerned.\n    /// @param _recipients The set of addresses allowed to participate.\n    function setRewardsAtRoundFor(uint256 _roundIndex, address[] calldata _recipients) external onlyOwner {\n        for (uint256 i; i < _recipients.length; i++) {\n            rounds[_roundIndex].isAllowed[_recipients[i]] = true;\n        }\n    }\n    /// @dev Checks if an address can participate in this round.\n    /// @param _roundIndex The index of the round to be checked.\n    /// @param _recipient The address whose authorization is to be checked.\n    function isAllowedAt(uint256 _roundIndex, address _recipient) external view returns (bool) {\n        return rounds[_roundIndex].isAllowed[_recipient];\n    }\n    /// @dev Withdraws rewards of a round.\n    /// @param _roundIndex The index of the round concerned.\n    function withdrawRewards(uint256 _roundIndex) external {\n        require(rounds[_roundIndex].isAllowed[msg.sender]);\n        uint256 amount = rounds[_roundIndex].rewards;\n        rounds[_roundIndex].rewards = 0;\n        (bool success,) = msg.sender.call{value: amount}(\"\");\n        require(success, \"Unsuccessful send\");\n    }\n\n    /// @dev Delete all the rounds created.\n\n    \n        \n          \n    \n\n        \n        Expand All\n    \n    @@ -692,6 +714,7 @@ contract WinnerTakesAll {\n  \n    function clearRounds() external onlyOwner {\n        delete rounds;\n    }\n\n    /// @dev Withdraws all the ethers to owner's address.\n    function withdrawETH() external onlyOwner {\n        (bool success,) = msg.sender.call{value: address(this).balance}(\"\");\n        require(success, \"Unsuccessful send\");\n    }\n}"
    },
    {
        "tag": "access control",
        "url": "https://github.com/HMXOrg/v2-evm/commit/97442502c62fd530e169f8d548c99f1645002cc2",
        "file": "src/storages/VaultStorage.sol",
        "before": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.18;\nimport { OwnableUpgradeable } from \"@openzeppelin-upgradeable/contracts/access/OwnableUpgradeable.sol\";\nimport { ReentrancyGuardUpgradeable } from \"@openzeppelin-upgradeable/contracts/security/ReentrancyGuardUpgradeable.sol\";\nimport { IERC20Upgradeable } from \"@openzeppelin-upgradeable/contracts/token/ERC20/IERC20Upgradeable.sol\";\n// interfaces\nimport { SafeERC20Upgradeable } from \"@openzeppelin-upgradeable/contracts/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport { Address } from \"@openzeppelin/contracts/utils/Address.sol\";\nimport { IVaultStorage } from \"./interfaces/IVaultStorage.sol\";\n/// @title VaultStorage\n/// @notice storage contract to do accounting for token, and also hold physical tokens\ncontract VaultStorage is OwnableUpgradeable, ReentrancyGuardUpgradeable, IVaultStorage {\n  using SafeERC20Upgradeable for IERC20Upgradeable;\n  using Address for address;\n  /**\n   * Events\n   */\n  event LogSetTraderBalance(address indexed trader, address token, uint balance);\n  event SetServiceExecutor(address indexed executorAddress, bool isServiceExecutor);\n  event LogSetStrategyAllowance(address indexed token, address strategy, address prevTarget, address newTarget);\n  /**\n   * States\n   */\n  mapping(address => uint256) public totalAmount; //token => tokenAmount\n  mapping(address => uint256) public plpLiquidity; // token => PLPTokenAmount\n  mapping(address => uint256) public protocolFees; // protocol fee in token unit\n  uint256 public plpLiquidityDebtUSDE30; // USD dept accounting when fundingFee is not enough to repay to trader\n  mapping(address => uint256) public fundingFeeReserve; // sum of realized funding fee amount\n  mapping(address => uint256) public devFees;\n  mapping(address => uint256) public tradingFeeDebt;\n  mapping(address => uint256) public borrowingFeeDebt;\n  mapping(address => uint256) public fundingFeeDebt;\n  mapping(address => uint256) public lossDebt;\n  uint256 public globalTradingFeeDebt;\n  uint256 public globalBorrowingFeeDebt;\n  uint256 public globalFundingFeeDebt;\n  uint256 public globalLossDebt;\n  // trader address (with sub-account) => token => amount\n  mapping(address => mapping(address => uint256)) public traderBalances;\n  // mapping(address => address[]) public traderTokens;\n  mapping(address => address[]) public traderTokens;\n  // mapping(token => strategy => target)\n  mapping(address => mapping(address => address)) public strategyAllowances;\n  // mapping(service executor address => allow)\n  mapping(address => bool) public serviceExecutors;\n  /**\n   * Modifiers\n   */\n  modifier onlyWhitelistedExecutor() {\n    if (!serviceExecutors[msg.sender]) revert IVaultStorage_NotWhiteListed();\n    _;\n  }\n  function initialize() external initializer {\n    OwnableUpgradeable.__Ownable_init();\n    ReentrancyGuardUpgradeable.__ReentrancyGuard_init();\n  }\n  /**\n   * Core Functions\n   */\n  function validateAddTraderToken(address _trader, address _token) external view {\n    _validateAddTraderToken(_trader, _token);\n  }\n  function validateRemoveTraderToken(address _trader, address _token) external view {\n    _validateRemoveTraderToken(_trader, _token);\n  }\n  /**\n   * Getters\n   */\n  function getTraderTokens(address _subAccount) external view returns (address[] memory) {\n    return traderTokens[_subAccount];\n  }\n  /**\n   * ERC20 interaction functions\n   */\n\n  function pullToken(address _token) external returns (uint256) {\n    uint256 prevBalance = totalAmount[_token];\n    uint256 nextBalance = IERC20Upgradeable(_token).balanceOf(address(this));\n\n\n    \n          \n            \n    \n\n          \n          Expand Down\n          \n            \n    \n\n          \n          Expand Up\n    \n    @@ -357,42 +357,42 @@ contract VaultStorage is OwnableUpgradeable, ReentrancyGuardUpgradeable, IVaultS\n  \n    totalAmount[_token] = nextBalance;\n    return nextBalance - prevBalance;\n  }\n  function pushToken(address _token, address _to, uint256 _amount) external nonReentrant onlyWhitelistedExecutor {\n    IERC20Upgradeable(_token).safeTransfer(_to, _amount);\n    totalAmount[_token] = IERC20Upgradeable(_token).balanceOf(address(this));\n  }\n  /**\n   * Setters\n   */\n  function setServiceExecutors(address _executorAddress, bool _isServiceExecutor) external nonReentrant onlyOwner {\n    serviceExecutors[_executorAddress] = _isServiceExecutor;\n    emit SetServiceExecutor(_executorAddress, _isServiceExecutor);\n  }\n  function addFee(address _token, uint256 _amount) external onlyWhitelistedExecutor {\n    protocolFees[_token] += _amount;\n  }\n  function addFundingFee(address _token, uint256 _amount) external onlyWhitelistedExecutor {\n    fundingFeeReserve[_token] += _amount;\n  }\n  function removeFundingFee(address _token, uint256 _amount) external onlyWhitelistedExecutor {\n    fundingFeeReserve[_token] -= _amount;\n  }\n  function addPlpLiquidityDebtUSDE30(uint256 _value) external onlyWhitelistedExecutor {\n    plpLiquidityDebtUSDE30 += _value;\n  }\n  function removePlpLiquidityDebtUSDE30(uint256 _value) external onlyWhitelistedExecutor {\n    plpLiquidityDebtUSDE30 -= _value;\n  }\n  function addPLPLiquidity(address _token, uint256 _amount) external onlyWhitelistedExecutor {\n    plpLiquidity[_token] += _amount;\n  }\n  function withdrawFee(address _token, uint256 _amount, address _receiver) external onlyWhitelistedExecutor {\n    if (_receiver == address(0)) revert IVaultStorage_ZeroAddress();\n    protocolFees[_token] -= _amount;\n    IERC20Upgradeable(_token).safeTransfer(_receiver, _amount);\n  }\n  function removePLPLiquidity(address _token, uint256 _amount) external onlyWhitelistedExecutor {\n    if (plpLiquidity[_token] < _amount) revert IVaultStorage_PLPBalanceRemaining();\n    plpLiquidity[_token] -= _amount;\n  }\n  /// @notice increase sub-account collateral\n  /// @param _subAccount - sub account\n  /// @param _token - collateral token to increase\n  /// @param _amount - amount to increase\n  function increaseTraderBalance(\n    address _subAccount,\n    address _token,\n    uint256 _amount\n  ) external onlyWhitelistedExecutor {\n    _increaseTraderBalance(_subAccount, _token, _amount);\n  }\n  /// @notice decrease sub-account collateral\n  /// @param _subAccount - sub account\n  /// @param _token - collateral token to increase\n  /// @param _amount - amount to increase\n  function decreaseTraderBalance(\n    address _subAccount,\n    address _token,\n    uint256 _amount\n  ) external onlyWhitelistedExecutor {\n    _deductTraderBalance(_subAccount, _token, _amount);\n  }\n  /// @notice Pays the PLP for providing liquidity with the specified token and amount.\n  /// @param _trader The address of the trader paying the PLP.\n  /// @param _token The address of the token being used to pay the PLP.\n  /// @param _amount The amount of the token being used to pay the PLP.\n  function payPlp(address _trader, address _token, uint256 _amount) external onlyWhitelistedExecutor {\n    // Increase the PLP's liquidity for the specified token\n    plpLiquidity[_token] += _amount;\n    // Decrease the trader's balance for the specified token\n    _deductTraderBalance(_trader, _token, _amount);\n  }\n  function transfer(address _token, address _from, address _to, uint256 _amount) external onlyWhitelistedExecutor {\n    _deductTraderBalance(_from, _token, _amount);\n    _increaseTraderBalance(_to, _token, _amount);\n  }\n  function payTradingFee(\n    address _trader,\n    address _token,\n    uint256 _devFeeAmount,\n    uint256 _protocolFeeAmount\n  ) external onlyWhitelistedExecutor {\n    // Deduct amount from trader balance\n    _deductTraderBalance(_trader, _token, _devFeeAmount + _protocolFeeAmount);\n    // Increase the amount to devFees and protocolFees\n    devFees[_token] += _devFeeAmount;\n    protocolFees[_token] += _protocolFeeAmount;\n  }\n  function payBorrowingFee(\n    address _trader,\n    address _token,\n    uint256 _devFeeAmount,\n    uint256 _plpFeeAmount\n  ) external onlyWhitelistedExecutor {\n    // Deduct amount from trader balance\n    _deductTraderBalance(_trader, _token, _devFeeAmount + _plpFeeAmount);\n    // Increase the amount to devFees and plpLiquidity\n    devFees[_token] += _devFeeAmount;\n    plpLiquidity[_token] += _plpFeeAmount;\n  }\n  function payFundingFeeFromTraderToPlp(\n    address _trader,\n    address _token,\n    uint256 _fundingFeeAmount\n  ) external onlyWhitelistedExecutor {\n    // Deduct amount from trader balance\n    _deductTraderBalance(_trader, _token, _fundingFeeAmount);\n    // Increase the amount to plpLiquidity\n    plpLiquidity[_token] += _fundingFeeAmount;\n  }\n  function payFundingFeeFromPlpToTrader(\n    address _trader,\n    address _token,\n    uint256 _fundingFeeAmount\n  ) external onlyWhitelistedExecutor {\n    // Deduct amount from plpLiquidity\n    plpLiquidity[_token] -= _fundingFeeAmount;\n    // Increase the amount to trader\n    _increaseTraderBalance(_trader, _token, _fundingFeeAmount);\n  }\n  function payTraderProfit(\n    address _trader,\n    address _token,\n    uint256 _totalProfitAmount,\n    uint256 _settlementFeeAmount\n  ) external onlyWhitelistedExecutor {\n    // Deduct amount from plpLiquidity\n    plpLiquidity[_token] -= _totalProfitAmount;\n    protocolFees[_token] += _settlementFeeAmount;\n    _increaseTraderBalance(_trader, _token, _totalProfitAmount - _settlementFeeAmount);\n  }\n  function _increaseTraderBalance(address _trader, address _token, uint256 _amount) internal {\n    if (_amount == 0) return;\n    if (traderBalances[_trader][_token] == 0) {\n      _addTraderToken(_trader, _token);\n    }\n    traderBalances[_trader][_token] += _amount;\n  }\n  function _deductTraderBalance(address _trader, address _token, uint256 _amount) internal {\n    if (_amount == 0) return;\n    traderBalances[_trader][_token] -= _amount;\n    if (traderBalances[_trader][_token] == 0) {\n      _removeTraderToken(_trader, _token);\n    }\n  }\n  function convertFundingFeeReserveWithPLP(\n    address _convertToken,\n    address _targetToken,\n    uint256 _convertAmount,\n    uint256 _targetAmount\n  ) external onlyWhitelistedExecutor {\n    // Deduct convert token amount from funding fee reserve\n    fundingFeeReserve[_convertToken] -= _convertAmount;\n    // Increase convert token amount to PLP\n    plpLiquidity[_convertToken] += _convertAmount;\n    // Deduct target token amount from PLP\n    plpLiquidity[_targetToken] -= _targetAmount;\n    // Deduct convert token amount from funding fee reserve\n    fundingFeeReserve[_targetToken] += _targetAmount;\n  }\n  function withdrawSurplusFromFundingFeeReserveToPLP(\n    address _token,\n    uint256 _fundingFeeAmount\n  ) external onlyWhitelistedExecutor {\n    // Deduct amount from funding fee reserve\n    fundingFeeReserve[_token] -= _fundingFeeAmount;\n    // Increase the amount to PLP\n    plpLiquidity[_token] += _fundingFeeAmount;\n  }\n  function payFundingFeeFromTraderToFundingFeeReserve(\n    address _trader,\n    address _token,\n    uint256 _fundingFeeAmount\n  ) external onlyWhitelistedExecutor {\n    // Deduct amount from trader balance\n    _deductTraderBalance(_trader, _token, _fundingFeeAmount);\n    // Increase the amount to fundingFee\n    fundingFeeReserve[_token] += _fundingFeeAmount;\n  }\n  function payFundingFeeFromFundingFeeReserveToTrader(\n    address _trader,\n    address _token,\n    uint256 _fundingFeeAmount\n  ) external onlyWhitelistedExecutor {\n    // Deduct amount from fundingFee\n    fundingFeeReserve[_token] -= _fundingFeeAmount;\n    // Increase the amount to trader\n    _increaseTraderBalance(_trader, _token, _fundingFeeAmount);\n  }\n  function repayFundingFeeDebtFromTraderToPlp(\n    address _trader,\n    address _token,\n    uint256 _fundingFeeAmount,\n    uint256 _fundingFeeValue\n  ) external onlyWhitelistedExecutor {\n    // Deduct amount from trader balance\n    _deductTraderBalance(_trader, _token, _fundingFeeAmount);\n    // Add token amounts that PLP received\n    plpLiquidity[_token] += _fundingFeeAmount;\n    // Remove debt value on PLP as received\n    plpLiquidityDebtUSDE30 -= _fundingFeeValue;\n  }\n  function borrowFundingFeeFromPlpToTrader(\n    address _trader,\n    address _token,\n    uint256 _fundingFeeAmount,\n    uint256 _fundingFeeValue\n  ) external onlyWhitelistedExecutor {\n    // Deduct token amounts from PLP\n    plpLiquidity[_token] -= _fundingFeeAmount;\n    // Increase the amount to trader\n    _increaseTraderBalance(_trader, _token, _fundingFeeAmount);\n    // Add debt value on PLP\n    plpLiquidityDebtUSDE30 += _fundingFeeValue;\n  }\n\n  function addTradingFeeDebt(address _trader, uint256 _tradingFeeDebt) external {\n    tradingFeeDebt[_trader] += _tradingFeeDebt;\n    globalTradingFeeDebt += _tradingFeeDebt;\n  }\n\n  function addBorrowingFeeDebt(address _trader, uint256 _borrowingFeeDebt) external {\n    borrowingFeeDebt[_trader] += _borrowingFeeDebt;\n    globalBorrowingFeeDebt += _borrowingFeeDebt;\n  }\n\n  function addFundingFeeDebt(address _trader, uint256 _fundingFeeDebt) external {\n    fundingFeeDebt[_trader] += _fundingFeeDebt;\n    globalFundingFeeDebt += _fundingFeeDebt;\n  }\n\n  function addLossDebt(address _trader, uint256 _lossDebt) external {\n    lossDebt[_trader] += _lossDebt;\n    globalLossDebt += _lossDebt;\n  }\n\n  function subTradingFeeDebt(address _trader, uint256 _tradingFeeDebt) external {\n    tradingFeeDebt[_trader] -= _tradingFeeDebt;\n    globalTradingFeeDebt -= _tradingFeeDebt;\n  }\n\n  function subBorrowingFeeDebt(address _trader, uint256 _borrowingFeeDebt) external {\n    borrowingFeeDebt[_trader] -= _borrowingFeeDebt;\n    globalBorrowingFeeDebt -= _borrowingFeeDebt;\n  }\n\n  function subFundingFeeDebt(address _trader, uint256 _fundingFeeDebt) external {\n    fundingFeeDebt[_trader] -= _fundingFeeDebt;\n    globalFundingFeeDebt -= _fundingFeeDebt;\n  }\n\n  function subLossDebt(address _trader, uint256 _lossDebt) external {\n    lossDebt[_trader] -= _lossDebt;\n    globalLossDebt -= _lossDebt;\n  }\n\n    \n          \n            \n    \n\n          \n          Expand Down\n    \n    \n  \n  /**\n   * Strategy\n   */\n  /// @notice Set the strategy for a token\n  /// @param _token The token to set the strategy for\n  /// @param _strategy The strategy to set\n  /// @param _target The target to set\n  function setStrategyAllowance(address _token, address _strategy, address _target) external onlyOwner {\n    emit LogSetStrategyAllowance(_token, _strategy, strategyAllowances[_token][_strategy], _target);\n    strategyAllowances[_token][_strategy] = _target;\n  }\n  function _getRevertMsg(bytes memory _returnData) internal pure returns (string memory) {\n    // If the _res length is less than 68, then the transaction failed silently (without a revert message)\n    if (_returnData.length < 68) return \"Transaction reverted silently\";\n    assembly {\n      // Slice the sighash.\n      _returnData := add(_returnData, 0x04)\n    }\n    return abi.decode(_returnData, (string)); // All that remains is the revert string\n  }\n  /// @notice invoking the target contract using call data.\n  /// @param _token The token to cook\n  /// @param _target target to execute callData\n  /// @param _callData call data signature\n  function cook(address _token, address _target, bytes calldata _callData) external returns (bytes memory) {\n    // Check\n    // 1. Only strategy for specific token can call this function\n    if (strategyAllowances[_token][msg.sender] != _target) revert IVaultStorage_Forbidden();\n    // 2. Target must be a contract. This to prevent strategy calling to EOA.\n    if (!_target.isContract()) revert IVaultStorage_TargetNotContract();\n    // 3. Execute the call as what the strategy wants\n    (bool _success, bytes memory _returnData) = _target.call(_callData);\n    // 4. Revert if not success\n    require(_success, _getRevertMsg(_returnData));\n    return _returnData;\n  }\n  /**\n   * Private Functions\n   */\n  function _addTraderToken(address _trader, address _token) private {\n    _validateAddTraderToken(_trader, _token);\n    traderTokens[_trader].push(_token);\n  }\n  function _removeTraderToken(address _trader, address _token) private {\n    _validateRemoveTraderToken(_trader, _token);\n    address[] storage traderToken = traderTokens[_trader];\n    uint256 tokenLen = traderToken.length;\n    uint256 lastTokenIndex = tokenLen - 1;\n    // find and deregister the token\n    for (uint256 i; i < tokenLen; ) {\n      if (traderToken[i] == _token) {\n        // delete the token by replacing it with the last one and then pop it from there\n        if (i != lastTokenIndex) {\n          traderToken[i] = traderToken[lastTokenIndex];\n        }\n        traderToken.pop();\n        break;\n      }\n      unchecked {\n        i++;\n      }\n    }\n  }\n  function _validateRemoveTraderToken(address _trader, address _token) private view {\n    if (traderBalances[_trader][_token] != 0) revert IVaultStorage_TraderBalanceRemaining();\n  }\n  function _validateAddTraderToken(address _trader, address _token) private view {\n    address[] storage traderToken = traderTokens[_trader];\n    for (uint256 i; i < traderToken.length; ) {\n      if (traderToken[i] == _token) revert IVaultStorage_TraderTokenAlreadyExists();\n      unchecked {\n        i++;\n      }\n    }\n  }\n  /// @custom:oz-upgrades-unsafe-allow constructor\n  constructor() {\n    _disableInitializers();\n  }\n}",
        "after": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.18;\nimport { OwnableUpgradeable } from \"@openzeppelin-upgradeable/contracts/access/OwnableUpgradeable.sol\";\nimport { ReentrancyGuardUpgradeable } from \"@openzeppelin-upgradeable/contracts/security/ReentrancyGuardUpgradeable.sol\";\nimport { IERC20Upgradeable } from \"@openzeppelin-upgradeable/contracts/token/ERC20/IERC20Upgradeable.sol\";\n// interfaces\nimport { SafeERC20Upgradeable } from \"@openzeppelin-upgradeable/contracts/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport { Address } from \"@openzeppelin/contracts/utils/Address.sol\";\nimport { IVaultStorage } from \"./interfaces/IVaultStorage.sol\";\n/// @title VaultStorage\n/// @notice storage contract to do accounting for token, and also hold physical tokens\ncontract VaultStorage is OwnableUpgradeable, ReentrancyGuardUpgradeable, IVaultStorage {\n  using SafeERC20Upgradeable for IERC20Upgradeable;\n  using Address for address;\n  /**\n   * Events\n   */\n  event LogSetTraderBalance(address indexed trader, address token, uint balance);\n  event SetServiceExecutor(address indexed executorAddress, bool isServiceExecutor);\n  event LogSetStrategyAllowance(address indexed token, address strategy, address prevTarget, address newTarget);\n  /**\n   * States\n   */\n  mapping(address => uint256) public totalAmount; //token => tokenAmount\n  mapping(address => uint256) public plpLiquidity; // token => PLPTokenAmount\n  mapping(address => uint256) public protocolFees; // protocol fee in token unit\n  uint256 public plpLiquidityDebtUSDE30; // USD dept accounting when fundingFee is not enough to repay to trader\n  mapping(address => uint256) public fundingFeeReserve; // sum of realized funding fee amount\n  mapping(address => uint256) public devFees;\n  mapping(address => uint256) public tradingFeeDebt;\n  mapping(address => uint256) public borrowingFeeDebt;\n  mapping(address => uint256) public fundingFeeDebt;\n  mapping(address => uint256) public lossDebt;\n  uint256 public globalTradingFeeDebt;\n  uint256 public globalBorrowingFeeDebt;\n  uint256 public globalFundingFeeDebt;\n  uint256 public globalLossDebt;\n  // trader address (with sub-account) => token => amount\n  mapping(address => mapping(address => uint256)) public traderBalances;\n  // mapping(address => address[]) public traderTokens;\n  mapping(address => address[]) public traderTokens;\n  // mapping(token => strategy => target)\n  mapping(address => mapping(address => address)) public strategyAllowances;\n  // mapping(service executor address => allow)\n  mapping(address => bool) public serviceExecutors;\n  /**\n   * Modifiers\n   */\n  modifier onlyWhitelistedExecutor() {\n    if (!serviceExecutors[msg.sender]) revert IVaultStorage_NotWhiteListed();\n    _;\n  }\n  function initialize() external initializer {\n    OwnableUpgradeable.__Ownable_init();\n    ReentrancyGuardUpgradeable.__ReentrancyGuard_init();\n  }\n  /**\n   * Core Functions\n   */\n  function validateAddTraderToken(address _trader, address _token) external view {\n    _validateAddTraderToken(_trader, _token);\n  }\n  function validateRemoveTraderToken(address _trader, address _token) external view {\n    _validateRemoveTraderToken(_trader, _token);\n  }\n  /**\n   * Getters\n   */\n  function getTraderTokens(address _subAccount) external view returns (address[] memory) {\n    return traderTokens[_subAccount];\n  }\n  /**\n   * ERC20 interaction functions\n   */\n\n  function pullToken(address _token) external onlyWhitelistedExecutor returns (uint256) {\n    uint256 prevBalance = totalAmount[_token];\n    uint256 nextBalance = IERC20Upgradeable(_token).balanceOf(address(this));\n\n\n    \n          \n            \n    \n\n          \n          Expand Down\n          \n            \n    \n\n          \n          Expand Up\n    \n    @@ -357,42 +357,42 @@ contract VaultStorage is OwnableUpgradeable, ReentrancyGuardUpgradeable, IVaultS\n  \n    totalAmount[_token] = nextBalance;\n    return nextBalance - prevBalance;\n  }\n  function pushToken(address _token, address _to, uint256 _amount) external nonReentrant onlyWhitelistedExecutor {\n    IERC20Upgradeable(_token).safeTransfer(_to, _amount);\n    totalAmount[_token] = IERC20Upgradeable(_token).balanceOf(address(this));\n  }\n  /**\n   * Setters\n   */\n  function setServiceExecutors(address _executorAddress, bool _isServiceExecutor) external nonReentrant onlyOwner {\n    serviceExecutors[_executorAddress] = _isServiceExecutor;\n    emit SetServiceExecutor(_executorAddress, _isServiceExecutor);\n  }\n  function addFee(address _token, uint256 _amount) external onlyWhitelistedExecutor {\n    protocolFees[_token] += _amount;\n  }\n  function addFundingFee(address _token, uint256 _amount) external onlyWhitelistedExecutor {\n    fundingFeeReserve[_token] += _amount;\n  }\n  function removeFundingFee(address _token, uint256 _amount) external onlyWhitelistedExecutor {\n    fundingFeeReserve[_token] -= _amount;\n  }\n  function addPlpLiquidityDebtUSDE30(uint256 _value) external onlyWhitelistedExecutor {\n    plpLiquidityDebtUSDE30 += _value;\n  }\n  function removePlpLiquidityDebtUSDE30(uint256 _value) external onlyWhitelistedExecutor {\n    plpLiquidityDebtUSDE30 -= _value;\n  }\n  function addPLPLiquidity(address _token, uint256 _amount) external onlyWhitelistedExecutor {\n    plpLiquidity[_token] += _amount;\n  }\n  function withdrawFee(address _token, uint256 _amount, address _receiver) external onlyWhitelistedExecutor {\n    if (_receiver == address(0)) revert IVaultStorage_ZeroAddress();\n    protocolFees[_token] -= _amount;\n    IERC20Upgradeable(_token).safeTransfer(_receiver, _amount);\n  }\n  function removePLPLiquidity(address _token, uint256 _amount) external onlyWhitelistedExecutor {\n    if (plpLiquidity[_token] < _amount) revert IVaultStorage_PLPBalanceRemaining();\n    plpLiquidity[_token] -= _amount;\n  }\n  /// @notice increase sub-account collateral\n  /// @param _subAccount - sub account\n  /// @param _token - collateral token to increase\n  /// @param _amount - amount to increase\n  function increaseTraderBalance(\n    address _subAccount,\n    address _token,\n    uint256 _amount\n  ) external onlyWhitelistedExecutor {\n    _increaseTraderBalance(_subAccount, _token, _amount);\n  }\n  /// @notice decrease sub-account collateral\n  /// @param _subAccount - sub account\n  /// @param _token - collateral token to increase\n  /// @param _amount - amount to increase\n  function decreaseTraderBalance(\n    address _subAccount,\n    address _token,\n    uint256 _amount\n  ) external onlyWhitelistedExecutor {\n    _deductTraderBalance(_subAccount, _token, _amount);\n  }\n  /// @notice Pays the PLP for providing liquidity with the specified token and amount.\n  /// @param _trader The address of the trader paying the PLP.\n  /// @param _token The address of the token being used to pay the PLP.\n  /// @param _amount The amount of the token being used to pay the PLP.\n  function payPlp(address _trader, address _token, uint256 _amount) external onlyWhitelistedExecutor {\n    // Increase the PLP's liquidity for the specified token\n    plpLiquidity[_token] += _amount;\n    // Decrease the trader's balance for the specified token\n    _deductTraderBalance(_trader, _token, _amount);\n  }\n  function transfer(address _token, address _from, address _to, uint256 _amount) external onlyWhitelistedExecutor {\n    _deductTraderBalance(_from, _token, _amount);\n    _increaseTraderBalance(_to, _token, _amount);\n  }\n  function payTradingFee(\n    address _trader,\n    address _token,\n    uint256 _devFeeAmount,\n    uint256 _protocolFeeAmount\n  ) external onlyWhitelistedExecutor {\n    // Deduct amount from trader balance\n    _deductTraderBalance(_trader, _token, _devFeeAmount + _protocolFeeAmount);\n    // Increase the amount to devFees and protocolFees\n    devFees[_token] += _devFeeAmount;\n    protocolFees[_token] += _protocolFeeAmount;\n  }\n  function payBorrowingFee(\n    address _trader,\n    address _token,\n    uint256 _devFeeAmount,\n    uint256 _plpFeeAmount\n  ) external onlyWhitelistedExecutor {\n    // Deduct amount from trader balance\n    _deductTraderBalance(_trader, _token, _devFeeAmount + _plpFeeAmount);\n    // Increase the amount to devFees and plpLiquidity\n    devFees[_token] += _devFeeAmount;\n    plpLiquidity[_token] += _plpFeeAmount;\n  }\n  function payFundingFeeFromTraderToPlp(\n    address _trader,\n    address _token,\n    uint256 _fundingFeeAmount\n  ) external onlyWhitelistedExecutor {\n    // Deduct amount from trader balance\n    _deductTraderBalance(_trader, _token, _fundingFeeAmount);\n    // Increase the amount to plpLiquidity\n    plpLiquidity[_token] += _fundingFeeAmount;\n  }\n  function payFundingFeeFromPlpToTrader(\n    address _trader,\n    address _token,\n    uint256 _fundingFeeAmount\n  ) external onlyWhitelistedExecutor {\n    // Deduct amount from plpLiquidity\n    plpLiquidity[_token] -= _fundingFeeAmount;\n    // Increase the amount to trader\n    _increaseTraderBalance(_trader, _token, _fundingFeeAmount);\n  }\n  function payTraderProfit(\n    address _trader,\n    address _token,\n    uint256 _totalProfitAmount,\n    uint256 _settlementFeeAmount\n  ) external onlyWhitelistedExecutor {\n    // Deduct amount from plpLiquidity\n    plpLiquidity[_token] -= _totalProfitAmount;\n    protocolFees[_token] += _settlementFeeAmount;\n    _increaseTraderBalance(_trader, _token, _totalProfitAmount - _settlementFeeAmount);\n  }\n  function _increaseTraderBalance(address _trader, address _token, uint256 _amount) internal {\n    if (_amount == 0) return;\n    if (traderBalances[_trader][_token] == 0) {\n      _addTraderToken(_trader, _token);\n    }\n    traderBalances[_trader][_token] += _amount;\n  }\n  function _deductTraderBalance(address _trader, address _token, uint256 _amount) internal {\n    if (_amount == 0) return;\n    traderBalances[_trader][_token] -= _amount;\n    if (traderBalances[_trader][_token] == 0) {\n      _removeTraderToken(_trader, _token);\n    }\n  }\n  function convertFundingFeeReserveWithPLP(\n    address _convertToken,\n    address _targetToken,\n    uint256 _convertAmount,\n    uint256 _targetAmount\n  ) external onlyWhitelistedExecutor {\n    // Deduct convert token amount from funding fee reserve\n    fundingFeeReserve[_convertToken] -= _convertAmount;\n    // Increase convert token amount to PLP\n    plpLiquidity[_convertToken] += _convertAmount;\n    // Deduct target token amount from PLP\n    plpLiquidity[_targetToken] -= _targetAmount;\n    // Deduct convert token amount from funding fee reserve\n    fundingFeeReserve[_targetToken] += _targetAmount;\n  }\n  function withdrawSurplusFromFundingFeeReserveToPLP(\n    address _token,\n    uint256 _fundingFeeAmount\n  ) external onlyWhitelistedExecutor {\n    // Deduct amount from funding fee reserve\n    fundingFeeReserve[_token] -= _fundingFeeAmount;\n    // Increase the amount to PLP\n    plpLiquidity[_token] += _fundingFeeAmount;\n  }\n  function payFundingFeeFromTraderToFundingFeeReserve(\n    address _trader,\n    address _token,\n    uint256 _fundingFeeAmount\n  ) external onlyWhitelistedExecutor {\n    // Deduct amount from trader balance\n    _deductTraderBalance(_trader, _token, _fundingFeeAmount);\n    // Increase the amount to fundingFee\n    fundingFeeReserve[_token] += _fundingFeeAmount;\n  }\n  function payFundingFeeFromFundingFeeReserveToTrader(\n    address _trader,\n    address _token,\n    uint256 _fundingFeeAmount\n  ) external onlyWhitelistedExecutor {\n    // Deduct amount from fundingFee\n    fundingFeeReserve[_token] -= _fundingFeeAmount;\n    // Increase the amount to trader\n    _increaseTraderBalance(_trader, _token, _fundingFeeAmount);\n  }\n  function repayFundingFeeDebtFromTraderToPlp(\n    address _trader,\n    address _token,\n    uint256 _fundingFeeAmount,\n    uint256 _fundingFeeValue\n  ) external onlyWhitelistedExecutor {\n    // Deduct amount from trader balance\n    _deductTraderBalance(_trader, _token, _fundingFeeAmount);\n    // Add token amounts that PLP received\n    plpLiquidity[_token] += _fundingFeeAmount;\n    // Remove debt value on PLP as received\n    plpLiquidityDebtUSDE30 -= _fundingFeeValue;\n  }\n  function borrowFundingFeeFromPlpToTrader(\n    address _trader,\n    address _token,\n    uint256 _fundingFeeAmount,\n    uint256 _fundingFeeValue\n  ) external onlyWhitelistedExecutor {\n    // Deduct token amounts from PLP\n    plpLiquidity[_token] -= _fundingFeeAmount;\n    // Increase the amount to trader\n    _increaseTraderBalance(_trader, _token, _fundingFeeAmount);\n    // Add debt value on PLP\n    plpLiquidityDebtUSDE30 += _fundingFeeValue;\n  }\n\n  function addTradingFeeDebt(address _trader, uint256 _tradingFeeDebt) external onlyWhitelistedExecutor {\n    tradingFeeDebt[_trader] += _tradingFeeDebt;\n    globalTradingFeeDebt += _tradingFeeDebt;\n  }\n\n  function addBorrowingFeeDebt(address _trader, uint256 _borrowingFeeDebt) external onlyWhitelistedExecutor {\n    borrowingFeeDebt[_trader] += _borrowingFeeDebt;\n    globalBorrowingFeeDebt += _borrowingFeeDebt;\n  }\n\n  function addFundingFeeDebt(address _trader, uint256 _fundingFeeDebt) external onlyWhitelistedExecutor {\n    fundingFeeDebt[_trader] += _fundingFeeDebt;\n    globalFundingFeeDebt += _fundingFeeDebt;\n  }\n\n  function addLossDebt(address _trader, uint256 _lossDebt) external onlyWhitelistedExecutor {\n    lossDebt[_trader] += _lossDebt;\n    globalLossDebt += _lossDebt;\n  }\n\n  function subTradingFeeDebt(address _trader, uint256 _tradingFeeDebt) external onlyWhitelistedExecutor {\n    tradingFeeDebt[_trader] -= _tradingFeeDebt;\n    globalTradingFeeDebt -= _tradingFeeDebt;\n  }\n\n  function subBorrowingFeeDebt(address _trader, uint256 _borrowingFeeDebt) external onlyWhitelistedExecutor {\n    borrowingFeeDebt[_trader] -= _borrowingFeeDebt;\n    globalBorrowingFeeDebt -= _borrowingFeeDebt;\n  }\n\n  function subFundingFeeDebt(address _trader, uint256 _fundingFeeDebt) external onlyWhitelistedExecutor {\n    fundingFeeDebt[_trader] -= _fundingFeeDebt;\n    globalFundingFeeDebt -= _fundingFeeDebt;\n  }\n\n  function subLossDebt(address _trader, uint256 _lossDebt) external onlyWhitelistedExecutor {\n    lossDebt[_trader] -= _lossDebt;\n    globalLossDebt -= _lossDebt;\n  }\n\n    \n          \n            \n    \n\n          \n          Expand Down\n    \n    \n  \n  /**\n   * Strategy\n   */\n  /// @notice Set the strategy for a token\n  /// @param _token The token to set the strategy for\n  /// @param _strategy The strategy to set\n  /// @param _target The target to set\n  function setStrategyAllowance(address _token, address _strategy, address _target) external onlyOwner {\n    emit LogSetStrategyAllowance(_token, _strategy, strategyAllowances[_token][_strategy], _target);\n    strategyAllowances[_token][_strategy] = _target;\n  }\n  function _getRevertMsg(bytes memory _returnData) internal pure returns (string memory) {\n    // If the _res length is less than 68, then the transaction failed silently (without a revert message)\n    if (_returnData.length < 68) return \"Transaction reverted silently\";\n    assembly {\n      // Slice the sighash.\n      _returnData := add(_returnData, 0x04)\n    }\n    return abi.decode(_returnData, (string)); // All that remains is the revert string\n  }\n  /// @notice invoking the target contract using call data.\n  /// @param _token The token to cook\n  /// @param _target target to execute callData\n  /// @param _callData call data signature\n  function cook(address _token, address _target, bytes calldata _callData) external returns (bytes memory) {\n    // Check\n    // 1. Only strategy for specific token can call this function\n    if (strategyAllowances[_token][msg.sender] != _target) revert IVaultStorage_Forbidden();\n    // 2. Target must be a contract. This to prevent strategy calling to EOA.\n    if (!_target.isContract()) revert IVaultStorage_TargetNotContract();\n    // 3. Execute the call as what the strategy wants\n    (bool _success, bytes memory _returnData) = _target.call(_callData);\n    // 4. Revert if not success\n    require(_success, _getRevertMsg(_returnData));\n    return _returnData;\n  }\n  /**\n   * Private Functions\n   */\n  function _addTraderToken(address _trader, address _token) private {\n    _validateAddTraderToken(_trader, _token);\n    traderTokens[_trader].push(_token);\n  }\n  function _removeTraderToken(address _trader, address _token) private {\n    _validateRemoveTraderToken(_trader, _token);\n    address[] storage traderToken = traderTokens[_trader];\n    uint256 tokenLen = traderToken.length;\n    uint256 lastTokenIndex = tokenLen - 1;\n    // find and deregister the token\n    for (uint256 i; i < tokenLen; ) {\n      if (traderToken[i] == _token) {\n        // delete the token by replacing it with the last one and then pop it from there\n        if (i != lastTokenIndex) {\n          traderToken[i] = traderToken[lastTokenIndex];\n        }\n        traderToken.pop();\n        break;\n      }\n      unchecked {\n        i++;\n      }\n    }\n  }\n  function _validateRemoveTraderToken(address _trader, address _token) private view {\n    if (traderBalances[_trader][_token] != 0) revert IVaultStorage_TraderBalanceRemaining();\n  }\n  function _validateAddTraderToken(address _trader, address _token) private view {\n    address[] storage traderToken = traderTokens[_trader];\n    for (uint256 i; i < traderToken.length; ) {\n      if (traderToken[i] == _token) revert IVaultStorage_TraderTokenAlreadyExists();\n      unchecked {\n        i++;\n      }\n    }\n  }\n  /// @custom:oz-upgrades-unsafe-allow constructor\n  constructor() {\n    _disableInitializers();\n  }\n}"
    },
    {
        "tag": "reentrancy",
        "url": "https://github.com/HMXOrg/v2-evm/commit/e944af1cfc72fa85fbf5f421a96a376fb227a4f8",
        "file": "src/handlers/CrossMarginHandler.sol",
        "before": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.18;\n// base\nimport { ERC20Upgradeable } from \"@openzeppelin-upgradeable/contracts/token/ERC20/ERC20Upgradeable.sol\";\nimport { SafeERC20Upgradeable } from \"@openzeppelin-upgradeable/contracts/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport { ReentrancyGuardUpgradeable } from \"@openzeppelin-upgradeable/contracts/security/ReentrancyGuardUpgradeable.sol\";\nimport { OwnableUpgradeable } from \"@openzeppelin-upgradeable/contracts/access/OwnableUpgradeable.sol\";\n// interfaces\nimport { ICrossMarginHandler } from \"@hmx/handlers/interfaces/ICrossMarginHandler.sol\";\nimport { CrossMarginService } from \"@hmx/services/CrossMarginService.sol\";\nimport { IEcoPyth } from \"@hmx/oracles/interfaces/IEcoPyth.sol\";\nimport { IWNative } from \"../interfaces/IWNative.sol\";\nimport { VaultStorage } from \"@hmx/storages/VaultStorage.sol\";\nimport { ConfigStorage } from \"@hmx/storages/ConfigStorage.sol\";\n/// @title CrossMarginHandler\n/// @notice This contract handles the deposit and withdrawal of collateral tokens for the Cross Margin Trading module.\ncontract CrossMarginHandler is OwnableUpgradeable, ReentrancyGuardUpgradeable, ICrossMarginHandler {\n  using SafeERC20Upgradeable for ERC20Upgradeable;\n  /**\n   * Events\n   */\n  event LogDepositCollateral(\n    address indexed primaryAccount,\n    uint256 indexed subAccountId,\n    address token,\n    uint256 amount\n  );\n  event LogWithdrawCollateral(\n    address indexed primaryAccount,\n    uint256 indexed subAccountId,\n    address token,\n    uint256 amount\n  );\n  event LogSetCrossMarginService(address indexed oldCrossMarginService, address newCrossMarginService);\n  event LogSetPyth(address indexed oldPyth, address newPyth);\n  event LogSetOrderExecutor(address executor, bool isAllow);\n  event LogSetMinExecutionFee(uint256 oldValue, uint256 newValue);\n  event LogCreateWithdrawOrder(\n    address indexed account,\n    uint8 indexed subAccountId,\n    uint256 indexed orderId,\n    address token,\n    uint256 amount,\n    uint256 executionFee,\n    bool shouldUnwrap\n  );\n  event LogCancelWithdrawOrder(\n    address indexed account,\n    uint8 indexed subAccountId,\n    uint256 indexed orderId,\n    address token,\n    uint256 amount,\n    uint256 executionFee,\n    bool shouldUnwrap\n  );\n  event LogExecuteWithdrawOrder(\n    address indexed account,\n    uint8 indexed subAccountId,\n    uint256 indexed orderId,\n    address token,\n    uint256 amount,\n    bool shouldUnwrap,\n    bool isSuccess\n  );\n  /**\n   * Constants\n   */\n  uint64 internal constant RATE_PRECISION = 1e18;\n  /**\n   * States\n   */\n  address public crossMarginService;\n  address public pyth;\n  uint256 public nextExecutionOrderIndex; // the index of the next withdraw order that should be executed\n  uint256 public minExecutionOrderFee; // minimum execution order fee in native token amount\n  bool private isExecuting; // order is executing (prevent direct call executeWithdrawOrder()\n\n  WithdrawOrder[] public withdrawOrders; // all withdrawOrder\n  mapping(address => WithdrawOrder[]) public subAccountExecutedWithdrawOrders; // subAccount -> executed orders\n\n    \n          \n            \n    \n\n          \n          Expand Down\n          \n            \n    \n\n          \n          Expand Up\n    \n    @@ -303,8 +302,6 @@ contract CrossMarginHandler is OwnableUpgradeable, ReentrancyGuardUpgradeable, I\n  \n  mapping(address => bool) public orderExecutors; //address -> flag to execute\n  /// @notice Initializes the CrossMarginHandler contract with the provided configuration parameters.\n  /// @param _crossMarginService Address of the CrossMarginService contract.\n  /// @param _pyth Address of the Pyth contract.\n  /// @param _minExecutionOrderFee Minimum execution fee for a withdrawal order.\n  function initialize(address _crossMarginService, address _pyth, uint256 _minExecutionOrderFee) external initializer {\n    OwnableUpgradeable.__Ownable_init();\n    ReentrancyGuardUpgradeable.__ReentrancyGuard_init();\n    // Sanity check\n    CrossMarginService(_crossMarginService).vaultStorage();\n    IEcoPyth(_pyth).getAssetIds();\n    crossMarginService = _crossMarginService;\n    pyth = _pyth;\n    minExecutionOrderFee = _minExecutionOrderFee;\n  }\n  function getActiveWithdrawOrders(\n    uint256 _limit,\n    uint256 _offset\n  ) external view returns (WithdrawOrder[] memory _withdrawOrder) {\n    // Find the _returnCount\n    uint256 _returnCount;\n    {\n      uint256 _activeOrderCount = withdrawOrders.length - nextExecutionOrderIndex;\n      uint256 _afterOffsetCount = _activeOrderCount > _offset ? (_activeOrderCount - _offset) : 0;\n      _returnCount = _afterOffsetCount > _limit ? _limit : _afterOffsetCount;\n      if (_returnCount == 0) return _withdrawOrder;\n    }\n    // Initialize order array\n    _withdrawOrder = new WithdrawOrder[](_returnCount);\n    // Build the array\n    {\n      for (uint i = 0; i < _returnCount; ) {\n        _withdrawOrder[i] = withdrawOrders[nextExecutionOrderIndex + _offset + i];\n        unchecked {\n          ++i;\n        }\n      }\n      return _withdrawOrder;\n    }\n  }\n  function getExecutedWithdrawOrders(\n    address _subAccount,\n    uint256 _limit,\n    uint256 _offset\n  ) external view returns (WithdrawOrder[] memory _withdrawOrder) {\n    // Find the _returnCount and\n    uint256 _returnCount;\n    {\n      uint256 _exeuctedOrderCount = subAccountExecutedWithdrawOrders[_subAccount].length;\n      uint256 _afterOffsetCount = _exeuctedOrderCount > _offset ? (_exeuctedOrderCount - _offset) : 0;\n      _returnCount = _afterOffsetCount > _limit ? _limit : _afterOffsetCount;\n      if (_returnCount == 0) return _withdrawOrder;\n    }\n    // Initialize order array\n    _withdrawOrder = new WithdrawOrder[](_returnCount);\n    // Build the array\n    {\n      for (uint i = 0; i < _returnCount; ) {\n        _withdrawOrder[i] = subAccountExecutedWithdrawOrders[_subAccount][_offset + i];\n        unchecked {\n          ++i;\n        }\n      }\n      return _withdrawOrder;\n    }\n  }\n  /**\n   * Modifiers\n   */\n  /// @notice Validate only accepted collateral tokens to be deposited or withdrawn\n  modifier onlyAcceptedToken(address _token) {\n    ConfigStorage(CrossMarginService(crossMarginService).configStorage()).validateAcceptedCollateral(_token);\n    _;\n  }\n  /// @notice Validate only whitelisted executors to call function\n  modifier onlyOrderExecutor() {\n    if (!orderExecutors[msg.sender]) revert ICrossMarginHandler_NotWhitelisted();\n    _;\n  }\n  /**\n   * CALCULATION\n   */\n  /// @notice Deposits the specified amount of collateral token into the user's sub-account.\n  /// @param _subAccountId ID of the user's sub-account.\n  /// @param _token Address of the collateral token to deposit.\n  /// @param _amount Amount of collateral token to deposit.\n  /// @param _shouldWrap Whether to wrap native ETH into WETH before depositing.\n  function depositCollateral(\n    uint8 _subAccountId,\n    address _token,\n    uint256 _amount,\n    bool _shouldWrap\n  ) external payable nonReentrant onlyAcceptedToken(_token) {\n    // SLOAD\n    CrossMarginService _crossMarginService = CrossMarginService(crossMarginService);\n    if (_shouldWrap) {\n      // Prevent mismatch msgValue and the input amount\n      if (msg.value != _amount) {\n        revert ICrossMarginHandler_MismatchMsgValue();\n      }\n      // Wrap the native to wNative. The _token must be wNative.\n      // If not, it would revert transfer amount exceed on the next line.\n      // slither-disable-next-line arbitrary-send-eth\n      IWNative(_token).deposit{ value: _amount }();\n      // Transfer those wNative token from this contract to VaultStorage\n      ERC20Upgradeable(_token).safeTransfer(_crossMarginService.vaultStorage(), _amount);\n    } else {\n      // Transfer depositing token from trader's wallet to VaultStorage\n      ERC20Upgradeable(_token).safeTransferFrom(msg.sender, _crossMarginService.vaultStorage(), _amount);\n    }\n    // Call service to deposit collateral\n    _crossMarginService.depositCollateral(msg.sender, _subAccountId, _token, _amount);\n    emit LogDepositCollateral(msg.sender, _subAccountId, _token, _amount);\n  }\n  /// @notice Creates a new withdraw order to withdraw the specified amount of collateral token from the user's sub-account.\n  /// @param _subAccountId ID of the user's sub-account.\n  /// @param _token Address of the collateral token to withdraw.\n  /// @param _amount Amount of collateral token to withdraw.\n  /// @param _executionFee Execution fee to pay for this order.\n  /// @param _shouldUnwrap Whether to unwrap WETH into native ETH after withdrawing.\n  /// @return _orderId The ID of the newly created withdraw order.\n  function createWithdrawCollateralOrder(\n    uint8 _subAccountId,\n    address _token,\n    uint256 _amount,\n    uint256 _executionFee,\n    bool _shouldUnwrap\n  ) external payable nonReentrant onlyAcceptedToken(_token) returns (uint256 _orderId) {\n    if (_executionFee < minExecutionOrderFee) revert ICrossMarginHandler_InsufficientExecutionFee();\n    if (msg.value != _executionFee) revert ICrossMarginHandler_InCorrectValueTransfer();\n    // convert native to WNative (including executionFee)\n    _transferInETH();\n    _orderId = withdrawOrders.length;\n    withdrawOrders.push(\n      WithdrawOrder({\n        account: payable(msg.sender),\n        orderId: _orderId,\n        token: _token,\n        amount: _amount,\n        executionFee: _executionFee,\n        shouldUnwrap: _shouldUnwrap,\n        subAccountId: _subAccountId,\n        crossMarginService: CrossMarginService(crossMarginService),\n        createdTimestamp: uint48(block.timestamp),\n        executedTimestamp: 0,\n        status: 0 // pending\n      })\n    );\n    emit LogCreateWithdrawOrder(msg.sender, _subAccountId, _orderId, _token, _amount, _executionFee, _shouldUnwrap);\n    return _orderId;\n  }\n  /// @notice Executes a batch of pending withdraw orders.\n  /// @param _endIndex The index of the last withdraw order to execute.\n  /// @param _feeReceiver The address to receive the total execution fee.\n  /// @param _priceData Price data from the Pyth oracle.\n  /// @param _publishTimeData Publish time data from the Pyth oracle.\n  /// @param _minPublishTime Minimum publish time for the Pyth oracle data.\n  /// @param _encodedVaas Encoded VaaS data for the Pyth oracle.\n  // slither-disable-next-line reentrancy-eth\n  function executeOrder(\n    uint256 _endIndex,\n    address payable _feeReceiver,\n    bytes32[] memory _priceData,\n    bytes32[] memory _publishTimeData,\n    uint256 _minPublishTime,\n    bytes32 _encodedVaas\n  ) external nonReentrant onlyOrderExecutor {\n    // Get the number of withdraw orders\n    uint256 _orderLength = withdrawOrders.length;\n    // Ensure there are orders to execute\n    if (nextExecutionOrderIndex == _orderLength) revert ICrossMarginHandler_NoOrder();\n    // Set the end index to the latest order index if it exceeds the number of orders\n    uint256 _latestOrderIndex = _orderLength - 1;\n    if (_endIndex > _latestOrderIndex) {\n      _endIndex = _latestOrderIndex;\n    }\n    // Update the price and publish time data using the Pyth oracle\n    // slither-disable-next-line arbitrary-send-eth\n    IEcoPyth(pyth).updatePriceFeeds(_priceData, _publishTimeData, _minPublishTime, _encodedVaas);\n    // Initialize variables for the execution loop\n    WithdrawOrder memory _order;\n    uint256 _totalFeeReceiver;\n    uint256 _executionFee;\n    for (uint256 i = nextExecutionOrderIndex; i <= _endIndex; ) {\n      _order = withdrawOrders[i];\n      _executionFee = _order.executionFee;\n      // Set the flag to indicate that orders are currently being executed\n      isExecuting = true;\n\n      try this.executeWithdrawOrder(_order) {\n        emit LogExecuteWithdrawOrder(\n\n    \n          \n            \n    \n\n          \n          Expand Down\n          \n            \n    \n\n          \n          Expand Up\n    \n    @@ -339,7 +336,6 @@ contract CrossMarginHandler is OwnableUpgradeable, ReentrancyGuardUpgradeable, I\n  \n          _order.account,\n          _order.subAccountId,\n          _order.orderId,\n          _order.token,\n          _order.amount,\n          _order.shouldUnwrap,\n          true\n        );\n        // update order status\n        _order.status = 1; // success\n      } catch Error(string memory) {\n        // Do nothing\n      } catch (bytes memory) {\n        emit LogExecuteWithdrawOrder(\n          _order.account,\n          _order.subAccountId,\n          _order.orderId,\n          _order.token,\n          _order.amount,\n          _order.shouldUnwrap,\n          false\n        );\n        // update order status\n        _order.status = 2; // fail\n      }\n      // assign exec time\n      _order.executedTimestamp = uint48(block.timestamp);\n\n      isExecuting = false;\n      _totalFeeReceiver += _executionFee;\n\n      // save to executed order first\n\n    \n        \n          \n    \n\n        \n        Expand All\n    \n    @@ -361,7 +357,7 @@ contract CrossMarginHandler is OwnableUpgradeable, ReentrancyGuardUpgradeable, I\n  \n      subAccountExecutedWithdrawOrders[_getSubAccount(_order.account, _order.subAccountId)].push(_order);\n      // clear executed withdraw order\n      delete withdrawOrders[i];\n      unchecked {\n        ++i;\n      }\n    }\n    nextExecutionOrderIndex = _endIndex + 1;\n    // Pay total collected fees to the executor\n    _transferOutETH(_totalFeeReceiver, _feeReceiver);\n  }\n  /// @notice Executes a single withdraw order by transferring the specified amount of collateral token to the user's wallet.\n  /// @param _order WithdrawOrder struct representing the order to execute.\n  function executeWithdrawOrder(WithdrawOrder memory _order) external {\n    // if not in executing state, then revert\n    if (!isExecuting) revert ICrossMarginHandler_NotExecutionState();\n\n    // Call service to withdraw collateral\n    if (_order.shouldUnwrap) {\n\n    \n          \n            \n    \n\n          \n          Expand Down\n    \n    \n  \n      // Withdraw wNative straight to this contract first.\n      _order.crossMarginService.withdrawCollateral(\n        _order.account,\n        _order.subAccountId,\n        _order.token,\n        _order.amount,\n        address(this)\n      );\n      // Then we unwrap the wNative token. The receiving amount should be the exact same as _amount. (No fee deducted when withdraw)\n      IWNative(_order.token).withdraw(_order.amount);\n      // slither-disable-next-line arbitrary-send-eth\n      payable(_order.account).transfer(_order.amount);\n    } else {\n      // Withdraw _token straight to the user\n      _order.crossMarginService.withdrawCollateral(\n        _order.account,\n        _order.subAccountId,\n        _order.token,\n        _order.amount,\n        _order.account\n      );\n    }\n    emit LogWithdrawCollateral(_order.account, _order.subAccountId, _order.token, _order.amount);\n  }\n  /// @notice Cancels the specified withdraw order.\n  /// @param _orderIndex Index of the order to cancel.\n  function cancelWithdrawOrder(uint256 _orderIndex) external nonReentrant {\n    // if order index >= liquidity order's length, then out of bound\n    // if order index < next execute index, means order index outdate\n    if (_orderIndex >= withdrawOrders.length || _orderIndex < nextExecutionOrderIndex) {\n      revert ICrossMarginHandler_NoOrder();\n    }\n    // SLOAD\n    WithdrawOrder memory _order = withdrawOrders[_orderIndex];\n    // validate if msg.sender is not owned the order, then revert\n    if (msg.sender != _order.account) revert ICrossMarginHandler_NotOrderOwner();\n    delete withdrawOrders[_orderIndex];\n    emit LogCancelWithdrawOrder(\n      payable(msg.sender),\n      _order.subAccountId,\n      _order.orderId,\n      _order.token,\n      _order.amount,\n      _order.executionFee,\n      _order.shouldUnwrap\n    );\n  }\n  /**\n   * GETTER\n   */\n  /// @notice Returns all pending withdraw orders.\n  /// @return _withdrawOrders An array of WithdrawOrder structs representing all pending withdraw orders.\n  function getWithdrawOrders() external view returns (WithdrawOrder[] memory _withdrawOrders) {\n    return withdrawOrders;\n  }\n  /// @notice get withdraw orders length\n  function getWithdrawOrderLength() external view returns (uint256) {\n    return withdrawOrders.length;\n  }\n  /**\n   * Setters\n   */\n  /// @notice Sets a new CrossMarginService contract address.\n  /// @param _crossMarginService The new CrossMarginService contract address.\n  function setCrossMarginService(address _crossMarginService) external nonReentrant onlyOwner {\n    if (_crossMarginService == address(0)) revert ICrossMarginHandler_InvalidAddress();\n    emit LogSetCrossMarginService(crossMarginService, _crossMarginService);\n    crossMarginService = _crossMarginService;\n    // Sanity check\n    CrossMarginService(_crossMarginService).vaultStorage();\n  }\n  /// @notice Sets a new Pyth contract address.\n  /// @param _pyth The new Pyth contract address.\n  function setPyth(address _pyth) external nonReentrant onlyOwner {\n    if (_pyth == address(0)) revert ICrossMarginHandler_InvalidAddress();\n    emit LogSetPyth(pyth, _pyth);\n    pyth = _pyth;\n    // Sanity check\n    IEcoPyth(_pyth).getAssetIds();\n  }\n  /// @notice setMinExecutionFee\n  /// @param _newMinExecutionFee minExecutionFee in ethers\n  function setMinExecutionFee(uint256 _newMinExecutionFee) external nonReentrant onlyOwner {\n    emit LogSetMinExecutionFee(minExecutionOrderFee, _newMinExecutionFee);\n    minExecutionOrderFee = _newMinExecutionFee;\n  }\n  /// @notice setOrderExecutor\n  /// @param _executor address who will be executor\n  /// @param _isAllow flag to allow to execute\n  function setOrderExecutor(address _executor, bool _isAllow) external nonReentrant onlyOwner {\n    orderExecutors[_executor] = _isAllow;\n    emit LogSetOrderExecutor(_executor, _isAllow);\n  }\n  /// @notice convert collateral\n  function convertSGlpCollateral(\n    uint8 _subAccountId,\n    address _tokenOut,\n    uint256 _amountIn\n  ) external nonReentrant onlyAcceptedToken(_tokenOut) returns (uint256 _amountOut) {\n    return\n      CrossMarginService(crossMarginService).convertSGlpCollateral(msg.sender, _subAccountId, _tokenOut, _amountIn);\n  }\n  /**\n   * Private Functions\n   */\n  /// @notice Transfer in ETH from user to be used as execution fee\n  /// @dev The received ETH will be wrapped into WETH and store in this contract for later use.\n  function _transferInETH() private {\n    IWNative(ConfigStorage(CrossMarginService(crossMarginService).configStorage()).weth()).deposit{\n      value: msg.value\n    }();\n  }\n  /// @notice Transfer out ETH to the receiver\n  /// @dev The stored WETH will be unwrapped and transfer as native token\n  /// @param _amountOut Amount of ETH to be transferred\n  /// @param _receiver The receiver of ETH in its native form. The receiver must be able to accept native token.\n  function _transferOutETH(uint256 _amountOut, address _receiver) private {\n    IWNative(ConfigStorage(CrossMarginService(crossMarginService).configStorage()).weth()).withdraw(_amountOut);\n    // slither-disable-next-line arbitrary-send-eth\n    payable(_receiver).transfer(_amountOut);\n  }\n  function _getSubAccount(address _primary, uint8 _subAccountId) private pure returns (address) {\n    if (_subAccountId > 255) revert();\n    return address(uint160(_primary) ^ uint160(_subAccountId));\n  }\n  receive() external payable {\n    // @dev Cannot enable this check due to Solidity Fallback Function Gas Limit introduced in 0.8.17.\n    // ref - https://stackoverflow.com/questions/74930609/solidity-fallback-function-gas-limit\n    // require(msg.sender == ConfigStorage(CrossMarginService(crossMarginService).configStorage()).weth());\n  }\n  /// @custom:oz-upgrades-unsafe-allow constructor\n  constructor() {\n    _disableInitializers();\n  }\n}",
        "after": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.18;\n// base\nimport { ERC20Upgradeable } from \"@openzeppelin-upgradeable/contracts/token/ERC20/ERC20Upgradeable.sol\";\nimport { SafeERC20Upgradeable } from \"@openzeppelin-upgradeable/contracts/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport { ReentrancyGuardUpgradeable } from \"@openzeppelin-upgradeable/contracts/security/ReentrancyGuardUpgradeable.sol\";\nimport { OwnableUpgradeable } from \"@openzeppelin-upgradeable/contracts/access/OwnableUpgradeable.sol\";\n// interfaces\nimport { ICrossMarginHandler } from \"@hmx/handlers/interfaces/ICrossMarginHandler.sol\";\nimport { CrossMarginService } from \"@hmx/services/CrossMarginService.sol\";\nimport { IEcoPyth } from \"@hmx/oracles/interfaces/IEcoPyth.sol\";\nimport { IWNative } from \"../interfaces/IWNative.sol\";\nimport { VaultStorage } from \"@hmx/storages/VaultStorage.sol\";\nimport { ConfigStorage } from \"@hmx/storages/ConfigStorage.sol\";\n/// @title CrossMarginHandler\n/// @notice This contract handles the deposit and withdrawal of collateral tokens for the Cross Margin Trading module.\ncontract CrossMarginHandler is OwnableUpgradeable, ReentrancyGuardUpgradeable, ICrossMarginHandler {\n  using SafeERC20Upgradeable for ERC20Upgradeable;\n  /**\n   * Events\n   */\n  event LogDepositCollateral(\n    address indexed primaryAccount,\n    uint256 indexed subAccountId,\n    address token,\n    uint256 amount\n  );\n  event LogWithdrawCollateral(\n    address indexed primaryAccount,\n    uint256 indexed subAccountId,\n    address token,\n    uint256 amount\n  );\n  event LogSetCrossMarginService(address indexed oldCrossMarginService, address newCrossMarginService);\n  event LogSetPyth(address indexed oldPyth, address newPyth);\n  event LogSetOrderExecutor(address executor, bool isAllow);\n  event LogSetMinExecutionFee(uint256 oldValue, uint256 newValue);\n  event LogCreateWithdrawOrder(\n    address indexed account,\n    uint8 indexed subAccountId,\n    uint256 indexed orderId,\n    address token,\n    uint256 amount,\n    uint256 executionFee,\n    bool shouldUnwrap\n  );\n  event LogCancelWithdrawOrder(\n    address indexed account,\n    uint8 indexed subAccountId,\n    uint256 indexed orderId,\n    address token,\n    uint256 amount,\n    uint256 executionFee,\n    bool shouldUnwrap\n  );\n  event LogExecuteWithdrawOrder(\n    address indexed account,\n    uint8 indexed subAccountId,\n    uint256 indexed orderId,\n    address token,\n    uint256 amount,\n    bool shouldUnwrap,\n    bool isSuccess\n  );\n  /**\n   * Constants\n   */\n  uint64 internal constant RATE_PRECISION = 1e18;\n  /**\n   * States\n   */\n  address public crossMarginService;\n  address public pyth;\n  uint256 public nextExecutionOrderIndex; // the index of the next withdraw order that should be executed\n  uint256 public minExecutionOrderFee; // minimum execution order fee in native token amount\n\n  WithdrawOrder[] public withdrawOrders; // all withdrawOrder\n  mapping(address => WithdrawOrder[]) public subAccountExecutedWithdrawOrders; // subAccount -> executed orders\n\n    \n          \n            \n    \n\n          \n          Expand Down\n          \n            \n    \n\n          \n          Expand Up\n    \n    @@ -303,8 +302,6 @@ contract CrossMarginHandler is OwnableUpgradeable, ReentrancyGuardUpgradeable, I\n  \n  mapping(address => bool) public orderExecutors; //address -> flag to execute\n  /// @notice Initializes the CrossMarginHandler contract with the provided configuration parameters.\n  /// @param _crossMarginService Address of the CrossMarginService contract.\n  /// @param _pyth Address of the Pyth contract.\n  /// @param _minExecutionOrderFee Minimum execution fee for a withdrawal order.\n  function initialize(address _crossMarginService, address _pyth, uint256 _minExecutionOrderFee) external initializer {\n    OwnableUpgradeable.__Ownable_init();\n    ReentrancyGuardUpgradeable.__ReentrancyGuard_init();\n    // Sanity check\n    CrossMarginService(_crossMarginService).vaultStorage();\n    IEcoPyth(_pyth).getAssetIds();\n    crossMarginService = _crossMarginService;\n    pyth = _pyth;\n    minExecutionOrderFee = _minExecutionOrderFee;\n  }\n  function getActiveWithdrawOrders(\n    uint256 _limit,\n    uint256 _offset\n  ) external view returns (WithdrawOrder[] memory _withdrawOrder) {\n    // Find the _returnCount\n    uint256 _returnCount;\n    {\n      uint256 _activeOrderCount = withdrawOrders.length - nextExecutionOrderIndex;\n      uint256 _afterOffsetCount = _activeOrderCount > _offset ? (_activeOrderCount - _offset) : 0;\n      _returnCount = _afterOffsetCount > _limit ? _limit : _afterOffsetCount;\n      if (_returnCount == 0) return _withdrawOrder;\n    }\n    // Initialize order array\n    _withdrawOrder = new WithdrawOrder[](_returnCount);\n    // Build the array\n    {\n      for (uint i = 0; i < _returnCount; ) {\n        _withdrawOrder[i] = withdrawOrders[nextExecutionOrderIndex + _offset + i];\n        unchecked {\n          ++i;\n        }\n      }\n      return _withdrawOrder;\n    }\n  }\n  function getExecutedWithdrawOrders(\n    address _subAccount,\n    uint256 _limit,\n    uint256 _offset\n  ) external view returns (WithdrawOrder[] memory _withdrawOrder) {\n    // Find the _returnCount and\n    uint256 _returnCount;\n    {\n      uint256 _exeuctedOrderCount = subAccountExecutedWithdrawOrders[_subAccount].length;\n      uint256 _afterOffsetCount = _exeuctedOrderCount > _offset ? (_exeuctedOrderCount - _offset) : 0;\n      _returnCount = _afterOffsetCount > _limit ? _limit : _afterOffsetCount;\n      if (_returnCount == 0) return _withdrawOrder;\n    }\n    // Initialize order array\n    _withdrawOrder = new WithdrawOrder[](_returnCount);\n    // Build the array\n    {\n      for (uint i = 0; i < _returnCount; ) {\n        _withdrawOrder[i] = subAccountExecutedWithdrawOrders[_subAccount][_offset + i];\n        unchecked {\n          ++i;\n        }\n      }\n      return _withdrawOrder;\n    }\n  }\n  /**\n   * Modifiers\n   */\n  /// @notice Validate only accepted collateral tokens to be deposited or withdrawn\n  modifier onlyAcceptedToken(address _token) {\n    ConfigStorage(CrossMarginService(crossMarginService).configStorage()).validateAcceptedCollateral(_token);\n    _;\n  }\n  /// @notice Validate only whitelisted executors to call function\n  modifier onlyOrderExecutor() {\n    if (!orderExecutors[msg.sender]) revert ICrossMarginHandler_NotWhitelisted();\n    _;\n  }\n  /**\n   * CALCULATION\n   */\n  /// @notice Deposits the specified amount of collateral token into the user's sub-account.\n  /// @param _subAccountId ID of the user's sub-account.\n  /// @param _token Address of the collateral token to deposit.\n  /// @param _amount Amount of collateral token to deposit.\n  /// @param _shouldWrap Whether to wrap native ETH into WETH before depositing.\n  function depositCollateral(\n    uint8 _subAccountId,\n    address _token,\n    uint256 _amount,\n    bool _shouldWrap\n  ) external payable nonReentrant onlyAcceptedToken(_token) {\n    // SLOAD\n    CrossMarginService _crossMarginService = CrossMarginService(crossMarginService);\n    if (_shouldWrap) {\n      // Prevent mismatch msgValue and the input amount\n      if (msg.value != _amount) {\n        revert ICrossMarginHandler_MismatchMsgValue();\n      }\n      // Wrap the native to wNative. The _token must be wNative.\n      // If not, it would revert transfer amount exceed on the next line.\n      // slither-disable-next-line arbitrary-send-eth\n      IWNative(_token).deposit{ value: _amount }();\n      // Transfer those wNative token from this contract to VaultStorage\n      ERC20Upgradeable(_token).safeTransfer(_crossMarginService.vaultStorage(), _amount);\n    } else {\n      // Transfer depositing token from trader's wallet to VaultStorage\n      ERC20Upgradeable(_token).safeTransferFrom(msg.sender, _crossMarginService.vaultStorage(), _amount);\n    }\n    // Call service to deposit collateral\n    _crossMarginService.depositCollateral(msg.sender, _subAccountId, _token, _amount);\n    emit LogDepositCollateral(msg.sender, _subAccountId, _token, _amount);\n  }\n  /// @notice Creates a new withdraw order to withdraw the specified amount of collateral token from the user's sub-account.\n  /// @param _subAccountId ID of the user's sub-account.\n  /// @param _token Address of the collateral token to withdraw.\n  /// @param _amount Amount of collateral token to withdraw.\n  /// @param _executionFee Execution fee to pay for this order.\n  /// @param _shouldUnwrap Whether to unwrap WETH into native ETH after withdrawing.\n  /// @return _orderId The ID of the newly created withdraw order.\n  function createWithdrawCollateralOrder(\n    uint8 _subAccountId,\n    address _token,\n    uint256 _amount,\n    uint256 _executionFee,\n    bool _shouldUnwrap\n  ) external payable nonReentrant onlyAcceptedToken(_token) returns (uint256 _orderId) {\n    if (_executionFee < minExecutionOrderFee) revert ICrossMarginHandler_InsufficientExecutionFee();\n    if (msg.value != _executionFee) revert ICrossMarginHandler_InCorrectValueTransfer();\n    // convert native to WNative (including executionFee)\n    _transferInETH();\n    _orderId = withdrawOrders.length;\n    withdrawOrders.push(\n      WithdrawOrder({\n        account: payable(msg.sender),\n        orderId: _orderId,\n        token: _token,\n        amount: _amount,\n        executionFee: _executionFee,\n        shouldUnwrap: _shouldUnwrap,\n        subAccountId: _subAccountId,\n        crossMarginService: CrossMarginService(crossMarginService),\n        createdTimestamp: uint48(block.timestamp),\n        executedTimestamp: 0,\n        status: 0 // pending\n      })\n    );\n    emit LogCreateWithdrawOrder(msg.sender, _subAccountId, _orderId, _token, _amount, _executionFee, _shouldUnwrap);\n    return _orderId;\n  }\n  /// @notice Executes a batch of pending withdraw orders.\n  /// @param _endIndex The index of the last withdraw order to execute.\n  /// @param _feeReceiver The address to receive the total execution fee.\n  /// @param _priceData Price data from the Pyth oracle.\n  /// @param _publishTimeData Publish time data from the Pyth oracle.\n  /// @param _minPublishTime Minimum publish time for the Pyth oracle data.\n  /// @param _encodedVaas Encoded VaaS data for the Pyth oracle.\n  // slither-disable-next-line reentrancy-eth\n  function executeOrder(\n    uint256 _endIndex,\n    address payable _feeReceiver,\n    bytes32[] memory _priceData,\n    bytes32[] memory _publishTimeData,\n    uint256 _minPublishTime,\n    bytes32 _encodedVaas\n  ) external nonReentrant onlyOrderExecutor {\n    // Get the number of withdraw orders\n    uint256 _orderLength = withdrawOrders.length;\n    // Ensure there are orders to execute\n    if (nextExecutionOrderIndex == _orderLength) revert ICrossMarginHandler_NoOrder();\n    // Set the end index to the latest order index if it exceeds the number of orders\n    uint256 _latestOrderIndex = _orderLength - 1;\n    if (_endIndex > _latestOrderIndex) {\n      _endIndex = _latestOrderIndex;\n    }\n    // Update the price and publish time data using the Pyth oracle\n    // slither-disable-next-line arbitrary-send-eth\n    IEcoPyth(pyth).updatePriceFeeds(_priceData, _publishTimeData, _minPublishTime, _encodedVaas);\n    // Initialize variables for the execution loop\n    WithdrawOrder memory _order;\n    uint256 _totalFeeReceiver;\n    uint256 _executionFee;\n    for (uint256 i = nextExecutionOrderIndex; i <= _endIndex; ) {\n      _order = withdrawOrders[i];\n      _executionFee = _order.executionFee;\n\n      try this.executeWithdrawOrder(_order) {\n        emit LogExecuteWithdrawOrder(\n\n    \n          \n            \n    \n\n          \n          Expand Down\n          \n            \n    \n\n          \n          Expand Up\n    \n    @@ -339,7 +336,6 @@ contract CrossMarginHandler is OwnableUpgradeable, ReentrancyGuardUpgradeable, I\n  \n          _order.account,\n          _order.subAccountId,\n          _order.orderId,\n          _order.token,\n          _order.amount,\n          _order.shouldUnwrap,\n          true\n        );\n        // update order status\n        _order.status = 1; // success\n      } catch Error(string memory) {\n        // Do nothing\n      } catch (bytes memory) {\n        emit LogExecuteWithdrawOrder(\n          _order.account,\n          _order.subAccountId,\n          _order.orderId,\n          _order.token,\n          _order.amount,\n          _order.shouldUnwrap,\n          false\n        );\n        // update order status\n        _order.status = 2; // fail\n      }\n      // assign exec time\n      _order.executedTimestamp = uint48(block.timestamp);\n\n      _totalFeeReceiver += _executionFee;\n\n      // save to executed order first\n\n    \n        \n          \n    \n\n        \n        Expand All\n    \n    @@ -361,7 +357,7 @@ contract CrossMarginHandler is OwnableUpgradeable, ReentrancyGuardUpgradeable, I\n  \n      subAccountExecutedWithdrawOrders[_getSubAccount(_order.account, _order.subAccountId)].push(_order);\n      // clear executed withdraw order\n      delete withdrawOrders[i];\n      unchecked {\n        ++i;\n      }\n    }\n    nextExecutionOrderIndex = _endIndex + 1;\n    // Pay total collected fees to the executor\n    _transferOutETH(_totalFeeReceiver, _feeReceiver);\n  }\n  /// @notice Executes a single withdraw order by transferring the specified amount of collateral token to the user's wallet.\n  /// @param _order WithdrawOrder struct representing the order to execute.\n  function executeWithdrawOrder(WithdrawOrder memory _order) external {\n    // if not in executing state, then revert\n    if (msg.sender != address(this)) revert ICrossMarginHandler_NotExecutionState();\n\n    // Call service to withdraw collateral\n    if (_order.shouldUnwrap) {\n\n    \n          \n            \n    \n\n          \n          Expand Down\n    \n    \n  \n      // Withdraw wNative straight to this contract first.\n      _order.crossMarginService.withdrawCollateral(\n        _order.account,\n        _order.subAccountId,\n        _order.token,\n        _order.amount,\n        address(this)\n      );\n      // Then we unwrap the wNative token. The receiving amount should be the exact same as _amount. (No fee deducted when withdraw)\n      IWNative(_order.token).withdraw(_order.amount);\n      // slither-disable-next-line arbitrary-send-eth\n      payable(_order.account).transfer(_order.amount);\n    } else {\n      // Withdraw _token straight to the user\n      _order.crossMarginService.withdrawCollateral(\n        _order.account,\n        _order.subAccountId,\n        _order.token,\n        _order.amount,\n        _order.account\n      );\n    }\n    emit LogWithdrawCollateral(_order.account, _order.subAccountId, _order.token, _order.amount);\n  }\n  /// @notice Cancels the specified withdraw order.\n  /// @param _orderIndex Index of the order to cancel.\n  function cancelWithdrawOrder(uint256 _orderIndex) external nonReentrant {\n    // if order index >= liquidity order's length, then out of bound\n    // if order index < next execute index, means order index outdate\n    if (_orderIndex >= withdrawOrders.length || _orderIndex < nextExecutionOrderIndex) {\n      revert ICrossMarginHandler_NoOrder();\n    }\n    // SLOAD\n    WithdrawOrder memory _order = withdrawOrders[_orderIndex];\n    // validate if msg.sender is not owned the order, then revert\n    if (msg.sender != _order.account) revert ICrossMarginHandler_NotOrderOwner();\n    delete withdrawOrders[_orderIndex];\n    emit LogCancelWithdrawOrder(\n      payable(msg.sender),\n      _order.subAccountId,\n      _order.orderId,\n      _order.token,\n      _order.amount,\n      _order.executionFee,\n      _order.shouldUnwrap\n    );\n  }\n  /**\n   * GETTER\n   */\n  /// @notice Returns all pending withdraw orders.\n  /// @return _withdrawOrders An array of WithdrawOrder structs representing all pending withdraw orders.\n  function getWithdrawOrders() external view returns (WithdrawOrder[] memory _withdrawOrders) {\n    return withdrawOrders;\n  }\n  /// @notice get withdraw orders length\n  function getWithdrawOrderLength() external view returns (uint256) {\n    return withdrawOrders.length;\n  }\n  /**\n   * Setters\n   */\n  /// @notice Sets a new CrossMarginService contract address.\n  /// @param _crossMarginService The new CrossMarginService contract address.\n  function setCrossMarginService(address _crossMarginService) external nonReentrant onlyOwner {\n    if (_crossMarginService == address(0)) revert ICrossMarginHandler_InvalidAddress();\n    emit LogSetCrossMarginService(crossMarginService, _crossMarginService);\n    crossMarginService = _crossMarginService;\n    // Sanity check\n    CrossMarginService(_crossMarginService).vaultStorage();\n  }\n  /// @notice Sets a new Pyth contract address.\n  /// @param _pyth The new Pyth contract address.\n  function setPyth(address _pyth) external nonReentrant onlyOwner {\n    if (_pyth == address(0)) revert ICrossMarginHandler_InvalidAddress();\n    emit LogSetPyth(pyth, _pyth);\n    pyth = _pyth;\n    // Sanity check\n    IEcoPyth(_pyth).getAssetIds();\n  }\n  /// @notice setMinExecutionFee\n  /// @param _newMinExecutionFee minExecutionFee in ethers\n  function setMinExecutionFee(uint256 _newMinExecutionFee) external nonReentrant onlyOwner {\n    emit LogSetMinExecutionFee(minExecutionOrderFee, _newMinExecutionFee);\n    minExecutionOrderFee = _newMinExecutionFee;\n  }\n  /// @notice setOrderExecutor\n  /// @param _executor address who will be executor\n  /// @param _isAllow flag to allow to execute\n  function setOrderExecutor(address _executor, bool _isAllow) external nonReentrant onlyOwner {\n    orderExecutors[_executor] = _isAllow;\n    emit LogSetOrderExecutor(_executor, _isAllow);\n  }\n  /// @notice convert collateral\n  function convertSGlpCollateral(\n    uint8 _subAccountId,\n    address _tokenOut,\n    uint256 _amountIn\n  ) external nonReentrant onlyAcceptedToken(_tokenOut) returns (uint256 _amountOut) {\n    return\n      CrossMarginService(crossMarginService).convertSGlpCollateral(msg.sender, _subAccountId, _tokenOut, _amountIn);\n  }\n  /**\n   * Private Functions\n   */\n  /// @notice Transfer in ETH from user to be used as execution fee\n  /// @dev The received ETH will be wrapped into WETH and store in this contract for later use.\n  function _transferInETH() private {\n    IWNative(ConfigStorage(CrossMarginService(crossMarginService).configStorage()).weth()).deposit{\n      value: msg.value\n    }();\n  }\n  /// @notice Transfer out ETH to the receiver\n  /// @dev The stored WETH will be unwrapped and transfer as native token\n  /// @param _amountOut Amount of ETH to be transferred\n  /// @param _receiver The receiver of ETH in its native form. The receiver must be able to accept native token.\n  function _transferOutETH(uint256 _amountOut, address _receiver) private {\n    IWNative(ConfigStorage(CrossMarginService(crossMarginService).configStorage()).weth()).withdraw(_amountOut);\n    // slither-disable-next-line arbitrary-send-eth\n    payable(_receiver).transfer(_amountOut);\n  }\n  function _getSubAccount(address _primary, uint8 _subAccountId) private pure returns (address) {\n    if (_subAccountId > 255) revert();\n    return address(uint160(_primary) ^ uint160(_subAccountId));\n  }\n  receive() external payable {\n    // @dev Cannot enable this check due to Solidity Fallback Function Gas Limit introduced in 0.8.17.\n    // ref - https://stackoverflow.com/questions/74930609/solidity-fallback-function-gas-limit\n    // require(msg.sender == ConfigStorage(CrossMarginService(crossMarginService).configStorage()).weth());\n  }\n  /// @custom:oz-upgrades-unsafe-allow constructor\n  constructor() {\n    _disableInitializers();\n  }\n}"
    },
    {
        "tag": "Front-Running",
        "url": "https://github.com/gabrielyiu/pendle-core-v2-public/commit/bd198cb836a6596e16ece191a4753e219a634f32",
        "file": "contracts/core/Market/PendleMarketFactory.sol",
        "before": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.15;\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\nimport \"../../interfaces/IPMarket.sol\";\nimport \"../../interfaces/IPYieldContractFactory.sol\";\nimport \"../../interfaces/IPMarketFactory.sol\";\nimport \"../../libraries/helpers/SSTORE2Deployer.sol\";\nimport \"../../periphery/PermissionsV2Upg.sol\";\nimport \"./PendleMarket.sol\";\nimport \"../LiquidityMining/PendleGauge.sol\";\ncontract PendleMarketFactory is PermissionsV2Upg, Initializable, IPMarketFactory {\n    using EnumerableSet for EnumerableSet.AddressSet;\n    struct MarketConfig {\n        address treasury;\n        uint96 lnFeeRateRoot;\n        // 1 SLOT = 256 bits\n        uint32 rateOracleTimeWindow;\n        uint8 reserveFeePercent;\n        // 1 SLOT = 40 bits\n    }\n    uint256 private constant MIN_RATE_ORACLE_TIME_WINDOW = 300 seconds;\n    address public immutable yieldContractFactory;\n    address public marketCreationCodePointer;\n    uint256 public immutable maxLnFeeRateRoot;\n    // PT -> scalarRoot -> initialAnchor\n    mapping(address => mapping(int256 => mapping(int256 => address))) internal markets;\n    EnumerableSet.AddressSet internal allMarkets;\n    address public vePendle;\n    address public gaugeController;\n    MarketConfig public marketConfig;\n    constructor(\n        address _governanceManager,\n        address _yieldContractFactory,\n        address _treasury,\n        uint96 _lnFeeRateRoot,\n        uint32 _rateOracleTimeWindow,\n        uint8 _reserveFeePercent\n    ) PermissionsV2Upg(_governanceManager) {\n        require(_yieldContractFactory != address(0), \"zero address\");\n        yieldContractFactory = _yieldContractFactory;\n        maxLnFeeRateRoot = uint256(LogExpMath.ln(int256((105 * Math.IONE) / 100))); // ln(1.05)\n        setTreasury(_treasury);\n        setlnFeeRateRoot(_lnFeeRateRoot);\n        setRateOracleTimeWindow(_rateOracleTimeWindow);\n        setReserveFeePercent(_reserveFeePercent);\n    }\n    function initialize(\n        address newVePendle,\n        address newGaugeController,\n        bytes memory _marketCreationCode\n    ) external onlyGovernance initializer {\n        require(newVePendle != address(0) && newGaugeController != address(0), \"zero address\");\n        vePendle = newVePendle;\n        gaugeController = newGaugeController;\n\n    \n          \n            \n    \n\n          \n          Expand Down\n    \n    \n  \n        marketCreationCodePointer = SSTORE2Deployer.setCreationCode(_marketCreationCode);\n    }\n    /**\n     * @notice Create a market between PT and its corresponding SCY\n     * with scalar & anchor config. Anyone is allowed to create a market on their own.\n     */\n    function createNewMarket(\n        address PT,\n        int256 scalarRoot,\n        int256 initialAnchor\n    ) external returns (address market) {\n        require(!IPPrincipalToken(PT).isExpired(), \"PT is expired\");\n        require(IPYieldContractFactory(yieldContractFactory).isPT(PT), \"Invalid PT\");\n        require(markets[PT][scalarRoot][initialAnchor] == address(0), \"market already created\");\n        // no need salt since market's existence has been checked before hand\n        market = SSTORE2Deployer.create2(\n            marketCreationCodePointer,\n            bytes32(block.chainid),\n            abi.encode(PT, scalarRoot, initialAnchor, vePendle, gaugeController)\n        );\n        markets[PT][scalarRoot][initialAnchor] = market;\n        require(allMarkets.add(market), \"IE market can't be added\");\n        emit CreateNewMarket(market, PT, scalarRoot, initialAnchor);\n    }\n    /// @dev for gas-efficient verification of market\n    function isValidMarket(address market) external view returns (bool) {\n        return allMarkets.contains(market);\n    }\n    function treasury() external view returns (address) {\n        return marketConfig.treasury;\n    }\n    function setTreasury(address newTreasury) public onlyGovernance {\n        require(newTreasury != address(0), \"zero address\");\n        marketConfig.treasury = newTreasury;\n        _emitNewMarketConfigEvent();\n    }\n    function setlnFeeRateRoot(uint96 newlnFeeRateRoot) public onlyGovernance {\n        require(newlnFeeRateRoot <= maxLnFeeRateRoot, \"invalid fee rate root\");\n        marketConfig.lnFeeRateRoot = newlnFeeRateRoot;\n        _emitNewMarketConfigEvent();\n    }\n    function setRateOracleTimeWindow(uint32 newRateOracleTimeWindow) public onlyGovernance {\n        require(newRateOracleTimeWindow >= MIN_RATE_ORACLE_TIME_WINDOW, \"invalid time window\");\n        marketConfig.rateOracleTimeWindow = newRateOracleTimeWindow;\n        _emitNewMarketConfigEvent();\n    }\n    function setReserveFeePercent(uint8 newReserveFeePercent) public onlyGovernance {\n        require(newReserveFeePercent <= 100, \"invalid reserve fee percent\");\n        marketConfig.reserveFeePercent = newReserveFeePercent;\n        _emitNewMarketConfigEvent();\n    }\n    function _emitNewMarketConfigEvent() internal {\n        MarketConfig memory local = marketConfig;\n        emit NewMarketConfig(\n            local.treasury,\n            local.lnFeeRateRoot,\n            local.rateOracleTimeWindow,\n            local.reserveFeePercent\n        );\n    }\n}",
        "after": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.15;\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\nimport \"../../interfaces/IPMarket.sol\";\nimport \"../../interfaces/IPYieldContractFactory.sol\";\nimport \"../../interfaces/IPMarketFactory.sol\";\nimport \"../../libraries/helpers/SSTORE2Deployer.sol\";\nimport \"../../periphery/PermissionsV2Upg.sol\";\nimport \"./PendleMarket.sol\";\nimport \"../LiquidityMining/PendleGauge.sol\";\ncontract PendleMarketFactory is PermissionsV2Upg, Initializable, IPMarketFactory {\n    using EnumerableSet for EnumerableSet.AddressSet;\n    struct MarketConfig {\n        address treasury;\n        uint96 lnFeeRateRoot;\n        // 1 SLOT = 256 bits\n        uint32 rateOracleTimeWindow;\n        uint8 reserveFeePercent;\n        // 1 SLOT = 40 bits\n    }\n    uint256 private constant MIN_RATE_ORACLE_TIME_WINDOW = 300 seconds;\n    address public immutable yieldContractFactory;\n    address public marketCreationCodePointer;\n    uint256 public immutable maxLnFeeRateRoot;\n    // PT -> scalarRoot -> initialAnchor\n    mapping(address => mapping(int256 => mapping(int256 => address))) internal markets;\n    EnumerableSet.AddressSet internal allMarkets;\n    address public vePendle;\n    address public gaugeController;\n    MarketConfig public marketConfig;\n    constructor(\n        address _governanceManager,\n        address _yieldContractFactory,\n        address _treasury,\n        uint96 _lnFeeRateRoot,\n        uint32 _rateOracleTimeWindow,\n        uint8 _reserveFeePercent\n    ) PermissionsV2Upg(_governanceManager) {\n        require(_yieldContractFactory != address(0), \"zero address\");\n        yieldContractFactory = _yieldContractFactory;\n        maxLnFeeRateRoot = uint256(LogExpMath.ln(int256((105 * Math.IONE) / 100))); // ln(1.05)\n        setTreasury(_treasury);\n        setlnFeeRateRoot(_lnFeeRateRoot);\n        setRateOracleTimeWindow(_rateOracleTimeWindow);\n        setReserveFeePercent(_reserveFeePercent);\n    }\n    function initialize(\n        address newVePendle,\n        address newGaugeController,\n        bytes memory _marketCreationCode\n    ) external initializer onlyGovernance {\n        require(newVePendle != address(0) && newGaugeController != address(0), \"zero address\");\n        vePendle = newVePendle;\n        gaugeController = newGaugeController;\n\n    \n          \n            \n    \n\n          \n          Expand Down\n    \n    \n  \n        marketCreationCodePointer = SSTORE2Deployer.setCreationCode(_marketCreationCode);\n    }\n    /**\n     * @notice Create a market between PT and its corresponding SCY\n     * with scalar & anchor config. Anyone is allowed to create a market on their own.\n     */\n    function createNewMarket(\n        address PT,\n        int256 scalarRoot,\n        int256 initialAnchor\n    ) external returns (address market) {\n        require(!IPPrincipalToken(PT).isExpired(), \"PT is expired\");\n        require(IPYieldContractFactory(yieldContractFactory).isPT(PT), \"Invalid PT\");\n        require(markets[PT][scalarRoot][initialAnchor] == address(0), \"market already created\");\n        // no need salt since market's existence has been checked before hand\n        market = SSTORE2Deployer.create2(\n            marketCreationCodePointer,\n            bytes32(block.chainid),\n            abi.encode(PT, scalarRoot, initialAnchor, vePendle, gaugeController)\n        );\n        markets[PT][scalarRoot][initialAnchor] = market;\n        require(allMarkets.add(market), \"IE market can't be added\");\n        emit CreateNewMarket(market, PT, scalarRoot, initialAnchor);\n    }\n    /// @dev for gas-efficient verification of market\n    function isValidMarket(address market) external view returns (bool) {\n        return allMarkets.contains(market);\n    }\n    function treasury() external view returns (address) {\n        return marketConfig.treasury;\n    }\n    function setTreasury(address newTreasury) public onlyGovernance {\n        require(newTreasury != address(0), \"zero address\");\n        marketConfig.treasury = newTreasury;\n        _emitNewMarketConfigEvent();\n    }\n    function setlnFeeRateRoot(uint96 newlnFeeRateRoot) public onlyGovernance {\n        require(newlnFeeRateRoot <= maxLnFeeRateRoot, \"invalid fee rate root\");\n        marketConfig.lnFeeRateRoot = newlnFeeRateRoot;\n        _emitNewMarketConfigEvent();\n    }\n    function setRateOracleTimeWindow(uint32 newRateOracleTimeWindow) public onlyGovernance {\n        require(newRateOracleTimeWindow >= MIN_RATE_ORACLE_TIME_WINDOW, \"invalid time window\");\n        marketConfig.rateOracleTimeWindow = newRateOracleTimeWindow;\n        _emitNewMarketConfigEvent();\n    }\n    function setReserveFeePercent(uint8 newReserveFeePercent) public onlyGovernance {\n        require(newReserveFeePercent <= 100, \"invalid reserve fee percent\");\n        marketConfig.reserveFeePercent = newReserveFeePercent;\n        _emitNewMarketConfigEvent();\n    }\n    function _emitNewMarketConfigEvent() internal {\n        MarketConfig memory local = marketConfig;\n        emit NewMarketConfig(\n            local.treasury,\n            local.lnFeeRateRoot,\n            local.rateOracleTimeWindow,\n            local.reserveFeePercent\n        );\n    }\n}"
    },
    {
        "tag": "reentrancy",
        "url": "https://github.com/arch-protocol/chambers/commit/8a21d06b5a74dda6ca05ddedc278feef19417e71",
        "file": "src/Chamber.sol",
        "before": "/**\n *     SPDX-License-Identifier: Apache License 2.0\n *\n *     Copyright 2018 Set Labs Inc.\n *     Copyright 2022 Smash Works Inc.\n *\n *     Licensed under the Apache License, Version 2.0 (the \"License\");\n *     you may not use this file except in compliance with the License.\n *     You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n *     Unless required by applicable law or agreed to in writing, software\n *     distributed under the License is distributed on an \"AS IS\" BASIS,\n *     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *     See the License for the specific language governing permissions and\n *     limitations under the License.\n *\n *     NOTICE\n *\n *     This is a modified code from Set Labs Inc. found at\n *\n *     https://github.com/SetProtocol/set-protocol-contracts\n *\n *     All changes made by Smash Works Inc. are described and documented at\n *\n *     https://docs.arch.finance/chambers\n */\npragma solidity ^0.8.17.0;\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {Owned} from \"solmate/auth/Owned.sol\";\nimport {ReentrancyGuard} from \"solmate/utils/ReentrancyGuard.sol\";\nimport {ArrayUtils} from \"./lib/ArrayUtils.sol\";\nimport {IChamberGod} from \"./interfaces/IChamberGod.sol\";\nimport {IChamber} from \"./interfaces/IChamber.sol\";\nimport {PreciseUnitMath} from \"./lib/PreciseUnitMath.sol\";\nimport {Address} from \"@openzeppelin/contracts/utils/Address.sol\";\ncontract Chamber is IChamber, Owned, ReentrancyGuard, ERC20 {\n    /*//////////////////////////////////////////////////////////////\n                                 CONSTANTS\n    //////////////////////////////////////////////////////////////*/\n    IChamberGod private god;\n    /*//////////////////////////////////////////////////////////////\n                                 LIBRARIES\n    //////////////////////////////////////////////////////////////*/\n    using ArrayUtils for address[];\n    using SafeERC20 for IERC20;\n    using Address for address;\n    using PreciseUnitMath for uint256;\n    /*//////////////////////////////////////////////////////////////\n                            CHAMBER STORAGE\n    //////////////////////////////////////////////////////////////*/\n    address[] public constituents;\n    mapping(address => uint256) public constituentQuantities;\n    address[] public wizards;\n    address[] public managers;\n\n    address[] public allowedContracts;\n\n    /*//////////////////////////////////////////////////////////////\n                                MODIFIERS\n    //////////////////////////////////////////////////////////////*/\n\n    \n        \n          \n    \n\n        \n        Expand All\n    \n    @@ -85,6 +87,13 @@ contract Chamber is IChamber, Owned, ReentrancyGuard, ERC20 {\n  \n    modifier onlyManager() virtual {\n        require(isManager(msg.sender), \"Must be Manager\");\n        _;\n    }\n    modifier onlyWizard() virtual {\n        require(isWizard(msg.sender), \"Must be a wizard\");\n        _;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    \n          \n            \n    \n\n          \n          Expand Down\n          \n            \n    \n\n          \n          Expand Up\n    \n    @@ -363,6 +372,24 @@ contract Chamber is IChamber, Owned, ReentrancyGuard, ERC20 {\n  \n    /**\n     * @param _owner        Owner of the chamber\n     * @param _name         Name of the chamber token\n     * @param _symbol       Symbol of the chamber token\n     * @param _constituents Initial constituents addresses of the chamber\n     * @param _quantities   Initial quantities of the chamber constituents\n     * @param _wizards      Allowed addresses that can access onlyWizard functions\n     * @param _managers     Allowed addresses that can access onlyManager functions\n     */\n    constructor(\n        address _owner,\n        string memory _name,\n        string memory _symbol,\n        address[] memory _constituents,\n        uint256[] memory _quantities,\n        address[] memory _wizards,\n        address[] memory _managers\n    ) Owned(_owner) ERC20(_name, _symbol, 18) {\n        constituents = _constituents;\n        wizards = _wizards;\n        god = IChamberGod(msg.sender);\n        for (uint256 i = 0; i < _managers.length; i++) {\n            managers.push(_managers[i]);\n        }\n        for (uint256 j = 0; j < _constituents.length; j++) {\n            constituentQuantities[_constituents[j]] = _quantities[j];\n        }\n    }\n    /*//////////////////////////////////////////////////////////////\n                               CHAMBER MANAGEMENT\n    //////////////////////////////////////////////////////////////*/\n    /**\n     * Allows the wizard to add a new constituent to the Chamber\n     *\n     * @param _constituent The address of the constituent to add\n     */\n    function addConstituent(address _constituent) external onlyWizard {\n        require(!isConstituent(_constituent), \"Must not be constituent\");\n        constituents.push(_constituent);\n        emit ConstituentAdded(_constituent);\n    }\n    /**\n     * Allows the wizard to remove a constituent from the Chamber\n     *\n     * @param _constituent The address of the constituent to remove\n     */\n    function removeConstituent(address _constituent) external onlyWizard {\n        require(isConstituent(_constituent), \"Must be constituent\");\n        constituents.removeStorage(_constituent);\n        emit ConstituentRemoved(_constituent);\n    }\n    /**\n     * Checks if the address is a manager of the Chamber\n     *\n     * @param _manager The address of a manager\n     *\n     * @return bool True/False if the address is a manager or not\n     */\n    function isManager(address _manager) public view returns (bool) {\n        return managers.contains(_manager);\n    }\n    /**\n     * Checks if the address is a wizard of the Chamber\n     *\n     * @param _wizard The address of a wizard\n     *\n     * @return bool True/False if the address is a wizard or not\n     */\n    function isWizard(address _wizard) public view returns (bool) {\n        return wizards.contains(_wizard);\n    }\n    /**\n     * Checks if the address is a constituent of the Chamber\n     *\n     * @param _constituent The address of a constituent\n     *\n     * @return bool True/False if the address is a constituent or not\n     */\n    function isConstituent(address _constituent) public view returns (bool) {\n        return constituents.contains(_constituent);\n    }\n    /**\n     * Allows the Owner to add a new manager to the Chamber\n     *\n     * @param _manager The address of the manager to add\n     */\n    function addManager(address _manager) external onlyOwner {\n        require(!isManager(_manager), \"Already manager\");\n        require(_manager != address(0), \"Cannot add null address\");\n        managers.push(_manager);\n        emit ManagerAdded(_manager);\n    }\n    /**\n     * Allows the Owner to remove a manager from the Chamber\n     *\n     * @param _manager The address of the manager to remove\n     */\n    function removeManager(address _manager) external onlyOwner {\n        require(isManager(_manager), \"Not a manager\");\n        managers.removeStorage(_manager);\n        emit ManagerRemoved(_manager);\n    }\n    /**\n     * Allows a Manager to add a new wizard to the Chamber\n     *\n     * @param _wizard The address of the wizard to add\n     */\n    function addWizard(address _wizard) external onlyManager {\n        require(god.isWizard(_wizard), \"Wizard not validated in ChamberGod\");\n        require(!isWizard(_wizard), \"Wizard already in Chamber\");\n        wizards.push(_wizard);\n        emit WizardAdded(_wizard);\n    }\n    /**\n     * Allows a Manager to remove a wizard from the Chamber\n     *\n     * @param _wizard The address of the wizard to remove\n     */\n    function removeWizard(address _wizard) external onlyManager {\n        require(isWizard(_wizard), \"Wizard not in chamber\");\n        wizards.removeStorage(_wizard);\n        emit WizardRemoved(_wizard);\n    }\n    /**\n     * Returns an array with the addresses of all the constituents of the\n     * Chamber\n     *\n     * @return an array of addresses for the constituents\n     */\n    function getConstituentsAddresses() external view returns (address[] memory) {\n        return constituents;\n    }\n    /**\n     * Returns an array with the quantities of all the constituents of the\n     * Chamber\n     *\n     * @return an array of uint256 for the quantities of the constituents\n     */\n    function getQuantities() external view returns (uint256[] memory) {\n        uint256[] memory quantities = new uint256[](constituents.length);\n        for (uint256 i = 0; i < constituents.length; i++) {\n            quantities[i] = constituentQuantities[constituents[i]];\n        }\n        return quantities;\n    }\n    /**\n     * Returns the quantity of a constituent of the Chamber\n     *\n     * @param _constituent The address of the constituent\n     *\n     * @return uint256 The quantity of the constituent\n     */\n    function getConstituentQuantity(address _constituent) external view returns (uint256) {\n        return constituentQuantities[_constituent];\n    }\n    /**\n     * Returns the addresses of all the wizards of the Chamber\n     *\n     * @return address[] Array containing the addresses of the wizards of the Chamber\n     */\n    function getWizards() external view returns (address[] memory) {\n        return wizards;\n    }\n    /**\n     * Returns the addresses of all the managers of the Chamber\n     *\n     * @return address[] Array containing the addresses of the managers of the Chamber\n     */\n    function getManagers() external view returns (address[] memory) {\n        return managers;\n    }\n    /**\n     * Returns the addresses of all the allowedContracts of the Chamber\n     *\n     * @return address[] Array containing the addresses of the allowedContracts of the Chamber\n     */\n    function getAllowedContracts() external view returns (address[] memory) {\n        return allowedContracts;\n    }\n    /**\n     * Allows a Manager to add a new allowedContract to the Chamber\n     *\n     * @param _target The address of the allowedContract to add\n     */\n    function addAllowedContract(address _target) external onlyManager {\n        require(god.isAllowedContract(_target), \"Contract not allowed in ChamberGod\");\n        require(!isAllowedContract(_target), \"Contract already allowed\");\n        allowedContracts.push(_target);\n        emit AllowedContractAdded(_target);\n    }\n    /**\n     * Allows a Manager to remove an allowedContract from the Chamber\n     *\n     * @param _target The address of the allowedContract to remove\n     */\n    function removeAllowedContract(address _target) external onlyManager {\n        require(isAllowedContract(_target), \"Contract not allowed\");\n        allowedContracts.removeStorage(_target);\n        emit AllowedContractRemoved(_target);\n    }\n    /**\n     * Checks if the address is an allowedContract of the Chamber\n     *\n     * @param _target The address of an allowedContract\n     *\n     * @return bool True/False if the address is an allowedContract or not\n     */\n    function isAllowedContract(address _target) public view returns (bool) {\n        return allowedContracts.contains(_target);\n    }\n    /*//////////////////////////////////////////////////////////////\n                               CHAMBER LOGIC\n    //////////////////////////////////////////////////////////////*/\n    /**\n     * Allows a wizard to mint an specific amount of chamber tokens\n     * to a recipient\n     *\n     * @param _recipient   The address of the recipient\n     * @param _quantity    The quantity of the chamber to mint\n     */\n    function mint(address _recipient, uint256 _quantity) external onlyWizard nonReentrant {\n        _mint(_recipient, _quantity);\n    }\n    /**\n     * Allows a wizard to burn an specific amount of chamber tokens\n     * from a source\n     *\n     * @param _from          The address of the source to burn from\n     * @param _quantity      The quantity of the chamber tokens to burn\n     */\n    function burn(address _from, uint256 _quantity) external onlyWizard nonReentrant {\n        _burn(_from, _quantity);\n    }\n\n    /**\n     * Allows a wizard to transfer an specific amount of constituent tokens\n     * to a recipient\n\n    \n        \n          \n    \n\n        \n        Expand All\n    \n    @@ -374,6 +401,7 @@ contract Chamber is IChamber, Owned, ReentrancyGuard, ERC20 {\n  \n     *\n     * @param _constituent   The address of the constituent\n     * @param _recipient     The address of the recipient to transfer tokens to\n     * @param _quantity      The quantity of the constituent to transfer\n     */\n    function withdrawTo(address _constituent, address _recipient, uint256 _quantity)\n        external\n        onlyWizard\n    {\n        if (_quantity > 0) {\n            // Retrieve current balance of token for the vault\n\n    \n        \n          \n    \n\n        \n        Expand All\n    \n    @@ -399,7 +427,7 @@ contract Chamber is IChamber, Owned, ReentrancyGuard, ERC20 {\n  \n            uint256 existingVaultBalance = IERC20(_constituent).balanceOf(address(this));\n            // Call specified ERC20 token contract to transfer tokens from Vault to user\n            IERC20(_constituent).safeTransfer(_recipient, _quantity);\n            // Verify transfer quantity is reflected in balance\n            uint256 newVaultBalance = IERC20(_constituent).balanceOf(address(this));\n            // Check to make sure current balances are as expected\n            require(\n                newVaultBalance >= existingVaultBalance - _quantity,\n                \"Chamber.withdrawTo: Invalid post-withdraw balance\"\n            );\n        }\n    }\n    /**\n     * Update the quantities of the constituents in the chamber based on the\n     * total suppply of tokens. Only considers constituents in the constituents\n     * list. Used by wizards. E.g. after an uncollateralized mint in the streaming fee wizard .\n     *\n     */\n    function updateQuantities() external onlyWizard nonReentrant {\n        uint256 _totalSupply = totalSupply;\n        uint256 _decimals = decimals;\n        for (uint256 i = 0; i < constituents.length; i++) {\n\n    \n          \n            \n    \n\n          \n          Expand Down\n    \n    \n  \n            address _constituent = constituents[i];\n            uint256 currentBalance = IERC20(_constituent).balanceOf(address(this));\n            uint256 _newQuantity = currentBalance.preciseDiv(_totalSupply, _decimals);\n            require(_newQuantity > 0, \"Zero quantity not allowed\");\n            constituentQuantities[_constituent] = _newQuantity;\n        }\n    }\n    /**\n     * Allows wizards to make low level calls to contracts that have been\n     * added to the allowedContracts mapping.\n     *\n     * @param _sellToken          The address of the token to sell\n     * @param _sellQuantity       The amount of sellToken to sell\n     * @param _buyToken           The address of the token to buy\n     * @param _minBuyQuantity     The minimum amount of buyToken that should be bought\n     * @param _data               The data to be passed to the contract\n     * @param _target            The address of the contract to call\n     *\n     * @return tokenAmountBought  The amount of buyToken bought\n     */\n    function executeTrade(\n        address _sellToken,\n        uint256 _sellQuantity,\n        address _buyToken,\n        uint256 _minBuyQuantity,\n        bytes memory _data,\n        address payable _target\n    ) external onlyWizard returns (uint256 tokenAmountBought) {\n        require(_target != address(this), \"Cannot invoke the Chamber\");\n        require(isAllowedContract(_target), \"Target not allowed\");\n        uint256 tokenAmountBefore = IERC20(_buyToken).balanceOf(address(this));\n        uint256 currentAllowance = IERC20(_sellToken).allowance(address(this), _target);\n        if (currentAllowance < _sellQuantity) {\n            IERC20(_sellToken).safeIncreaseAllowance(\n                _target, ((_sellQuantity * 105 / 100) - currentAllowance)\n            );\n        }\n        _invokeContract(_data, _target);\n        uint256 tokenAmountAfter = IERC20(_buyToken).balanceOf(address(this));\n        tokenAmountBought = tokenAmountAfter - tokenAmountBefore;\n        require(tokenAmountBought >= _minBuyQuantity, \"Underbought buy quantity\");\n        return tokenAmountBought;\n    }\n    /**\n     * Low level call to a contract. Only allowed contracts can be called.\n     *\n     * @param _data           The encoded calldata to be passed to the contract\n     * @param _target         The address of the contract to call\n     *\n     * @return response       The response bytes from the contract call\n     */\n    function _invokeContract(bytes memory _data, address payable _target)\n        internal\n        returns (bytes memory response)\n    {\n        response = address(_target).functionCall(_data);\n        require(response.length > 0, \"Low level functionCall failed\");\n        return (response);\n    }\n}",
        "after": "/**\n *     SPDX-License-Identifier: Apache License 2.0\n *\n *     Copyright 2018 Set Labs Inc.\n *     Copyright 2022 Smash Works Inc.\n *\n *     Licensed under the Apache License, Version 2.0 (the \"License\");\n *     you may not use this file except in compliance with the License.\n *     You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n *     Unless required by applicable law or agreed to in writing, software\n *     distributed under the License is distributed on an \"AS IS\" BASIS,\n *     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *     See the License for the specific language governing permissions and\n *     limitations under the License.\n *\n *     NOTICE\n *\n *     This is a modified code from Set Labs Inc. found at\n *\n *     https://github.com/SetProtocol/set-protocol-contracts\n *\n *     All changes made by Smash Works Inc. are described and documented at\n *\n *     https://docs.arch.finance/chambers\n */\npragma solidity ^0.8.17.0;\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {Owned} from \"solmate/auth/Owned.sol\";\nimport {ReentrancyGuard} from \"solmate/utils/ReentrancyGuard.sol\";\nimport {ArrayUtils} from \"./lib/ArrayUtils.sol\";\nimport {IChamberGod} from \"./interfaces/IChamberGod.sol\";\nimport {IChamber} from \"./interfaces/IChamber.sol\";\nimport {PreciseUnitMath} from \"./lib/PreciseUnitMath.sol\";\nimport {Address} from \"@openzeppelin/contracts/utils/Address.sol\";\ncontract Chamber is IChamber, Owned, ReentrancyGuard, ERC20 {\n    /*//////////////////////////////////////////////////////////////\n                                 CONSTANTS\n    //////////////////////////////////////////////////////////////*/\n    IChamberGod private god;\n    /*//////////////////////////////////////////////////////////////\n                                 LIBRARIES\n    //////////////////////////////////////////////////////////////*/\n    using ArrayUtils for address[];\n    using SafeERC20 for IERC20;\n    using Address for address;\n    using PreciseUnitMath for uint256;\n    /*//////////////////////////////////////////////////////////////\n                            CHAMBER STORAGE\n    //////////////////////////////////////////////////////////////*/\n    address[] public constituents;\n    mapping(address => uint256) public constituentQuantities;\n    address[] public wizards;\n    address[] public managers;\n\n    address[] public allowedContracts;\n\n    uint8 private chamberLocked = 1;\n\n    /*//////////////////////////////////////////////////////////////\n                                MODIFIERS\n    //////////////////////////////////////////////////////////////*/\n\n    \n        \n          \n    \n\n        \n        Expand All\n    \n    @@ -85,6 +87,13 @@ contract Chamber is IChamber, Owned, ReentrancyGuard, ERC20 {\n  \n    modifier onlyManager() virtual {\n        require(isManager(msg.sender), \"Must be Manager\");\n        _;\n    }\n    modifier onlyWizard() virtual {\n        require(isWizard(msg.sender), \"Must be a wizard\");\n        _;\n    }\n\n    modifier chambersNonReentrant() virtual {\n        require(chamberLocked == 1, \"Non reentrancy allowed\");\n        chamberLocked = 2;\n        _;\n        chamberLocked = 1;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    \n          \n            \n    \n\n          \n          Expand Down\n          \n            \n    \n\n          \n          Expand Up\n    \n    @@ -363,6 +372,24 @@ contract Chamber is IChamber, Owned, ReentrancyGuard, ERC20 {\n  \n    /**\n     * @param _owner        Owner of the chamber\n     * @param _name         Name of the chamber token\n     * @param _symbol       Symbol of the chamber token\n     * @param _constituents Initial constituents addresses of the chamber\n     * @param _quantities   Initial quantities of the chamber constituents\n     * @param _wizards      Allowed addresses that can access onlyWizard functions\n     * @param _managers     Allowed addresses that can access onlyManager functions\n     */\n    constructor(\n        address _owner,\n        string memory _name,\n        string memory _symbol,\n        address[] memory _constituents,\n        uint256[] memory _quantities,\n        address[] memory _wizards,\n        address[] memory _managers\n    ) Owned(_owner) ERC20(_name, _symbol, 18) {\n        constituents = _constituents;\n        wizards = _wizards;\n        god = IChamberGod(msg.sender);\n        for (uint256 i = 0; i < _managers.length; i++) {\n            managers.push(_managers[i]);\n        }\n        for (uint256 j = 0; j < _constituents.length; j++) {\n            constituentQuantities[_constituents[j]] = _quantities[j];\n        }\n    }\n    /*//////////////////////////////////////////////////////////////\n                               CHAMBER MANAGEMENT\n    //////////////////////////////////////////////////////////////*/\n    /**\n     * Allows the wizard to add a new constituent to the Chamber\n     *\n     * @param _constituent The address of the constituent to add\n     */\n    function addConstituent(address _constituent) external onlyWizard {\n        require(!isConstituent(_constituent), \"Must not be constituent\");\n        constituents.push(_constituent);\n        emit ConstituentAdded(_constituent);\n    }\n    /**\n     * Allows the wizard to remove a constituent from the Chamber\n     *\n     * @param _constituent The address of the constituent to remove\n     */\n    function removeConstituent(address _constituent) external onlyWizard {\n        require(isConstituent(_constituent), \"Must be constituent\");\n        constituents.removeStorage(_constituent);\n        emit ConstituentRemoved(_constituent);\n    }\n    /**\n     * Checks if the address is a manager of the Chamber\n     *\n     * @param _manager The address of a manager\n     *\n     * @return bool True/False if the address is a manager or not\n     */\n    function isManager(address _manager) public view returns (bool) {\n        return managers.contains(_manager);\n    }\n    /**\n     * Checks if the address is a wizard of the Chamber\n     *\n     * @param _wizard The address of a wizard\n     *\n     * @return bool True/False if the address is a wizard or not\n     */\n    function isWizard(address _wizard) public view returns (bool) {\n        return wizards.contains(_wizard);\n    }\n    /**\n     * Checks if the address is a constituent of the Chamber\n     *\n     * @param _constituent The address of a constituent\n     *\n     * @return bool True/False if the address is a constituent or not\n     */\n    function isConstituent(address _constituent) public view returns (bool) {\n        return constituents.contains(_constituent);\n    }\n    /**\n     * Allows the Owner to add a new manager to the Chamber\n     *\n     * @param _manager The address of the manager to add\n     */\n    function addManager(address _manager) external onlyOwner {\n        require(!isManager(_manager), \"Already manager\");\n        require(_manager != address(0), \"Cannot add null address\");\n        managers.push(_manager);\n        emit ManagerAdded(_manager);\n    }\n    /**\n     * Allows the Owner to remove a manager from the Chamber\n     *\n     * @param _manager The address of the manager to remove\n     */\n    function removeManager(address _manager) external onlyOwner {\n        require(isManager(_manager), \"Not a manager\");\n        managers.removeStorage(_manager);\n        emit ManagerRemoved(_manager);\n    }\n    /**\n     * Allows a Manager to add a new wizard to the Chamber\n     *\n     * @param _wizard The address of the wizard to add\n     */\n    function addWizard(address _wizard) external onlyManager {\n        require(god.isWizard(_wizard), \"Wizard not validated in ChamberGod\");\n        require(!isWizard(_wizard), \"Wizard already in Chamber\");\n        wizards.push(_wizard);\n        emit WizardAdded(_wizard);\n    }\n    /**\n     * Allows a Manager to remove a wizard from the Chamber\n     *\n     * @param _wizard The address of the wizard to remove\n     */\n    function removeWizard(address _wizard) external onlyManager {\n        require(isWizard(_wizard), \"Wizard not in chamber\");\n        wizards.removeStorage(_wizard);\n        emit WizardRemoved(_wizard);\n    }\n    /**\n     * Returns an array with the addresses of all the constituents of the\n     * Chamber\n     *\n     * @return an array of addresses for the constituents\n     */\n    function getConstituentsAddresses() external view returns (address[] memory) {\n        return constituents;\n    }\n    /**\n     * Returns an array with the quantities of all the constituents of the\n     * Chamber\n     *\n     * @return an array of uint256 for the quantities of the constituents\n     */\n    function getQuantities() external view returns (uint256[] memory) {\n        uint256[] memory quantities = new uint256[](constituents.length);\n        for (uint256 i = 0; i < constituents.length; i++) {\n            quantities[i] = constituentQuantities[constituents[i]];\n        }\n        return quantities;\n    }\n    /**\n     * Returns the quantity of a constituent of the Chamber\n     *\n     * @param _constituent The address of the constituent\n     *\n     * @return uint256 The quantity of the constituent\n     */\n    function getConstituentQuantity(address _constituent) external view returns (uint256) {\n        return constituentQuantities[_constituent];\n    }\n    /**\n     * Returns the addresses of all the wizards of the Chamber\n     *\n     * @return address[] Array containing the addresses of the wizards of the Chamber\n     */\n    function getWizards() external view returns (address[] memory) {\n        return wizards;\n    }\n    /**\n     * Returns the addresses of all the managers of the Chamber\n     *\n     * @return address[] Array containing the addresses of the managers of the Chamber\n     */\n    function getManagers() external view returns (address[] memory) {\n        return managers;\n    }\n    /**\n     * Returns the addresses of all the allowedContracts of the Chamber\n     *\n     * @return address[] Array containing the addresses of the allowedContracts of the Chamber\n     */\n    function getAllowedContracts() external view returns (address[] memory) {\n        return allowedContracts;\n    }\n    /**\n     * Allows a Manager to add a new allowedContract to the Chamber\n     *\n     * @param _target The address of the allowedContract to add\n     */\n    function addAllowedContract(address _target) external onlyManager {\n        require(god.isAllowedContract(_target), \"Contract not allowed in ChamberGod\");\n        require(!isAllowedContract(_target), \"Contract already allowed\");\n        allowedContracts.push(_target);\n        emit AllowedContractAdded(_target);\n    }\n    /**\n     * Allows a Manager to remove an allowedContract from the Chamber\n     *\n     * @param _target The address of the allowedContract to remove\n     */\n    function removeAllowedContract(address _target) external onlyManager {\n        require(isAllowedContract(_target), \"Contract not allowed\");\n        allowedContracts.removeStorage(_target);\n        emit AllowedContractRemoved(_target);\n    }\n    /**\n     * Checks if the address is an allowedContract of the Chamber\n     *\n     * @param _target The address of an allowedContract\n     *\n     * @return bool True/False if the address is an allowedContract or not\n     */\n    function isAllowedContract(address _target) public view returns (bool) {\n        return allowedContracts.contains(_target);\n    }\n    /*//////////////////////////////////////////////////////////////\n                               CHAMBER LOGIC\n    //////////////////////////////////////////////////////////////*/\n    /**\n     * Allows a wizard to mint an specific amount of chamber tokens\n     * to a recipient\n     *\n     * @param _recipient   The address of the recipient\n     * @param _quantity    The quantity of the chamber to mint\n     */\n    function mint(address _recipient, uint256 _quantity) external onlyWizard nonReentrant {\n        _mint(_recipient, _quantity);\n    }\n    /**\n     * Allows a wizard to burn an specific amount of chamber tokens\n     * from a source\n     *\n     * @param _from          The address of the source to burn from\n     * @param _quantity      The quantity of the chamber tokens to burn\n     */\n    function burn(address _from, uint256 _quantity) external onlyWizard nonReentrant {\n        _burn(_from, _quantity);\n    }\n\n    /**\n     * Locks the chamber from potentially malicious outside calls of contracts\n     * that were not created by arch-protocol\n     */\n    function lockChamber() external onlyWizard nonReentrant {\n        require(chamberLocked == 1, \"Chamber locked\");\n        chamberLocked = 2;\n    }\n\n    /**\n     * Unlocks the chamber from potentially malicious outside calls of contracts\n     * that were not created by arch-protocol\n     */\n    function unlockChamber() external onlyWizard nonReentrant {\n        require(chamberLocked == 2, \"Chamber already unlocked\");\n        chamberLocked = 1;\n    }\n\n    /**\n     * Allows a wizard to transfer an specific amount of constituent tokens\n     * to a recipient\n\n    \n        \n          \n    \n\n        \n        Expand All\n    \n    @@ -374,6 +401,7 @@ contract Chamber is IChamber, Owned, ReentrancyGuard, ERC20 {\n  \n     *\n     * @param _constituent   The address of the constituent\n     * @param _recipient     The address of the recipient to transfer tokens to\n     * @param _quantity      The quantity of the constituent to transfer\n     */\n    function withdrawTo(address _constituent, address _recipient, uint256 _quantity)\n        external\n        onlyWizard\n        nonReentrant\n    {\n        if (_quantity > 0) {\n            // Retrieve current balance of token for the vault\n\n    \n        \n          \n    \n\n        \n        Expand All\n    \n    @@ -399,7 +427,7 @@ contract Chamber is IChamber, Owned, ReentrancyGuard, ERC20 {\n  \n            uint256 existingVaultBalance = IERC20(_constituent).balanceOf(address(this));\n            // Call specified ERC20 token contract to transfer tokens from Vault to user\n            IERC20(_constituent).safeTransfer(_recipient, _quantity);\n            // Verify transfer quantity is reflected in balance\n            uint256 newVaultBalance = IERC20(_constituent).balanceOf(address(this));\n            // Check to make sure current balances are as expected\n            require(\n                newVaultBalance >= existingVaultBalance - _quantity,\n                \"Chamber.withdrawTo: Invalid post-withdraw balance\"\n            );\n        }\n    }\n    /**\n     * Update the quantities of the constituents in the chamber based on the\n     * total suppply of tokens. Only considers constituents in the constituents\n     * list. Used by wizards. E.g. after an uncollateralized mint in the streaming fee wizard .\n     *\n     */\n    function updateQuantities() external onlyWizard nonReentrant chambersNonReentrant {\n        uint256 _totalSupply = totalSupply;\n        uint256 _decimals = decimals;\n        for (uint256 i = 0; i < constituents.length; i++) {\n\n    \n          \n            \n    \n\n          \n          Expand Down\n    \n    \n  \n            address _constituent = constituents[i];\n            uint256 currentBalance = IERC20(_constituent).balanceOf(address(this));\n            uint256 _newQuantity = currentBalance.preciseDiv(_totalSupply, _decimals);\n            require(_newQuantity > 0, \"Zero quantity not allowed\");\n            constituentQuantities[_constituent] = _newQuantity;\n        }\n    }\n    /**\n     * Allows wizards to make low level calls to contracts that have been\n     * added to the allowedContracts mapping.\n     *\n     * @param _sellToken          The address of the token to sell\n     * @param _sellQuantity       The amount of sellToken to sell\n     * @param _buyToken           The address of the token to buy\n     * @param _minBuyQuantity     The minimum amount of buyToken that should be bought\n     * @param _data               The data to be passed to the contract\n     * @param _target            The address of the contract to call\n     *\n     * @return tokenAmountBought  The amount of buyToken bought\n     */\n    function executeTrade(\n        address _sellToken,\n        uint256 _sellQuantity,\n        address _buyToken,\n        uint256 _minBuyQuantity,\n        bytes memory _data,\n        address payable _target\n    ) external onlyWizard returns (uint256 tokenAmountBought) {\n        require(_target != address(this), \"Cannot invoke the Chamber\");\n        require(isAllowedContract(_target), \"Target not allowed\");\n        uint256 tokenAmountBefore = IERC20(_buyToken).balanceOf(address(this));\n        uint256 currentAllowance = IERC20(_sellToken).allowance(address(this), _target);\n        if (currentAllowance < _sellQuantity) {\n            IERC20(_sellToken).safeIncreaseAllowance(\n                _target, ((_sellQuantity * 105 / 100) - currentAllowance)\n            );\n        }\n        _invokeContract(_data, _target);\n        uint256 tokenAmountAfter = IERC20(_buyToken).balanceOf(address(this));\n        tokenAmountBought = tokenAmountAfter - tokenAmountBefore;\n        require(tokenAmountBought >= _minBuyQuantity, \"Underbought buy quantity\");\n        return tokenAmountBought;\n    }\n    /**\n     * Low level call to a contract. Only allowed contracts can be called.\n     *\n     * @param _data           The encoded calldata to be passed to the contract\n     * @param _target         The address of the contract to call\n     *\n     * @return response       The response bytes from the contract call\n     */\n    function _invokeContract(bytes memory _data, address payable _target)\n        internal\n        returns (bytes memory response)\n    {\n        response = address(_target).functionCall(_data);\n        require(response.length > 0, \"Low level functionCall failed\");\n        return (response);\n    }\n}"
    },
    {
        "tag": "arithmetic",
        "url": "https://github.com/FastLane-Labs/atlas/commit/c9b4f86bfa977750f9a849128446abc29bf0ce4c",
        "file": "src/contracts/atlas/Atlas.sol",
        "before": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.22;\nimport { SafeTransferLib, ERC20 } from \"solmate/utils/SafeTransferLib.sol\";\nimport { LibSort } from \"solady/utils/LibSort.sol\";\nimport { IAtlasVerification } from \"src/contracts/interfaces/IAtlasVerification.sol\";\nimport { Escrow } from \"./Escrow.sol\";\nimport { Factory } from \"./Factory.sol\";\nimport \"src/contracts/types/SolverCallTypes.sol\";\nimport \"src/contracts/types/UserCallTypes.sol\";\nimport \"src/contracts/types/LockTypes.sol\";\nimport \"src/contracts/types/DAppApprovalTypes.sol\";\nimport \"src/contracts/types/ValidCallsTypes.sol\";\nimport { CallBits } from \"src/contracts/libraries/CallBits.sol\";\nimport { SafetyBits } from \"src/contracts/libraries/SafetyBits.sol\";\n/// @title Atlas V1\n/// @author FastLane Labs\n/// @notice The Execution Abstraction protocol.\ncontract Atlas is Escrow, Factory {\n    using CallBits for uint32;\n    using SafetyBits for EscrowKey;\n    constructor(\n        uint256 _escrowDuration,\n        address _verification,\n        address _simulator,\n        address _surchargeRecipient,\n        address _executionTemplate\n    )\n        Escrow(_escrowDuration, _verification, _simulator, _surchargeRecipient)\n        Factory(_executionTemplate)\n    { }\n    /// @notice metacall is the entrypoint function for the Atlas transactions.\n    /// @param userOp The UserOperation struct containing the user's transaction data.\n    /// @param solverOps The SolverOperation array containing the solvers' transaction data.\n    /// @param dAppOp The DAppOperation struct containing the DApp's transaction data.\n    function metacall(\n        UserOperation calldata userOp, // set by user\n        SolverOperation[] calldata solverOps, // supplied by ops relay\n        DAppOperation calldata dAppOp // supplied by front end via atlas SDK\n    )\n        external\n        payable\n        returns (bool auctionWon)\n    {\n        uint256 gasMarker = gasleft(); // + 21_000 + (msg.data.length * _CALLDATA_LENGTH_PREMIUM);\n        bool isSimulation = msg.sender == SIMULATOR;\n        (address executionEnvironment, DAppConfig memory dConfig) = _getOrCreateExecutionEnvironment(userOp);\n        // Gracefully return if not valid. This allows signature data to be stored, which helps prevent\n        // replay attacks.\n        // NOTE: Currently reverting instead of graceful return to help w/ testing. TODO - still reverting?\n        (bytes32 userOpHash, ValidCallsResult validCallsResult) = IAtlasVerification(VERIFICATION).validateCalls(\n            dConfig, userOp, solverOps, dAppOp, msg.value, msg.sender, isSimulation\n        );\n        if (validCallsResult != ValidCallsResult.Valid) {\n            if (isSimulation) revert VerificationSimFail(uint256(validCallsResult));\n            else revert ValidCalls(validCallsResult);\n        }\n        // Initialize the lock\n        _setAtlasLock(executionEnvironment, gasMarker, userOp.value);\n        try this.execute{ value: msg.value }(dConfig, userOp, solverOps, executionEnvironment, msg.sender, userOpHash)\n        returns (bool _auctionWon, uint256 winningSolverIndex) {\n            auctionWon = _auctionWon;\n            // Gas Refund to sender only if execution is successful\n            (uint256 ethPaidToBundler, uint256 netGasSurcharge) = _settle({\n                winningSolver: auctionWon ? solverOps[winningSolverIndex].from : msg.sender,\n                bundler: msg.sender\n            });\n            emit MetacallResult(\n                msg.sender,\n                userOp.from,\n                auctionWon ? solverOps[winningSolverIndex].from : address(0),\n                ethPaidToBundler,\n                netGasSurcharge\n            );\n        } catch (bytes memory revertData) {\n            // Bubble up some specific errors\n            _handleErrors(revertData, dConfig.callConfig);\n            // Refund the msg.value to sender if it errored\n            if (msg.value != 0) SafeTransferLib.safeTransferETH(msg.sender, msg.value);\n        }\n        // Release the lock\n        _releaseAtlasLock();\n    }\n    /// @notice execute is called above, in a try-catch block in metacall.\n    /// @param dConfig Configuration data for the DApp involved, containing execution parameters and settings.\n    /// @param userOp UserOperation struct of the current metacall tx.\n    /// @param solverOps SolverOperation array of the current metacall tx.\n    /// @param executionEnvironment Address of the execution environment contract of the current metacall tx.\n    /// @param bundler Address of the bundler of the current metacall tx.\n    /// @param userOpHash Hash of the userOp struct of the current metacall tx.\n    /// @return auctionWon Boolean indicating whether the auction was won\n    /// @return uint256 The solver outcome bitmap\n    function execute(\n        DAppConfig calldata dConfig,\n        UserOperation calldata userOp,\n        SolverOperation[] calldata solverOps,\n        address executionEnvironment,\n        address bundler,\n        bytes32 userOpHash\n    )\n        external\n        payable\n        returns (bool auctionWon, uint256)\n    {\n        // This is a self.call made externally so that it can be used with try/catch\n        if (msg.sender != address(this)) revert InvalidAccess();\n        (bytes memory returnData, EscrowKey memory key) =\n            _preOpsUserExecutionIteration(dConfig, userOp, solverOps, executionEnvironment, bundler, userOpHash);\n        if (dConfig.callConfig.exPostBids()) {\n            (auctionWon, key) = _bidFindingIteration(dConfig, userOp, solverOps, returnData, key);\n        } else {\n            (auctionWon, key) = _bidKnownIteration(dConfig, userOp, solverOps, returnData, key);\n        }\n        // If no solver was successful, handle revert decision\n        if (!auctionWon) {\n            if (key.isSimulation) revert SolverSimFail(uint256(key.solverOutcome));\n            if (dConfig.callConfig.needsFulfillment()) {\n                revert UserNotFulfilled(); // revert(\"ERR-E003 SolverFulfillmentFailure\");\n            }\n        }\n        if (dConfig.callConfig.needsPostOpsCall()) {\n            // NOTE: key.addressPointer currently points at address(0) if all solvers fail.\n            // TODO: point key.addressPointer at bundler if all fail.\n            key = key.holdPostOpsLock(); // preserves addressPointer of winning solver\n            bool callSuccessful = _executePostOpsCall(auctionWon, returnData, key);\n            if (!callSuccessful) {\n                if (key.isSimulation) revert PostOpsSimFail();\n                else revert PostOpsFail();\n            }\n        }\n        return (auctionWon, uint256(key.solverOutcome));\n    }\n    /// @notice Called above in `execute`, this function executes the preOps and userOp calls.\n    /// @param dConfig Configuration data for the DApp involved, containing execution parameters and settings.\n    /// @param userOp UserOperation struct of the current metacall tx.\n    /// @param solverOps SolverOperation array of the current metacall tx.\n    /// @param executionEnvironment Address of the execution environment contract of the current metacall tx.\n    /// @param bundler Address of the bundler of the current metacall tx.\n    /// @param userOpHash Hash of the userOp struct of the current metacall tx.\n    /// @return bytes returnData returned from the preOps and/or userOp calls.\n    /// @return EscrowKey struct containing the current state of the escrow lock.\n    function _preOpsUserExecutionIteration(\n        DAppConfig calldata dConfig,\n        UserOperation calldata userOp,\n        SolverOperation[] calldata solverOps,\n        address executionEnvironment,\n        address bundler,\n        bytes32 userOpHash\n    )\n        internal\n        returns (bytes memory, EscrowKey memory)\n    {\n        bool callSuccessful;\n        bool usePreOpsReturnData;\n        bytes memory returnData;\n        // Build the memory lock\n        EscrowKey memory key = _buildEscrowLock(\n            dConfig, executionEnvironment, userOpHash, bundler, uint8(solverOps.length), bundler == SIMULATOR\n        );\n        if (dConfig.callConfig.needsPreOpsCall()) {\n            // CASE: Need PreOps Call\n            key = key.holdPreOpsLock(dConfig.to);\n            if (CallBits.needsPreOpsReturnData(dConfig.callConfig)) {\n                // CASE: Need PreOps return data\n                usePreOpsReturnData = true;\n                (callSuccessful, returnData) = _executePreOpsCall(userOp, executionEnvironment, key.pack());\n            } else {\n                // CASE: Ignore PreOps return data\n                (callSuccessful,) = _executePreOpsCall(userOp, executionEnvironment, key.pack());\n            }\n            if (!callSuccessful) {\n                if (key.isSimulation) revert PreOpsSimFail();\n                else revert PreOpsFail();\n            }\n        }\n        key = key.holdUserLock(userOp.dapp);\n        if (CallBits.needsUserReturnData(dConfig.callConfig)) {\n            // CASE: Need User return data\n            if (usePreOpsReturnData) {\n                // CASE: Need PreOps return Data, Need User return data\n                bytes memory userReturnData;\n                (callSuccessful, userReturnData) = _executeUserOperation(userOp, executionEnvironment, key.pack());\n                returnData = bytes.concat(returnData, userReturnData);\n            } else {\n                // CASE: Ignore PreOps return data, Need User return data\n                (callSuccessful, returnData) = _executeUserOperation(userOp, executionEnvironment, key.pack());\n            }\n        } else {\n            // CASE: Ignore User return data\n            (callSuccessful,) = _executeUserOperation(userOp, executionEnvironment, key.pack());\n        }\n        if (!callSuccessful) {\n            if (key.isSimulation) revert UserOpSimFail();\n            else revert UserOpFail();\n        }\n        return (returnData, key);\n    }\n    /// @notice Called above in `execute` if the DAppConfig requires ex post bids. Sorts solverOps by bid amount and\n    /// executes them in descending order until a successful winner is found.\n    /// @param dConfig Configuration data for the DApp involved, containing execution parameters and settings.\n    /// @param userOp UserOperation struct of the current metacall tx.\n    /// @param solverOps SolverOperation array of the current metacall tx.\n    /// @param returnData Return data from the preOps and userOp calls.\n    /// @param key EscrowKey struct containing the current state of the escrow lock.\n    /// @return auctionWon bool indicating whether a winning solver was found or not.\n    /// @return EscrowKey struct containing the current state of the escrow lock.\n    function _bidFindingIteration(\n        DAppConfig calldata dConfig,\n        UserOperation calldata userOp,\n        SolverOperation[] calldata solverOps,\n        bytes memory returnData,\n        EscrowKey memory key\n    )\n        internal\n        returns (bool auctionWon, EscrowKey memory)\n    {\n        key.bidFind = true;\n        uint256[] memory bidsAndIndices = new uint256[](solverOps.length);\n        uint256 zeroBidCount;\n        uint256 bidAmountFound;\n        uint256 bidsAndIndicesLastIndex = bidsAndIndices.length - 1; // computed once for efficiency\n        // First, get all bid amounts. Bids of zero are ignored by only storing non-zero bids in the array, from right\n        // to left. If there are any zero bids they will end up on the left as uint(0) values - in their sorted\n        // position. This reduces operations needed later when sorting the array in ascending order.\n        // Each non-zero bid amount is packed with its original solverOps array index, to fit into a uint256 value. The\n        // order of bidAmount and index is important - with bidAmount using the most significant bits, and considering\n        // we do not store zero bids in the array, the index values within the uint256 should not impact the sorting.\n        // |<------------------------- uint256 (256 bits) ------------------------->|\n        // |                                                                        |\n        // |<------------------ uint240 ----------------->|<-------- uint16 ------->|\n        // |                                              |                         |\n        // |                    bidAmount                 |          index          |\n        // |                                              |                         |\n        // |<------------------ 240 bits ---------------->|<------- 16 bits ------->|\n        for (uint256 i; i < solverOps.length; ++i) {\n            bidAmountFound = _getBidAmount(dConfig, userOp, solverOps[i], returnData, key);\n\n            if (bidAmountFound == 0) {\n                // Zero bids are ignored: increment zeroBidCount offset\n                unchecked {\n                    ++zeroBidCount;\n                }\n            } else {\n                if (bidAmountFound > type(uint240).max) revert BidTooHigh(i, bidAmountFound);\n\n                // Non-zero bids are packed with their original solverOps index.\n                // The array is filled with non-zero bids from the right. This causes all zero bids to be on the left -\n                // in their sorted position, so fewer operations are needed in the sorting step below.\n\n    \n          \n            \n    \n\n          \n          Expand Down\n    \n    \n  \n                bidsAndIndices[bidsAndIndicesLastIndex - (i - zeroBidCount)] =\n                    uint256(uint240(bidAmountFound) << BITS_FOR_INDEX | uint16(i));\n            }\n        }\n        // Then, sorts the uint256 array in-place, in ascending order.\n        LibSort.insertionSort(bidsAndIndices);\n        key.bidFind = false;\n        // Finally, iterate through sorted bidsAndIndices array in descending order of bidAmount.\n        for (uint256 i = bidsAndIndices.length - 1; i >= 0; --i) {\n            // Isolate the bidAmount from the packed uint256 value\n            bidAmountFound = (bidsAndIndices[i] >> BITS_FOR_INDEX) & FIRST_240_BITS_MASK;\n            // If we reach the zero bids on the left of array, break as all valid bids already checked.\n            if (bidAmountFound == 0) break;\n            // Isolate the original solverOps index from the packed uint256 value\n            uint256 solverOpsIndex = bidsAndIndices[i] & FIRST_16_BITS_MASK;\n            (auctionWon, key) = _executeSolverOperation(\n                dConfig, userOp, solverOps[solverOpsIndex], returnData, bidAmountFound, true, key\n            );\n            if (auctionWon) {\n                key = _allocateValue(dConfig, solverOps[solverOpsIndex], bidAmountFound, returnData, key);\n                key.solverOutcome = uint24(solverOpsIndex);\n                return (auctionWon, key);\n            }\n        }\n        return (auctionWon, key);\n    }\n    /// @notice Called above in `execute` as an alternative to `_bidFindingIteration`, if solverOps have already been\n    /// reliably sorted. Executes solverOps in order until a successful winner is found.\n    /// @param dConfig Configuration data for the DApp involved, containing execution parameters and settings.\n    /// @param userOp UserOperation struct of the current metacall tx.\n    /// @param solverOps SolverOperation array of the current metacall tx.\n    /// @param returnData Return data from the preOps and userOp calls.\n    /// @param key EscrowKey struct containing the current state of the escrow lock.\n    /// @return auctionWon bool indicating whether a winning solver was found or not.\n    /// @return EscrowKey struct containing the current state of the escrow lock.\n    function _bidKnownIteration(\n        DAppConfig calldata dConfig,\n        UserOperation calldata userOp,\n        SolverOperation[] calldata solverOps,\n        bytes memory returnData,\n        EscrowKey memory key\n    )\n        internal\n        returns (bool auctionWon, EscrowKey memory)\n    {\n        uint256 k = solverOps.length;\n        uint256 i;\n        for (; i < k;) {\n            // valid solverOps are packed from left of array - break at first invalid solverOp\n            SolverOperation calldata solverOp = solverOps[i];\n            (auctionWon, key) =\n                _executeSolverOperation(dConfig, userOp, solverOp, returnData, solverOp.bidAmount, false, key);\n            if (auctionWon) {\n                key = _allocateValue(dConfig, solverOp, solverOp.bidAmount, returnData, key);\n                key.solverOutcome = uint24(i);\n                return (auctionWon, key);\n            }\n            unchecked {\n                ++i;\n            }\n        }\n        return (auctionWon, key);\n    }\n    /// @notice Called at the end of `metacall` to bubble up specific error info in a revert.\n    /// @param revertData Revert data from a failure during the execution of the metacall.\n    /// @param callConfig The CallConfig of the current metacall tx.\n    function _handleErrors(bytes memory revertData, uint32 callConfig) internal view {\n        bytes4 errorSwitch = bytes4(revertData);\n        if (msg.sender == SIMULATOR) {\n            // Simulation\n            if (errorSwitch == PreOpsSimFail.selector) {\n                revert PreOpsSimFail();\n            } else if (errorSwitch == UserOpSimFail.selector) {\n                revert UserOpSimFail();\n            } else if (errorSwitch == SolverSimFail.selector) {\n                // Expects revertData in form [bytes4, uint256]\n                uint256 solverOutcomeResult;\n                assembly {\n                    let dataLocation := add(revertData, 0x20)\n                    solverOutcomeResult := mload(add(dataLocation, sub(mload(revertData), 32)))\n                }\n                revert SolverSimFail(solverOutcomeResult);\n            } else if (errorSwitch == PostOpsSimFail.selector) {\n                revert PostOpsSimFail();\n            }\n        }\n        if (errorSwitch == UserNotFulfilled.selector) {\n            revert UserNotFulfilled();\n        }\n        if (callConfig.allowsReuseUserOps()) {\n            assembly {\n                mstore(0, errorSwitch)\n                revert(0, 4)\n            }\n        }\n    }\n    /// @notice Reverts if the caller is not the execution environment address expected from the set of inputs.\n    /// @param user User address\n    /// @param controller DAppControl contract address\n    /// @param callConfig CallConfig of the current metacall tx.\n    function _verifyCallerIsExecutionEnv(address user, address controller, uint32 callConfig) internal view override {\n        if (msg.sender != _getExecutionEnvironmentCustom(user, controller.codehash, controller, callConfig)) {\n            revert EnvironmentMismatch();\n        }\n    }\n}",
        "after": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.22;\nimport { SafeTransferLib, ERC20 } from \"solmate/utils/SafeTransferLib.sol\";\nimport { LibSort } from \"solady/utils/LibSort.sol\";\nimport { IAtlasVerification } from \"src/contracts/interfaces/IAtlasVerification.sol\";\nimport { Escrow } from \"./Escrow.sol\";\nimport { Factory } from \"./Factory.sol\";\nimport \"src/contracts/types/SolverCallTypes.sol\";\nimport \"src/contracts/types/UserCallTypes.sol\";\nimport \"src/contracts/types/LockTypes.sol\";\nimport \"src/contracts/types/DAppApprovalTypes.sol\";\nimport \"src/contracts/types/ValidCallsTypes.sol\";\nimport { CallBits } from \"src/contracts/libraries/CallBits.sol\";\nimport { SafetyBits } from \"src/contracts/libraries/SafetyBits.sol\";\n/// @title Atlas V1\n/// @author FastLane Labs\n/// @notice The Execution Abstraction protocol.\ncontract Atlas is Escrow, Factory {\n    using CallBits for uint32;\n    using SafetyBits for EscrowKey;\n    constructor(\n        uint256 _escrowDuration,\n        address _verification,\n        address _simulator,\n        address _surchargeRecipient,\n        address _executionTemplate\n    )\n        Escrow(_escrowDuration, _verification, _simulator, _surchargeRecipient)\n        Factory(_executionTemplate)\n    { }\n    /// @notice metacall is the entrypoint function for the Atlas transactions.\n    /// @param userOp The UserOperation struct containing the user's transaction data.\n    /// @param solverOps The SolverOperation array containing the solvers' transaction data.\n    /// @param dAppOp The DAppOperation struct containing the DApp's transaction data.\n    function metacall(\n        UserOperation calldata userOp, // set by user\n        SolverOperation[] calldata solverOps, // supplied by ops relay\n        DAppOperation calldata dAppOp // supplied by front end via atlas SDK\n    )\n        external\n        payable\n        returns (bool auctionWon)\n    {\n        uint256 gasMarker = gasleft(); // + 21_000 + (msg.data.length * _CALLDATA_LENGTH_PREMIUM);\n        bool isSimulation = msg.sender == SIMULATOR;\n        (address executionEnvironment, DAppConfig memory dConfig) = _getOrCreateExecutionEnvironment(userOp);\n        // Gracefully return if not valid. This allows signature data to be stored, which helps prevent\n        // replay attacks.\n        // NOTE: Currently reverting instead of graceful return to help w/ testing. TODO - still reverting?\n        (bytes32 userOpHash, ValidCallsResult validCallsResult) = IAtlasVerification(VERIFICATION).validateCalls(\n            dConfig, userOp, solverOps, dAppOp, msg.value, msg.sender, isSimulation\n        );\n        if (validCallsResult != ValidCallsResult.Valid) {\n            if (isSimulation) revert VerificationSimFail(uint256(validCallsResult));\n            else revert ValidCalls(validCallsResult);\n        }\n        // Initialize the lock\n        _setAtlasLock(executionEnvironment, gasMarker, userOp.value);\n        try this.execute{ value: msg.value }(dConfig, userOp, solverOps, executionEnvironment, msg.sender, userOpHash)\n        returns (bool _auctionWon, uint256 winningSolverIndex) {\n            auctionWon = _auctionWon;\n            // Gas Refund to sender only if execution is successful\n            (uint256 ethPaidToBundler, uint256 netGasSurcharge) = _settle({\n                winningSolver: auctionWon ? solverOps[winningSolverIndex].from : msg.sender,\n                bundler: msg.sender\n            });\n            emit MetacallResult(\n                msg.sender,\n                userOp.from,\n                auctionWon ? solverOps[winningSolverIndex].from : address(0),\n                ethPaidToBundler,\n                netGasSurcharge\n            );\n        } catch (bytes memory revertData) {\n            // Bubble up some specific errors\n            _handleErrors(revertData, dConfig.callConfig);\n            // Refund the msg.value to sender if it errored\n            if (msg.value != 0) SafeTransferLib.safeTransferETH(msg.sender, msg.value);\n        }\n        // Release the lock\n        _releaseAtlasLock();\n    }\n    /// @notice execute is called above, in a try-catch block in metacall.\n    /// @param dConfig Configuration data for the DApp involved, containing execution parameters and settings.\n    /// @param userOp UserOperation struct of the current metacall tx.\n    /// @param solverOps SolverOperation array of the current metacall tx.\n    /// @param executionEnvironment Address of the execution environment contract of the current metacall tx.\n    /// @param bundler Address of the bundler of the current metacall tx.\n    /// @param userOpHash Hash of the userOp struct of the current metacall tx.\n    /// @return auctionWon Boolean indicating whether the auction was won\n    /// @return uint256 The solver outcome bitmap\n    function execute(\n        DAppConfig calldata dConfig,\n        UserOperation calldata userOp,\n        SolverOperation[] calldata solverOps,\n        address executionEnvironment,\n        address bundler,\n        bytes32 userOpHash\n    )\n        external\n        payable\n        returns (bool auctionWon, uint256)\n    {\n        // This is a self.call made externally so that it can be used with try/catch\n        if (msg.sender != address(this)) revert InvalidAccess();\n        (bytes memory returnData, EscrowKey memory key) =\n            _preOpsUserExecutionIteration(dConfig, userOp, solverOps, executionEnvironment, bundler, userOpHash);\n        if (dConfig.callConfig.exPostBids()) {\n            (auctionWon, key) = _bidFindingIteration(dConfig, userOp, solverOps, returnData, key);\n        } else {\n            (auctionWon, key) = _bidKnownIteration(dConfig, userOp, solverOps, returnData, key);\n        }\n        // If no solver was successful, handle revert decision\n        if (!auctionWon) {\n            if (key.isSimulation) revert SolverSimFail(uint256(key.solverOutcome));\n            if (dConfig.callConfig.needsFulfillment()) {\n                revert UserNotFulfilled(); // revert(\"ERR-E003 SolverFulfillmentFailure\");\n            }\n        }\n        if (dConfig.callConfig.needsPostOpsCall()) {\n            // NOTE: key.addressPointer currently points at address(0) if all solvers fail.\n            // TODO: point key.addressPointer at bundler if all fail.\n            key = key.holdPostOpsLock(); // preserves addressPointer of winning solver\n            bool callSuccessful = _executePostOpsCall(auctionWon, returnData, key);\n            if (!callSuccessful) {\n                if (key.isSimulation) revert PostOpsSimFail();\n                else revert PostOpsFail();\n            }\n        }\n        return (auctionWon, uint256(key.solverOutcome));\n    }\n    /// @notice Called above in `execute`, this function executes the preOps and userOp calls.\n    /// @param dConfig Configuration data for the DApp involved, containing execution parameters and settings.\n    /// @param userOp UserOperation struct of the current metacall tx.\n    /// @param solverOps SolverOperation array of the current metacall tx.\n    /// @param executionEnvironment Address of the execution environment contract of the current metacall tx.\n    /// @param bundler Address of the bundler of the current metacall tx.\n    /// @param userOpHash Hash of the userOp struct of the current metacall tx.\n    /// @return bytes returnData returned from the preOps and/or userOp calls.\n    /// @return EscrowKey struct containing the current state of the escrow lock.\n    function _preOpsUserExecutionIteration(\n        DAppConfig calldata dConfig,\n        UserOperation calldata userOp,\n        SolverOperation[] calldata solverOps,\n        address executionEnvironment,\n        address bundler,\n        bytes32 userOpHash\n    )\n        internal\n        returns (bytes memory, EscrowKey memory)\n    {\n        bool callSuccessful;\n        bool usePreOpsReturnData;\n        bytes memory returnData;\n        // Build the memory lock\n        EscrowKey memory key = _buildEscrowLock(\n            dConfig, executionEnvironment, userOpHash, bundler, uint8(solverOps.length), bundler == SIMULATOR\n        );\n        if (dConfig.callConfig.needsPreOpsCall()) {\n            // CASE: Need PreOps Call\n            key = key.holdPreOpsLock(dConfig.to);\n            if (CallBits.needsPreOpsReturnData(dConfig.callConfig)) {\n                // CASE: Need PreOps return data\n                usePreOpsReturnData = true;\n                (callSuccessful, returnData) = _executePreOpsCall(userOp, executionEnvironment, key.pack());\n            } else {\n                // CASE: Ignore PreOps return data\n                (callSuccessful,) = _executePreOpsCall(userOp, executionEnvironment, key.pack());\n            }\n            if (!callSuccessful) {\n                if (key.isSimulation) revert PreOpsSimFail();\n                else revert PreOpsFail();\n            }\n        }\n        key = key.holdUserLock(userOp.dapp);\n        if (CallBits.needsUserReturnData(dConfig.callConfig)) {\n            // CASE: Need User return data\n            if (usePreOpsReturnData) {\n                // CASE: Need PreOps return Data, Need User return data\n                bytes memory userReturnData;\n                (callSuccessful, userReturnData) = _executeUserOperation(userOp, executionEnvironment, key.pack());\n                returnData = bytes.concat(returnData, userReturnData);\n            } else {\n                // CASE: Ignore PreOps return data, Need User return data\n                (callSuccessful, returnData) = _executeUserOperation(userOp, executionEnvironment, key.pack());\n            }\n        } else {\n            // CASE: Ignore User return data\n            (callSuccessful,) = _executeUserOperation(userOp, executionEnvironment, key.pack());\n        }\n        if (!callSuccessful) {\n            if (key.isSimulation) revert UserOpSimFail();\n            else revert UserOpFail();\n        }\n        return (returnData, key);\n    }\n    /// @notice Called above in `execute` if the DAppConfig requires ex post bids. Sorts solverOps by bid amount and\n    /// executes them in descending order until a successful winner is found.\n    /// @param dConfig Configuration data for the DApp involved, containing execution parameters and settings.\n    /// @param userOp UserOperation struct of the current metacall tx.\n    /// @param solverOps SolverOperation array of the current metacall tx.\n    /// @param returnData Return data from the preOps and userOp calls.\n    /// @param key EscrowKey struct containing the current state of the escrow lock.\n    /// @return auctionWon bool indicating whether a winning solver was found or not.\n    /// @return EscrowKey struct containing the current state of the escrow lock.\n    function _bidFindingIteration(\n        DAppConfig calldata dConfig,\n        UserOperation calldata userOp,\n        SolverOperation[] calldata solverOps,\n        bytes memory returnData,\n        EscrowKey memory key\n    )\n        internal\n        returns (bool auctionWon, EscrowKey memory)\n    {\n        key.bidFind = true;\n        uint256[] memory bidsAndIndices = new uint256[](solverOps.length);\n        uint256 zeroBidCount;\n        uint256 bidAmountFound;\n        uint256 bidsAndIndicesLastIndex = bidsAndIndices.length - 1; // computed once for efficiency\n        // First, get all bid amounts. Bids of zero are ignored by only storing non-zero bids in the array, from right\n        // to left. If there are any zero bids they will end up on the left as uint(0) values - in their sorted\n        // position. This reduces operations needed later when sorting the array in ascending order.\n        // Each non-zero bid amount is packed with its original solverOps array index, to fit into a uint256 value. The\n        // order of bidAmount and index is important - with bidAmount using the most significant bits, and considering\n        // we do not store zero bids in the array, the index values within the uint256 should not impact the sorting.\n        // |<------------------------- uint256 (256 bits) ------------------------->|\n        // |                                                                        |\n        // |<------------------ uint240 ----------------->|<-------- uint16 ------->|\n        // |                                              |                         |\n        // |                    bidAmount                 |          index          |\n        // |                                              |                         |\n        // |<------------------ 240 bits ---------------->|<------- 16 bits ------->|\n        for (uint256 i; i < solverOps.length; ++i) {\n            bidAmountFound = _getBidAmount(dConfig, userOp, solverOps[i], returnData, key);\n\n            if (bidAmountFound == 0 || bidAmountFound > type(uint240).max) {\n                // Zero bids are ignored: increment zeroBidCount offset\n                // Bids that would cause an overflow are also ignored\n                unchecked {\n                    ++zeroBidCount;\n                }\n            } else {\n                // Non-zero bids are packed with their original solverOps index.\n                // The array is filled with non-zero bids from the right. This causes all zero bids to be on the left -\n                // in their sorted position, so fewer operations are needed in the sorting step below.\n\n    \n          \n            \n    \n\n          \n          Expand Down\n    \n    \n  \n                bidsAndIndices[bidsAndIndicesLastIndex - (i - zeroBidCount)] =\n                    uint256(uint240(bidAmountFound) << BITS_FOR_INDEX | uint16(i));\n            }\n        }\n        // Then, sorts the uint256 array in-place, in ascending order.\n        LibSort.insertionSort(bidsAndIndices);\n        key.bidFind = false;\n        // Finally, iterate through sorted bidsAndIndices array in descending order of bidAmount.\n        for (uint256 i = bidsAndIndices.length - 1; i >= 0; --i) {\n            // Isolate the bidAmount from the packed uint256 value\n            bidAmountFound = (bidsAndIndices[i] >> BITS_FOR_INDEX) & FIRST_240_BITS_MASK;\n            // If we reach the zero bids on the left of array, break as all valid bids already checked.\n            if (bidAmountFound == 0) break;\n            // Isolate the original solverOps index from the packed uint256 value\n            uint256 solverOpsIndex = bidsAndIndices[i] & FIRST_16_BITS_MASK;\n            (auctionWon, key) = _executeSolverOperation(\n                dConfig, userOp, solverOps[solverOpsIndex], returnData, bidAmountFound, true, key\n            );\n            if (auctionWon) {\n                key = _allocateValue(dConfig, solverOps[solverOpsIndex], bidAmountFound, returnData, key);\n                key.solverOutcome = uint24(solverOpsIndex);\n                return (auctionWon, key);\n            }\n        }\n        return (auctionWon, key);\n    }\n    /// @notice Called above in `execute` as an alternative to `_bidFindingIteration`, if solverOps have already been\n    /// reliably sorted. Executes solverOps in order until a successful winner is found.\n    /// @param dConfig Configuration data for the DApp involved, containing execution parameters and settings.\n    /// @param userOp UserOperation struct of the current metacall tx.\n    /// @param solverOps SolverOperation array of the current metacall tx.\n    /// @param returnData Return data from the preOps and userOp calls.\n    /// @param key EscrowKey struct containing the current state of the escrow lock.\n    /// @return auctionWon bool indicating whether a winning solver was found or not.\n    /// @return EscrowKey struct containing the current state of the escrow lock.\n    function _bidKnownIteration(\n        DAppConfig calldata dConfig,\n        UserOperation calldata userOp,\n        SolverOperation[] calldata solverOps,\n        bytes memory returnData,\n        EscrowKey memory key\n    )\n        internal\n        returns (bool auctionWon, EscrowKey memory)\n    {\n        uint256 k = solverOps.length;\n        uint256 i;\n        for (; i < k;) {\n            // valid solverOps are packed from left of array - break at first invalid solverOp\n            SolverOperation calldata solverOp = solverOps[i];\n            (auctionWon, key) =\n                _executeSolverOperation(dConfig, userOp, solverOp, returnData, solverOp.bidAmount, false, key);\n            if (auctionWon) {\n                key = _allocateValue(dConfig, solverOp, solverOp.bidAmount, returnData, key);\n                key.solverOutcome = uint24(i);\n                return (auctionWon, key);\n            }\n            unchecked {\n                ++i;\n            }\n        }\n        return (auctionWon, key);\n    }\n    /// @notice Called at the end of `metacall` to bubble up specific error info in a revert.\n    /// @param revertData Revert data from a failure during the execution of the metacall.\n    /// @param callConfig The CallConfig of the current metacall tx.\n    function _handleErrors(bytes memory revertData, uint32 callConfig) internal view {\n        bytes4 errorSwitch = bytes4(revertData);\n        if (msg.sender == SIMULATOR) {\n            // Simulation\n            if (errorSwitch == PreOpsSimFail.selector) {\n                revert PreOpsSimFail();\n            } else if (errorSwitch == UserOpSimFail.selector) {\n                revert UserOpSimFail();\n            } else if (errorSwitch == SolverSimFail.selector) {\n                // Expects revertData in form [bytes4, uint256]\n                uint256 solverOutcomeResult;\n                assembly {\n                    let dataLocation := add(revertData, 0x20)\n                    solverOutcomeResult := mload(add(dataLocation, sub(mload(revertData), 32)))\n                }\n                revert SolverSimFail(solverOutcomeResult);\n            } else if (errorSwitch == PostOpsSimFail.selector) {\n                revert PostOpsSimFail();\n            }\n        }\n        if (errorSwitch == UserNotFulfilled.selector) {\n            revert UserNotFulfilled();\n        }\n        if (callConfig.allowsReuseUserOps()) {\n            assembly {\n                mstore(0, errorSwitch)\n                revert(0, 4)\n            }\n        }\n    }\n    /// @notice Reverts if the caller is not the execution environment address expected from the set of inputs.\n    /// @param user User address\n    /// @param controller DAppControl contract address\n    /// @param callConfig CallConfig of the current metacall tx.\n    function _verifyCallerIsExecutionEnv(address user, address controller, uint32 callConfig) internal view override {\n        if (msg.sender != _getExecutionEnvironmentCustom(user, controller.codehash, controller, callConfig)) {\n            revert EnvironmentMismatch();\n        }\n    }\n}"
    }
]